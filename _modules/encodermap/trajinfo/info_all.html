
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>encodermap.trajinfo.info_all &#8212; encodermap 3.0.1+10.g67ae638.dirty documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=c1026b93" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=ea0ca436"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=30646c52"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/encodermap/trajinfo/info_all';</script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="3.0.1+10.g67ae638.dirty" />
    <meta name="docbuild:last-update" content="2025-05-15T21:15:05"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-light" alt="encodermap 3.0.1+10.g67ae638.dirty documentation - Home"/>
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-dark pst-js-only" alt="encodermap 3.0.1+10.g67ae638.dirty documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started/index.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notebooks/index.html">
    Notebook Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started/index.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notebooks/index.html">
    Notebook Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">encodermap.trajinfo.info_all</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for encodermap.trajinfo.info_all</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># encodermap/trajinfo/info_all.py</span>
<span class="c1">################################################################################</span>
<span class="c1"># EncoderMap: A python library for dimensionality reduction.</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2019-2024 University of Konstanz and the Authors</span>
<span class="c1">#</span>
<span class="c1"># Authors:</span>
<span class="c1"># Kevin Sawade</span>
<span class="c1">#</span>
<span class="c1"># Encodermap is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as</span>
<span class="c1"># published by the Free Software Foundation, either version 2.1</span>
<span class="c1"># of the License, or (at your option) any later version.</span>
<span class="c1"># This package is distributed in the hope that it will be useful to other</span>
<span class="c1"># researches. IT DOES NOT COME WITH ANY WARRANTY WHATSOEVER; without even the</span>
<span class="c1"># implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1"># See the GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># See &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">################################################################################</span>
<span class="sd">&quot;&quot;&quot;Classes to work with ensembles of trajectories.</span>

<span class="sd">The statistics of a protein can be better described by an ensemble of proteins,</span>
<span class="sd">rather than a single long trajectory. Treating a protein in such a way opens great</span>
<span class="sd">possibilities and changes the way one can treat molecular dynamics data.</span>
<span class="sd">Trajectory ensembles allow:</span>
<span class="sd">    * Faster convergence via adaptive sampling.</span>
<span class="sd">    * Better grasp of equilibrium and off-equilibrium dynamics.</span>


<span class="sd">This subpackage contains two classes which are containers of trajectory data.</span>
<span class="sd">The SingleTraj trajectory contains information about a single trajectory.</span>
<span class="sd">The TrajEnsemble class contains information about multiple trajectories. This adds</span>
<span class="sd">a new dimension to MD data. The time and atom dimension are already established.</span>
<span class="sd">Two frames can be appended along the time axis to get a trajectory with multiple</span>
<span class="sd">frames. If they are appended along the atom axis, the new frame contains the</span>
<span class="sd">atoms of these two. The trajectory works in a similar fashion. Adding two trajectories</span>
<span class="sd">along the trajectory axis returns a trajectory ensemble, represented as a `TrajEnsemble`</span>
<span class="sd">class in this package.</span>

<span class="sd">See also:</span>
<span class="sd">    http://statisticalbiophysicsblog.org/?p=92</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">################################################################################</span>
<span class="c1"># Imports</span>
<span class="c1">################################################################################</span>


<span class="c1"># Future Imports at the top</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># Standard Library Imports</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">KeysView</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">overload</span>

<span class="c1"># Third Party Imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">from</span> <span class="nn">optional_imports</span> <span class="kn">import</span> <span class="n">_optional_import</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="k">as</span> <span class="n">normal_tqdm_</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span> <span class="k">as</span> <span class="n">notebook_tqdm_</span>

<span class="c1"># Encodermap imports</span>
<span class="kn">from</span> <span class="nn">encodermap._typing</span> <span class="kn">import</span> <span class="n">CanBeIndex</span><span class="p">,</span> <span class="n">CustomAAsDict</span>
<span class="kn">from</span> <span class="nn">encodermap.misc.misc</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">_TOPOLOGY_EXTS</span><span class="p">,</span>
    <span class="n">_is_notebook</span><span class="p">,</span>
    <span class="n">get_full_common_str_and_ref</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">encodermap.misc.xarray_save_wrong_hdf5</span> <span class="kn">import</span> <span class="n">save_netcdf_alongside_mdtraj</span>
<span class="kn">from</span> <span class="nn">encodermap.trajinfo.trajinfo_utils</span> <span class="kn">import</span> <span class="n">CustomTopology</span><span class="p">,</span> <span class="n">TrajEnsembleFeatureType</span>


<span class="c1">################################################################################</span>
<span class="c1"># Typing</span>
<span class="c1">################################################################################</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
    <span class="c1"># Third Party Imports</span>
    <span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>
    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
    <span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
    <span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>

    <span class="c1"># Encodermap imports</span>
    <span class="kn">from</span> <span class="nn">encodermap.trajinfo.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>


<span class="n">string_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Optional Imports</span>
<span class="c1">################################################################################</span>


<span class="n">md</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">)</span>
<span class="n">pd</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">)</span>
<span class="n">xr</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;xarray&quot;</span><span class="p">)</span>
<span class="n">HDF5TrajectoryFile</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;formats.hdf5&quot;</span><span class="p">)</span>
<span class="n">h5py</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;h5py&quot;</span><span class="p">)</span>

<span class="c1">################################################################################</span>
<span class="c1"># Globals</span>
<span class="c1">################################################################################</span>


<span class="n">__all__</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;TrajEnsemble&quot;</span><span class="p">]</span>


<span class="c1">################################################################################</span>
<span class="c1"># Utils</span>
<span class="c1">################################################################################</span>


<span class="k">class</span> <span class="nc">notebook_tqdm</span><span class="p">(</span><span class="n">notebook_tqdm_</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">normal_tqdm</span><span class="p">(</span><span class="n">normal_tqdm_</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">[</span><span class="n">function</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;update_calls&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s2">&quot;ENCODERMAP_PRINT_PROG_UPDATES&quot;</span><span class="p">,</span> <span class="s2">&quot;False&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;True&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INSTANTIATION&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_print</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">debug_print</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Progbar </span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">function</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">function</span><span class="si">:</span><span class="s2">&lt;15</span><span class="si">}</span><span class="s2"> total: </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2"> n: </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;update_calls&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">[</span><span class="n">function</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;update_calls&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BEFORE UPDATE (</span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug_print</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">[</span><span class="n">function</span><span class="p">][</span><span class="s2">&quot;update_calls&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print</span> <span class="ow">and</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER  UPDATE (</span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_print</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">total</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;function&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">[</span><span class="n">function</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;update_calls&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">total</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calls</span><span class="p">[</span><span class="n">function</span><span class="p">][</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="n">total</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">total</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BEFORE RESET (</span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debug_print</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total</span> <span class="o">=</span> <span class="n">total</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print</span> <span class="ow">and</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AFTER  RESET (</span><span class="si">{</span><span class="n">function</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug_print</span><span class="p">()</span>


<span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">temp_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Temporarily set a numpy seed in a context manager.</span>

<span class="sd">    Args:</span>
<span class="sd">        seed (int): The seed.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from encodermap.trajinfo.info_all import temp_seed</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; with temp_seed(123456789):</span>
<span class="sd">        ...     print(np.random.randint(low=0, high=10, size=(5, )))</span>
<span class="sd">        [8 2 9 7 4]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_mode</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">modes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This operation is only available when a file &quot;</span> <span class="s1">&#39;is open in mode=&quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span> <span class="n">m</span>
        <span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Classes</span>
<span class="c1">################################################################################</span>


<span class="k">class</span> <span class="nc">HDF5GroupWrite</span><span class="p">(</span><span class="n">md</span><span class="o">.</span><span class="n">formats</span><span class="o">.</span><span class="n">HDF5TrajectoryFile</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">KeysView</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t view keys of closed HDF5 file.&quot;</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">KeysView</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initialize_headers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">n_atoms</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">set_coordinates</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_time</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_cell</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_velocities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_kineticEnergy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_potentialEnergy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_temperature</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">set_alchemicalLambda</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.._version</span> <span class="kn">import</span> <span class="n">get_versions</span>

        <span class="n">version</span> <span class="o">=</span> <span class="n">get_versions</span><span class="p">()[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_atoms</span> <span class="o">=</span> <span class="n">n_atoms</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">conventions</span> <span class="o">=</span> <span class="s2">&quot;Pande&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">conventionVersion</span> <span class="o">=</span> <span class="s2">&quot;1.1&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">program</span> <span class="o">=</span> <span class="s2">&quot;MDTraj&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">programVersion</span> <span class="o">=</span> <span class="n">version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;title&quot;</span>

        <span class="c1"># if the client has not the title attribute themselves, we&#39;ll</span>
        <span class="c1"># set it to MDTraj as a default option.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="p">,</span> <span class="s2">&quot;application&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_attrs</span><span class="o">.</span><span class="n">application</span> <span class="o">=</span> <span class="s2">&quot;MDTraj&quot;</span>

        <span class="c1"># create arrays that store frame level informat</span>
        <span class="k">if</span> <span class="n">set_coordinates</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;coordinates_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;coordinates_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nanometers&quot;</span>

        <span class="k">if</span> <span class="n">set_time</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;time_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;time_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;picoseconds&quot;</span>

        <span class="k">if</span> <span class="n">set_cell</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;cell_lengths_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;cell_angles_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;cell_lengths_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nanometers&quot;</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;cell_angles_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;degrees&quot;</span>

        <span class="k">if</span> <span class="n">set_velocities</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;velocities_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;velocities_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nanometers/picosecond&quot;</span>

        <span class="k">if</span> <span class="n">set_kineticEnergy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;kineticEnergy_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;kineticEnergy_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kilojoules_per_mole&quot;</span>

        <span class="k">if</span> <span class="n">set_potentialEnergy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;potentialEnergy_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;potentialEnergy_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kilojoules_per_mole&quot;</span>

        <span class="k">if</span> <span class="n">set_temperature</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;temperature_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="p">)</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;temperature_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span>
                <span class="s2">&quot;units&quot;</span>
            <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;kelvin&quot;</span>

        <span class="k">if</span> <span class="n">set_alchemicalLambda</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_earray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;lambda_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">atom</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">Float32Atom</span><span class="p">(),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;lambda_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;dimensionless&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_into_group</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">coordinates</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">time</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">cell_lengths</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">cell_angles</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">topology</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">from</span> <span class="nn">mdtraj.utils</span> <span class="kn">import</span> <span class="n">ensure_type</span><span class="p">,</span> <span class="n">in_units_of</span>

        <span class="n">_check_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_frame_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;coordinates_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_needs_initialization</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_frame_index</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_needs_initialization</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># these must be either both present or both absent. since</span>
        <span class="c1"># we&#39;re going to throw an error if one is present w/o the other,</span>
        <span class="c1"># lets do it now.</span>
        <span class="k">if</span> <span class="n">cell_lengths</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cell_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_lengths were given, but no cell_angles&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cell_angles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cell_angles were given, but no cell_lengths&quot;</span><span class="p">)</span>

        <span class="c1"># if the input arrays are openmm.unit.Quantities, convert them</span>
        <span class="c1"># into md units. Note that this acts as a no-op if the user doesn&#39;t</span>
        <span class="c1"># have openmm.unit installed (e.g. they didn&#39;t install OpenMM)</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">in_units_of</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;nanometers&quot;</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">in_units_of</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;picoseconds&quot;</span><span class="p">)</span>
        <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">in_units_of</span><span class="p">(</span><span class="n">cell_lengths</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;nanometers&quot;</span><span class="p">)</span>
        <span class="n">cell_angles</span> <span class="o">=</span> <span class="n">in_units_of</span><span class="p">(</span><span class="n">cell_angles</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;degrees&quot;</span><span class="p">)</span>

        <span class="c1"># do typechecking and shapechecking on the arrays</span>
        <span class="c1"># this ensure_type method has a lot of options, but basically it lets</span>
        <span class="c1"># us validate most aspects of the array. Also, we can upconvert</span>
        <span class="c1"># on defficent ndim, which means that if the user sends in a single</span>
        <span class="c1"># frame of data (i.e. coordinates is shape=(n_atoms, 3)), we can</span>
        <span class="c1"># realize that. obviously the default mode is that they want to</span>
        <span class="c1"># write multiple frames at a time, so the coordinate shape is</span>
        <span class="c1"># (n_frames, n_atoms, 3)</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">ensure_type</span><span class="p">(</span>
            <span class="n">coordinates</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;coordinates&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">can_be_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">warn_on_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">add_newaxis_on_deficient_ndim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="p">(</span>
            <span class="n">n_frames</span><span class="p">,</span>
            <span class="n">n_atoms</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">time</span> <span class="o">=</span> <span class="n">ensure_type</span><span class="p">(</span>
            <span class="n">time</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;time&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,),</span>
            <span class="n">can_be_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">warn_on_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">add_newaxis_on_deficient_ndim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cell_lengths</span> <span class="o">=</span> <span class="n">ensure_type</span><span class="p">(</span>
            <span class="n">cell_lengths</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cell_lengths&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">can_be_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">warn_on_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">add_newaxis_on_deficient_ndim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cell_angles</span> <span class="o">=</span> <span class="n">ensure_type</span><span class="p">(</span>
            <span class="n">cell_angles</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span>
            <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;cell_angles&quot;</span><span class="p">,</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_frames</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
            <span class="n">can_be_none</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">warn_on_cast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">add_newaxis_on_deficient_ndim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if this is our first call to write(), we need to create the headers</span>
        <span class="c1"># and the arrays in the underlying HDF5 file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_initialization</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_headers</span><span class="p">(</span>
                <span class="n">group_id</span><span class="o">=</span><span class="n">group_id</span><span class="p">,</span>
                <span class="n">n_atoms</span><span class="o">=</span><span class="n">n_atoms</span><span class="p">,</span>
                <span class="n">set_coordinates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">set_time</span><span class="o">=</span><span class="p">(</span><span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">set_cell</span><span class="o">=</span><span class="p">(</span><span class="n">cell_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cell_angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
                <span class="n">set_velocities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">set_kineticEnergy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">set_potentialEnergy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">set_temperature</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">set_alchemicalLambda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_initialization</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># we need to check that that the entries that the user is trying</span>
            <span class="c1"># to save are actually fields in OUR file</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># try to get the nodes for all the fields that we have</span>
            <span class="c1"># which are not None</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;coordinates_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;time_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;cell_angles_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;cell_lengths_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">contents</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">contents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">contents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># for each attribute that they&#39;re not saving, we want</span>
                    <span class="c1"># to make sure the file doesn&#39;t explect it</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">()</span>
                    <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                        <span class="k">pass</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The file that you&#39;re trying to save to doesn&#39;t &quot;</span>
                <span class="s2">&quot;contain the field </span><span class="si">%s</span><span class="s2">. You can always save a new trajectory &quot;</span>
                <span class="s2">&quot;and have it contain this information, but I don&#39;t allow &#39;ragged&#39; &quot;</span>
                <span class="s2">&quot;arrays. If one frame is going to have </span><span class="si">%s</span><span class="s2"> information, then I expect &quot;</span>
                <span class="s2">&quot;all of them to. So I can&#39;t save it for just these frames. Sorry &quot;</span>
                <span class="s2">&quot;about that :)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The file that you&#39;re saving to expects each frame &quot;</span>
                <span class="s2">&quot;to contain </span><span class="si">%s</span><span class="s2"> information, but you did not supply it.&quot;</span>
                <span class="s2">&quot;I don&#39;t allow &#39;ragged&#39; arrays. If one frame is going &quot;</span>
                <span class="s2">&quot;to have </span><span class="si">%s</span><span class="s2"> information, then I expect all of them to. &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_frame_index</span> <span class="o">+=</span> <span class="n">n_frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_topology</span><span class="p">(</span><span class="n">group_id</span><span class="p">,</span> <span class="n">topology</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_topology</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">topology_object</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the topology into the group_id.</span>

<span class="sd">        Args:</span>
<span class="sd">            group_id (str): The name of the group. Normally &#39;topology&#39; is</span>
<span class="sd">                used for single traj HDF5 files. Can also be &#39;topology_&lt;traj_num&gt;&#39;,</span>
<span class="sd">                where &lt;traj_num&gt; is the traj_num of a trajectory.</span>
<span class="sd">            topology_object (md.Topology): The topology to put into the group.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_mode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;File already exists and has trajectory information. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Set `overwrite` to True to overwrite.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># we want to be able to handle the openmm Topology object</span>
        <span class="c1"># here too, so if it&#39;s not an mdtraj topology we&#39;ll just guess</span>
        <span class="c1"># that it&#39;s probably an openmm topology and convert</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">topology_object</span><span class="p">,</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">):</span>
            <span class="n">topology_object</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="o">.</span><span class="n">from_openmm</span><span class="p">(</span><span class="n">topology_object</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">topology_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;chains&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;bonds&quot;</span><span class="p">:</span> <span class="p">[]}</span>

            <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">topology_object</span><span class="o">.</span><span class="n">chains</span><span class="p">:</span>
                <span class="n">chain_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;residues&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="p">)}</span>
                <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
                    <span class="n">residue_dict</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                        <span class="s2">&quot;atoms&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;resSeq&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="p">),</span>
                        <span class="s2">&quot;segmentID&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">residue</span><span class="o">.</span><span class="n">segment_id</span><span class="p">),</span>
                    <span class="p">}</span>

                    <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">element_symbol_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">symbol</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="n">element_symbol_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

                        <span class="n">residue_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="p">{</span>
                                <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">),</span>
                                <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
                                <span class="s2">&quot;element&quot;</span><span class="p">:</span> <span class="n">element_symbol_string</span><span class="p">,</span>
                            <span class="p">}</span>
                        <span class="p">)</span>
                    <span class="n">chain_dict</span><span class="p">[</span><span class="s2">&quot;residues&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">residue_dict</span><span class="p">)</span>
                <span class="n">topology_dict</span><span class="p">[</span><span class="s2">&quot;chains&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain_dict</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">atom1</span><span class="p">,</span> <span class="n">atom2</span> <span class="ow">in</span> <span class="n">topology_object</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
                <span class="n">topology_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">atom1</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">atom2</span><span class="o">.</span><span class="n">index</span><span class="p">)])</span>

        <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;topology_object fails to implement the&quot;</span>
                <span class="s2">&quot;chains() -&gt; residue() -&gt; atoms() and bond() protocol. &quot;</span>
                <span class="s2">&quot;Specifically, we encountered the following </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">e</span>
            <span class="p">)</span>

        <span class="c1"># actually set the tables</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_node</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;topology&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">topology_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;ascii&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&gt;=</span> <span class="s2">&quot;3.0.0&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">create_array</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">createArray</span><span class="p">(</span>
                <span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">object</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">from</span> <span class="nn">mdtraj.utils</span> <span class="kn">import</span> <span class="n">in_units_of</span>

        <span class="k">def</span> <span class="nf">get_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">out_units</span><span class="p">,</span> <span class="n">can_be_none</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="n">where</span><span class="o">=</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">traj_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">)</span>
                <span class="n">in_units</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">attrs</span><span class="o">.</span><span class="n">units</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_units</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                    <span class="n">in_units</span> <span class="o">=</span> <span class="n">in_units</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">in_units_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">in_units</span><span class="p">,</span> <span class="n">out_units</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">data</span>
            <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">can_be_none</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">raise</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;coordinates&quot;</span><span class="p">:</span> <span class="n">get_field</span><span class="p">(</span>
                <span class="s2">&quot;coordinates&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
                <span class="n">out_units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">,</span>
                <span class="n">can_be_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">get_field</span><span class="p">(</span>
                <span class="s2">&quot;time&quot;</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">out_units</span><span class="o">=</span><span class="s2">&quot;picoseconds&quot;</span><span class="p">,</span> <span class="n">can_be_none</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">),</span>
            <span class="s2">&quot;cell_lengths&quot;</span><span class="p">:</span> <span class="n">get_field</span><span class="p">(</span>
                <span class="s2">&quot;cell_lengths&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
                <span class="n">out_units</span><span class="o">=</span><span class="s2">&quot;nanometers&quot;</span><span class="p">,</span>
                <span class="n">can_be_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="s2">&quot;cell_angles&quot;</span><span class="p">:</span> <span class="n">get_field</span><span class="p">(</span>
                <span class="s2">&quot;cell_angles&quot;</span><span class="p">,</span>
                <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)),</span>
                <span class="n">out_units</span><span class="o">=</span><span class="s2">&quot;degrees&quot;</span><span class="p">,</span>
                <span class="n">can_be_none</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">read_topology</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">:</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">import</span> <span class="nn">mdtraj.core.element</span> <span class="k">as</span> <span class="nn">elem</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">group_id</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="n">topology_dict</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
        <span class="k">except</span> <span class="bp">self</span><span class="o">.</span><span class="n">tables</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">topology</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">chain_dict</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="n">topology_dict</span><span class="p">[</span><span class="s2">&quot;chains&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">add_chain</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">residue_dict</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">chain_dict</span><span class="p">[</span><span class="s2">&quot;residues&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">resSeq</span> <span class="o">=</span> <span class="n">residue_dict</span><span class="p">[</span><span class="s2">&quot;resSeq&quot;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">resSeq</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;No resSeq information found in HDF file, defaulting to zero-based indices&quot;</span>
                    <span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">segment_id</span> <span class="o">=</span> <span class="n">residue_dict</span><span class="p">[</span><span class="s2">&quot;segmentID&quot;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">segment_id</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">residue</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">add_residue</span><span class="p">(</span>
                    <span class="n">residue_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">chain</span><span class="p">,</span> <span class="n">resSeq</span><span class="o">=</span><span class="n">resSeq</span><span class="p">,</span> <span class="n">segment_id</span><span class="o">=</span><span class="n">segment_id</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">atom_dict</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                    <span class="n">residue_dict</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">element</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">get_by_symbol</span><span class="p">(</span><span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;element&quot;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">element</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">virtual</span>
                    <span class="n">topology</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">atom_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">element</span><span class="p">,</span> <span class="n">residue</span><span class="p">)</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">topology</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="ow">in</span> <span class="n">topology_dict</span><span class="p">[</span><span class="s2">&quot;bonds&quot;</span><span class="p">]:</span>
            <span class="n">topology</span><span class="o">.</span><span class="n">add_bond</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">atoms</span><span class="p">[</span><span class="n">index2</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">topology</span>

    <span class="k">def</span> <span class="nf">read_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]:</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">from</span> <span class="nn">mdtraj.core.trajectory</span> <span class="kn">import</span> <span class="n">Trajectory</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">list_nodes</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;CVs&quot;</span><span class="p">]</span>
        <span class="n">traj_nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trajs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="n">traj_nums</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="n">traj_nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">))))</span>
        <span class="k">for</span> <span class="n">traj_num</span> <span class="ow">in</span> <span class="n">traj_nums</span><span class="p">:</span>
            <span class="n">topology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_topology</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">traj_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">traj_num</span><span class="p">)</span>
            <span class="n">trajs</span><span class="p">[</span><span class="n">traj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span>
                <span class="n">xyz</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">],</span>
                <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
                <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cell_lengths&quot;</span><span class="p">],</span>
                <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cell_angles&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">trajs</span>

    <span class="k">def</span> <span class="nf">read_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traj_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">:</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">from</span> <span class="nn">mdtraj.core.trajectory</span> <span class="kn">import</span> <span class="n">Trajectory</span>

        <span class="n">topology</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_topology</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;topology_</span><span class="si">{</span><span class="n">traj_num</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">traj_num</span><span class="p">)</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;coordinates&quot;</span><span class="p">],</span>
            <span class="n">topology</span><span class="o">=</span><span class="n">topology</span><span class="p">,</span>
            <span class="n">time</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">],</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cell_lengths&quot;</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;cell_angles&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">traj</span>


<span class="k">class</span> <span class="nc">TrajEnsembleTsel</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other</span> <span class="o">=</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">CanBeIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">TrajEnsemble</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">]:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">trajs_by_traj_num</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No trajectories with traj_num </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> in TrajEnsemble </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;with trajectories: </span><span class="si">{</span><span class="n">items</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">trajs_by_traj_num</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">item</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="o">.</span><span class="n">_pyemma_indexing_tsel</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently can&#39;t index trajs with slice.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The `tsel[]` method of `TrajEnsmeble` takes </span><span class="si">{</span><span class="n">CanBeIndex</span><span class="si">}</span><span class="s2"> types, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="si">}</span><span class="s2"> was provided.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;No trajs with traj_nums </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> in TrajEnsmble </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with trajectories: </span><span class="si">{</span><span class="n">items</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">other</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>


<div class="viewcode-block" id="TrajEnsemble">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble">[docs]</a>
<span class="k">class</span> <span class="nc">TrajEnsemble</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A fancy list of single trajectories. Topologies can be different across trajs.</span>

<span class="sd">    Check out http://statisticalbiophysicsblog.org/?p=92 for why trajectory ensembles are awesome.</span>

<span class="sd">    This class is a fancy list of :obj:`encodermap.trajinfo.info_single.SingleTraj``.</span>
<span class="sd">    Trajectories can have different topologies and will be grouped by</span>
<span class="sd">    the ``common_str`` argument. Each trajectory has its own unique ``traj_num``,</span>
<span class="sd">    which identifies it in the ensemble - even when the ensemble is sliced or</span>
<span class="sd">    subsampled.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;)</span>

<span class="sd">        Addition of two :obj:`encodermap.trajinfo.info_single.SingleTraj` also creates an ensemble.</span>

<span class="sd">        &gt;&gt;&gt; trajs = traj1 + traj2</span>
<span class="sd">        &gt;&gt;&gt; trajs  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.TrajEnsemble object. Current backend is no_load. Containing 2 trajectories. Common str is [&#39;1YUG&#39;, &#39;1YUF&#39;]. Not containing any CVs...&gt;</span>

<span class="sd">    Indexing a :obj:`TrajEnsemble` returns a :obj:`encodermap.trajinfo.info_single.SingleTraj`</span>
<span class="sd">    based on its 0-based index. Think of the :obj:`TrajEnsmeble` as a list of</span>
<span class="sd">    :obj:`encodermap.trajinfo.info_single.SingleTraj`. But trajectories can also</span>
<span class="sd">    have ``traj_nums``, which do not have to adhere to ``[0, 1, 2, ...]``. This</span>
<span class="sd">    is similar to how a :obj:`pandas.DataFrame` offers indexing via ``.loc[]``</span>
<span class="sd">    and ``.iloc[]`` (https://pandas.pydata.org/docs/user_guide/indexing.html#different-choices-for-indexing).</span>
<span class="sd">    For indexing trajs based on their ``traj_num``, you can use the ``.tsel[]``</span>
<span class="sd">    accessor of the :obj:`TrajEnsmeble`</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;)</span>

<span class="sd">        Addition of two `SingleTraj` also creates an ensemble.</span>

<span class="sd">        &gt;&gt;&gt; trajs = traj1 + traj2</span>
<span class="sd">        &gt;&gt;&gt; trajs.traj_nums</span>
<span class="sd">        [0, 1]</span>

<span class="sd">        Change the ``traj_num`` of ``traj2``</span>

<span class="sd">        &gt;&gt;&gt; trajs[1].traj_num = 4</span>
<span class="sd">        &gt;&gt;&gt; trajs.traj_nums</span>
<span class="sd">        [0, 4]</span>
<span class="sd">        &gt;&gt;&gt; trajs[1]  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.SingleTraj object. Currently not in memory. Basename is &#39;1YUF&#39;. Not containing any CVs. Common string is &#39;1YUF&#39;. Object at ...&gt;</span>
<span class="sd">        &gt;&gt;&gt; trajs.tsel[4]  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.SingleTraj object. Currently not in memory. Basename is &#39;1YUF&#39;. Not containing any CVs. Common string is &#39;1YUF&#39;. Object at ...&gt;</span>

<span class="sd">    :obj:`TrajEnsemble` supports fancy indexing. You can slice to your liking</span>
<span class="sd">    (``trajs[::5]`` returns a :obj:`TrajEnsemble` object that only consideres</span>
<span class="sd">    every fifth frame). Besides indexing by slices and integers, you can pass a</span>
<span class="sd">    2-dimensional :obj:`numpy.ndarray`. ``np.array([[0, 5], [1, 10], [5, 20]])``</span>
<span class="sd">    will return a :obj:`TrajEnsemble` object with frame 5 of trajectory 0, frame</span>
<span class="sd">    10 of trajectory 1 and frame 20 of trajectory 5.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;)</span>
<span class="sd">        &gt;&gt;&gt; trajs = traj1 + traj2</span>
<span class="sd">        &gt;&gt;&gt; sel = trajs[[[0, 0], [0, 1], [0, 2], [1, 10]]]</span>
<span class="sd">        &gt;&gt;&gt; sel  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.TrajEnsemble object. Current backend is no_load. Containing 4 frames and 2 trajectories. Common str is...&gt;</span>


<span class="sd">    The :obj:`TrajEnsemble` class also is an iterator to iterate over trajectores.</span>
<span class="sd">    Besides plain iteration, the :obj:`TrajEnsmeble` also offers alternate iterators.</span>
<span class="sd">    The ``itertrajs()`` iterator returns a two-tuple of ``traj_num`` and ``traj``.</span>
<span class="sd">    The ``iterframes()`` iterator returns a three-tuple of ``traj_num``,</span>
<span class="sd">    ``frame_num``, and ``traj``.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;)</span>
<span class="sd">        &gt;&gt;&gt; trajs = traj1 + traj2</span>
<span class="sd">        &gt;&gt;&gt; trajs[1].traj_num = 4</span>
<span class="sd">        &gt;&gt;&gt; for traj_num, traj in trajs.itertrajs():</span>
<span class="sd">        ...     print(traj_num, traj.n_frames)</span>
<span class="sd">        0 15</span>
<span class="sd">        4 16</span>
<span class="sd">        &gt;&gt;&gt; for traj_num, frame_num ,traj in trajs.subsample(10).iterframes():</span>
<span class="sd">        ...     print(traj_num, frame_num, traj.n_frames)</span>
<span class="sd">        0 0 1</span>
<span class="sd">        0 10 1</span>
<span class="sd">        4 0 1</span>
<span class="sd">        4 10 1</span>

<span class="sd">    The :obj:`TrajEnsemble` has multiple alternative constructors. The</span>
<span class="sd">    :meth:`with_overwrite_trajnums` constructor fixes inhomogeneous sequences of</span>
<span class="sd">    :obj:`encodermap.trajinfo.info_single.SingleTraj` and :obj:`TrajEnsemble`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;, traj_num=0)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;, traj_num=0)</span>
<span class="sd">        &gt;&gt;&gt; trajs = em.TrajEnsemble([traj1, traj2])  # doctest: +IGNORE_EXCEPTION_DETAIL, +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        Exception: The `traj_num` attributes of the provided 2 `SingleTraj`s is not unique, the `traj_num` 0 occurs 2 times. This can happen, if you use `SingleTraj`s, that are already part of a `TrajEnsemble`. To create copies of the `SingleTraj`s and overwrite their `traj_num`s, use the `with_overwrite_trajnums()` constructor.</span>
<span class="sd">        &gt;&gt;&gt; trajs = em.TrajEnsemble.with_overwrite_trajnums(traj1, traj2)</span>
<span class="sd">        &gt;&gt;&gt; trajs  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.TrajEnsemble...&gt;</span>

<span class="sd">    The :meth:`from_dataset` constructor can be used to load an ensemble from</span>
<span class="sd">    an ``.h5`` file</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; from tempfile import TemporaryDirectory</span>
<span class="sd">        &gt;&gt;&gt; traj1 = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; traj2 = em.SingleTraj.from_pdb_id(&quot;1YUF&quot;)</span>
<span class="sd">        &gt;&gt;&gt; trajs = em.TrajEnsemble([traj1, traj2])</span>
<span class="sd">        &gt;&gt;&gt; with TemporaryDirectory() as td:</span>
<span class="sd">        ...     trajs.save(td + &quot;/trajs.h5&quot;)</span>
<span class="sd">        ...     new = em.TrajEnsemble.from_dataset(td + &quot;/trajs.h5&quot;)</span>
<span class="sd">        ...     print(new)  # doctest: +ELLIPSIS</span>
<span class="sd">        encodermap.TrajEnsemble object. Current backend is no_load. Containing 2 trajectories. Common str is...Not containing any CVs.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        CVs (dict[str, np.ndarray]): The collective variables of the ``SingleTraj``</span>
<span class="sd">            classes. Only CVs with matching names in all ``SingleTraj`` classes</span>
<span class="sd">            are returned. The data is stacked along a hypothetical time axis</span>
<span class="sd">            along the trajs.</span>
<span class="sd">        _CVs (xarray.Dataset): The same data as in CVs but with labels.</span>
<span class="sd">            Additionally, the xarray is not stacked along the time axis.</span>
<span class="sd">            It contains an extra dimension for trajectories.</span>
<span class="sd">        n_trajs (int): Number of individual trajectories in this class.</span>
<span class="sd">        n_frames (int): Number of frames, sum over all trajectories.</span>
<span class="sd">        locations (list[str]): A list with the locations of the trajectories.</span>
<span class="sd">        top (list[mdtraj.Topology]): A list with the reference pdb for each trajecotry.</span>
<span class="sd">        basenames (list[str]): A list with the names of the trajecotries.</span>
<span class="sd">            The leading path and the file extension is omitted.</span>
<span class="sd">        name_arr (np.ndarray): An array with ``len(name_arr) == n_frames``.</span>
<span class="sd">            This array keeps track of each frame in this object by identifying each</span>
<span class="sd">            frame with a filename. This can be useful, when frames are mixed inside</span>
<span class="sd">            a :obj:`TrajEnsemble` class.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trajs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="n">Path</span><span class="p">],</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">],</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">],</span>
        <span class="p">],</span>
        <span class="n">tops</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;no_load&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;no_load&quot;</span><span class="p">,</span>
        <span class="n">common_str</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">basename_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">traj_nums</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">custom_top</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CustomAAsDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the :obj:`TrajEnsmeble` class with two lists of files.</span>

<span class="sd">        Args:</span>
<span class="sd">            trajs (Union[Sequence[str], Sequence[md.Trajectory],</span>
<span class="sd">                Sequence[SingleTraj], Sequence[Path]]): List of strings with</span>
<span class="sd">                paths to trajectories. Can also be a list of md.Trajectory or</span>
<span class="sd">                em.SingleTraj.</span>
<span class="sd">            tops (Optional[list[str]]): List of strings with paths to reference pdbs.</span>
<span class="sd">            backend (str, optional): Choose the backend to load trajectories:</span>
<span class="sd">                    - &#39;mdtraj&#39; uses mdtraj, which loads all trajectories into RAM.</span>
<span class="sd">                    - &#39;no_load&#39; creates an empty trajectory object.</span>
<span class="sd">                Defaults to &#39;no_load&#39;, which makes the instantiation of large</span>
<span class="sd">                ensembles fast and RAM efficient.</span>
<span class="sd">            common_str (list[str], optional): If you want to include trajectories with</span>
<span class="sd">                different topology. The common string is used to pair traj-files</span>
<span class="sd">                (``.xtc, .dcd, .lammpstrj, ...``) with their topology</span>
<span class="sd">                (``.pdb, .gro, ...``). The common-string should be a substring</span>
<span class="sd">                of matching traj and topology files.</span>
<span class="sd">            basename_fn (Union[None, Callable[[str], str], optional): A function</span>
<span class="sd">                to apply to the trajectory file path string to return the basename</span>
<span class="sd">                of the trajectory. If None is provided, the filename without</span>
<span class="sd">                extension will be used. When all files are named the same and</span>
<span class="sd">                the folder they&#39;re in defines the name of the trajectory, you</span>
<span class="sd">                can supply ``lambda x: split(&#39;/&#39;)[-2]`` as this argument.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            custom_top: Optional[CustomAAsDict]: An instance of the</span>
<span class="sd">                :obj:`encodermap.trajinfo.trajinfo_utils.CustomTopology` or a</span>
<span class="sd">                dictionary that can be made into such.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># defaults</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>

        <span class="c1"># check if h5file might be a complete dataset</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.h5&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">TrajEnsemble</span><span class="o">.</span><span class="n">from_dataset</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">basename_fn</span><span class="o">=</span><span class="n">basename_fn</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tops</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Your list of topology files is empty: </span><span class="si">{</span><span class="n">tops</span><span class="si">=}</span><span class="s2">. Pass None, if &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;your trajectories are all .pdb/.gro files.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>

        <span class="c1"># custom topology to load dihedral angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_custom_top</span> <span class="o">=</span> <span class="n">custom_top</span>

        <span class="c1"># set the trajnums</span>
        <span class="k">if</span> <span class="n">traj_nums</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Standard Library Imports</span>
            <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Uneven length of `traj_nums` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and `trajs` (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span><span class="si">}</span><span class="s2">) provided.&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
                <span class="n">trajs_</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="n">trajs</span><span class="p">):</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="n">t</span><span class="o">.</span><span class="n">traj_num</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="n">trajs_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">trajs</span> <span class="o">=</span> <span class="n">trajs_</span>

        <span class="c1"># make sure, that traj_nums are not duplicated</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">trajs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">traj_num</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">traj_num</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The `SingleTraj`s you provided have bad `traj_num`s &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;one has `None`, the others have int: </span><span class="si">{</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">traj_num</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">trajs</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([(</span><span class="n">i</span><span class="o">.</span><span class="n">traj_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
                <span class="n">uniques</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">traj_num</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]),</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">counts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">ex_num</span> <span class="o">=</span> <span class="n">uniques</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The `traj_num` attributes of the provided </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span><span class="si">}</span><span class="s2"> `SingleTraj`s are &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;not unique, the `traj_num` </span><span class="si">{</span><span class="n">ex_num</span><span class="si">}</span><span class="s2"> occurs </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span><span class="si">}</span><span class="s2"> times. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;This can happen, if you use `SingleTraj`s, that are already part of &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;a `TrajEnsemble`. To create copies of the `SingleTraj`s and over&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;write their `traj_num`s, use the `with_overwrite_trajnums()` constructor.&quot;</span>
                    <span class="p">)</span>
                <span class="n">trajs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">traj_num</span><span class="p">))</span>

        <span class="c1"># basename function</span>
        <span class="k">if</span> <span class="n">basename_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">basename_fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span> <span class="o">=</span> <span class="n">basename_fn</span>

        <span class="c1"># common string</span>
        <span class="k">if</span> <span class="n">common_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">common_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">common_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">common_str</span> <span class="o">=</span> <span class="p">[</span><span class="n">common_str</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">common_str</span> <span class="o">=</span> <span class="n">common_str</span>

        <span class="c1"># loading with setters</span>
        <span class="k">if</span> <span class="n">tops</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">=</span> <span class="n">tops</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">top</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">_TOPOLOGY_EXTS</span> <span class="k">for</span> <span class="n">top</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">=</span> <span class="n">trajs</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">tops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">tops</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj_files</span> <span class="o">=</span> <span class="n">trajs</span>

        <span class="c1"># set the traj nums afterwards</span>
        <span class="k">if</span> <span class="n">traj_nums</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">):</span>
                <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="o">=</span> <span class="n">i</span>

<div class="viewcode-block" id="TrajEnsemble.with_overwrite_trajnums">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.with_overwrite_trajnums">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">with_overwrite_trajnums</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="o">*</span><span class="n">trajs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">TrajEnsemble</span><span class="p">,</span> <span class="s2">&quot;SingleTraj&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a :obj:`TrajEnsemble` by copying the provided</span>
<span class="sd">        :obj:`encodermap.trajinfo.info_single.SingleTraj` instances and</span>
<span class="sd">        changing their ``traj_num`` attribute to adhere to ``[0, 1, 2, ...]``.</span>

<span class="sd">        Args:</span>
<span class="sd">            trajs (Sequence[SingleTraj]): The sequence of trajs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TrajEnsemble: A :obj:`TrajEnsemble` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Standard Library Imports</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>

        <span class="n">new_trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">t</span><span class="o">.</span><span class="n">traj_num</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">new_trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">traj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="n">new_trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Classmethod `with_overwrite_trajnums` can only accept `SingleTraj` &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and `TrajEnsemble`, but </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2"> is not an instance of either.&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">new_trajs</span><span class="p">)</span></div>


<div class="viewcode-block" id="TrajEnsemble.from_textfile">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.from_textfile">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_textfile</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fname</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">basename_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a :obj:`TrajEnsemble` object from a textfile.</span>

<span class="sd">        The textfile needs to be space-separated with two or three columns:</span>
<span class="sd">            - Column 1:</span>
<span class="sd">                The trajectory file.</span>
<span class="sd">            - Column 2:</span>
<span class="sd">                The corresponding topology file (If you are using ``.h5`` trajs,</span>
<span class="sd">                column 1 and 2 will be identical, but column 2 needs to be there</span>
<span class="sd">                nonetheless).</span>
<span class="sd">            - Column 3:</span>
<span class="sd">                The common string of the trajectory. This column can be left</span>
<span class="sd">                out, which will result in an :obj:`TrajEnsemble` without common</span>
<span class="sd">                strings.</span>

<span class="sd">        Args:</span>
<span class="sd">            fname (Union[str, Path]): File to be read.</span>
<span class="sd">            basename_fn (Union[None, Callable[[str], str]], optional): A function</span>
<span class="sd">                to apply to the ``traj_file`` string to return the basename of</span>
<span class="sd">                the trajectory. If None is provided, the filename without</span>
<span class="sd">                extension will be used.  When all files are named the same and</span>
<span class="sd">                the folder they&#39;re in defines the name of the trajectory, you</span>
<span class="sd">                can supply ``lambda x: split(&#39;/&#39;)[-2]`` as this argument.</span>
<span class="sd">                Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TrajEnsemble: A :obj:`TrajEnsemble` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">..trajinfo</span> <span class="kn">import</span> <span class="n">info_single</span>

        <span class="n">traj_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">top_files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">common_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">traj_nums</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">traj_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">top_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">traj_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">traj_nums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">common_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="n">common_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">traj_file</span><span class="p">,</span> <span class="n">top_file</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">traj_num</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">traj_files</span><span class="p">,</span> <span class="n">top_files</span><span class="p">,</span> <span class="n">common_str</span><span class="p">,</span> <span class="n">traj_nums</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info_single</span><span class="o">.</span><span class="n">SingleTraj</span><span class="p">(</span><span class="n">traj_file</span><span class="p">,</span> <span class="n">top_file</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">traj_num</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">trajs</span><span class="p">,</span> <span class="n">common_str</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">common_str</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">basename_fn</span><span class="o">=</span><span class="n">basename_fn</span>
        <span class="p">)</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataset</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fname</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">basename_fn</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>

        <span class="n">traj_nums</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">h5file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">h5file</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;CVs&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">traj_nums</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\d+&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
        <span class="n">traj_nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">))))</span>

        <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj_num</span> <span class="ow">in</span> <span class="n">traj_nums</span><span class="p">:</span>
            <span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">SingleTraj</span><span class="p">(</span>
                    <span class="n">traj</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
                    <span class="n">top</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
                    <span class="n">traj_num</span><span class="o">=</span><span class="n">traj_num</span><span class="p">,</span>
                    <span class="n">basename_fn</span><span class="o">=</span><span class="n">basename_fn</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">common_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">common_str</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]))</span>
        <span class="n">newclass</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">trajs</span><span class="o">=</span><span class="n">trajs</span><span class="p">,</span> <span class="n">common_str</span><span class="o">=</span><span class="n">common_str</span><span class="p">,</span> <span class="n">basename_fn</span><span class="o">=</span><span class="n">basename_fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newclass</span>

<div class="viewcode-block" id="TrajEnsemble.load_custom_topology">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.load_custom_topology">[docs]</a>
    <span class="k">def</span> <span class="nf">load_custom_topology</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">custom_top</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">CustomTopology</span><span class="p">,</span> <span class="n">CustomAAsDict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads a custom_topology from a `CustomTopology` class or a dict.</span>

<span class="sd">        See Also:</span>
<span class="sd">            `CustomTopology`</span>

<span class="sd">        Args:</span>
<span class="sd">            custom_top: Optional[Union[CustomTopology, CustomAAsDict]]: An instance of the</span>
<span class="sd">                `CustomTopology` class or a dictionary that can be made into such.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
            <span class="n">traj</span><span class="o">.</span><span class="n">load_custom_topology</span><span class="p">(</span><span class="n">custom_top</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tsel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TrajEnsembleTsel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TrajEnsemble.del_featurizer">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.del_featurizer">[docs]</a>
    <span class="k">def</span> <span class="nf">del_featurizer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes the current instance of ``self.featurizer``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_featurizer&quot;</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_featurizer</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">featurizer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">..loading.featurizer</span> <span class="kn">import</span> <span class="n">Featurizer</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_featurizer&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_featurizer</span> <span class="o">=</span> <span class="n">Featurizer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_featurizer</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traj_files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: A list of the traj_files of the individual SingleTraj classes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traj_files</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top_files</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: Returns minimal set of topology files.</span>

<span class="sd">        If yoy want a list of top files with the same</span>
<span class="sd">        length as self.trajs use self._top_files and</span>
<span class="sd">        self._traj_files.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span><span class="p">))</span>

    <span class="nd">@traj_files</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">traj_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trajs</span><span class="p">):</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">..trajinfo</span> <span class="kn">import</span> <span class="n">info_single</span>

        <span class="n">traj_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">))</span>
        <span class="c1"># fill this lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
            <span class="n">trajs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;mdtraj&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">info_single</span><span class="o">.</span><span class="n">SingleTraj</span><span class="p">(</span>
                    <span class="n">traj</span><span class="p">,</span>
                    <span class="n">traj_num</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span><span class="p">,</span>
                    <span class="n">custom_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_custom_top</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="n">trajs</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;SingleTraj&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="n">trajs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">top_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_traj_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>
            <span class="c1"># check backends and common str</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;no_load&quot;</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span>
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;mdtraj&quot;</span>
            <span class="p">):</span>
                <span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">load_traj</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="n">trajs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">if</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="p">:</span>
                        <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">traj_num</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_files</span><span class="p">:</span>
            <span class="c1"># find common_str matches in top_files and traj_files</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_traj_files</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_common_str</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">get_full_common_str_and_ref</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">cs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">traj_nums</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traj_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_common_str</span>
            <span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">info_single</span><span class="o">.</span><span class="n">SingleTraj</span><span class="p">(</span>
                    <span class="n">traj</span><span class="o">=</span><span class="n">t</span><span class="p">,</span>
                    <span class="n">top</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
                    <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
                    <span class="n">common_str</span><span class="o">=</span><span class="n">cs</span><span class="p">,</span>
                    <span class="n">traj_num</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                    <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span><span class="p">,</span>
                    <span class="n">custom_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_custom_top</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">top_files</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj_file</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="n">trajs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">info_single</span><span class="o">.</span><span class="n">SingleTraj</span><span class="p">(</span>
                        <span class="n">traj</span><span class="o">=</span><span class="n">traj_file</span><span class="p">,</span>
                        <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span><span class="p">,</span>
                        <span class="n">traj_num</span><span class="o">=</span><span class="n">i</span><span class="p">,</span>
                        <span class="n">custom_top</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_custom_top</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;The objects in the list are not of the correct type or inconsistent. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;You provided </span><span class="si">{</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">trajs</span><span class="p">]</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="s2">&quot;Please provide a list of `str`, list of `mdtraj.Trajectory` or list of `SingleTraj`.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: Returns a minimal set of mdtraj.Topologies.</span>

<span class="sd">        If all trajectories share the same topology a list</span>
<span class="sd">        with len 1 will be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IOError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;no such file&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;I have no idea how this IOError can occur. </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="si">=}</span><span class="s2">.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajs_by_top</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;dict[md.Topology, TrajEnsemble]: Returns the trajs in `self` ordered by top.</span>

<span class="sd">        If all trajectories share the same topology, a dict with</span>
<span class="sd">        one key will be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">TrajEnsemble</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">v</span><span class="o">.</span><span class="n">common_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">common_str</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">v</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajs_by_common_str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">TrajEnsemble</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;dict[str, TrajEnsemble]: Returns the trajs in `self` ordered by top.</span>

<span class="sd">        If all trajectories share the same common_str, a dict with</span>
<span class="sd">        one key will be returned. As the common_str can be None, None can also</span>
<span class="sd">        occur as a key in this dict.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">common_str</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">TrajEnsemble</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="TrajEnsemble.sidechain_info">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.sidechain_info">[docs]</a>
    <span class="k">def</span> <span class="nf">sidechain_info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices used for the AngleDihedralCartesianEncoderMap class to</span>
<span class="sd">        allow training with multiple different sidechains.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict[str, Sequence[int]]: The indices. The key &#39;-1&#39; is used for</span>
<span class="sd">            the hypothetical convex hull of all feature spaces (the output of</span>
<span class="sd">            the tensorflow model). The other keys match the common_str of the</span>
<span class="sd">            trajs.</span>

<span class="sd">        Raises:</span>
<span class="sd">            Exception: When the common_strings and topologies are not</span>
<span class="sd">                aligned. An exception is raised. Aligned means that all trajs</span>
<span class="sd">                with the same common_str should possess the same topology.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure no clustal w has not been loaded</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;This is currently not supported for TrajEsnembles with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;clustal_w alignments.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_residues</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">n_residues</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

        <span class="c1"># make sure CVs are loaded and contain the appropriate values</span>
        <span class="n">should_be</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;central_cartesians&quot;</span><span class="p">,</span>
            <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
            <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
            <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
            <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
            <span class="s2">&quot;side_cartesians&quot;</span><span class="p">,</span>
            <span class="s2">&quot;side_distances&quot;</span><span class="p">,</span>
            <span class="s2">&quot;side_angles&quot;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">should_be</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The TrajEnsemble misses these CVs to calculate the sidechain_info: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="si">}</span><span class="s2">. Please load them with `trajs.load_CVs(</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="si">}</span><span class="s2">)`.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># make sure we are using an ensemble with generic indices</span>
        <span class="n">forbidden_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residues</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">offending</span> <span class="o">:=</span> <span class="p">[</span>
                        <span class="n">label</span>
                        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">central_distances</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span>
                            <span class="s2">&quot;CENTRAL_DISTANCES&quot;</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">values</span>
                        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">f</span> <span class="ow">in</span> <span class="n">label</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">forbidden_names</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The CVs in this TrajEnsemble were not loaded with the `ensemble=True` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;keyword in `trajs.load_CVs()`. Finding the sidechain_info in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;such a set of CVs is not possible. The offending labels </span><span class="si">{</span><span class="n">offending</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;contain residue names, which should not occur if CVs were loaded &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with `ensemble=True`.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># the key -1 is the feature hull, telling tensorflow</span>
        <span class="c1"># how to create the branched chain of backbone and sidechains</span>
        <span class="c1"># i.e. how many sidechains there are per residue max</span>
        <span class="c1"># the other keys correspond to which sidechain atoms are non nan and</span>
        <span class="c1"># can be used when calculating the distance matrices per different atom</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="p">{}}</span>

        <span class="c1"># the feature hull</span>
        <span class="n">max_sidechains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">side_dihedrals</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;SIDE_DIHEDRALS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">for</span> <span class="n">residx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_residues</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">max_sidechains</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">residx</span><span class="p">))]</span>
            <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">residx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>

        <span class="c1"># for every traj</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;This traj has the same `traj_num` as another traj.&quot;</span>
            <span class="n">out</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">residx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_residues</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">l</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">side_dihedrals</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;SIDE_DIHEDRALS&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">residx</span><span class="p">))</span>
                <span class="p">]</span>
                <span class="n">first_frame</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;frame_num&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">length</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">side_dihedrals</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span>
                        <span class="n">frame_num</span><span class="o">=</span><span class="n">first_frame</span><span class="p">,</span> <span class="n">SIDE_DIHEDRALS</span><span class="o">=</span><span class="n">labels</span>
                    <span class="p">)</span>
                    <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s2">&quot;SIDE_DIHEDRALS&quot;</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;SIDE_DIHEDRALS&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">out</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="p">][</span><span class="n">residx</span><span class="p">]</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">trajs_by_traj_num</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">]:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: Duplication of self.index_arr&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_arr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: List of number of residues of the SingleTraj classes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">n_residues</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basenames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: List of the basenames in the Info single classes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">basename</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traj_nums</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: Number of info single classes in self.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: Number of trajectories in this ensemble.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">)</span>

<div class="viewcode-block" id="TrajEnsemble.to_alignment_query">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.to_alignment_query">[docs]</a>
    <span class="k">def</span> <span class="nf">to_alignment_query</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A string, that cen be put into sequence alignment software.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cs</span><span class="p">,</span> <span class="n">trajs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_common_str</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can&#39;t provide a query for a `TrajEnsemble`, where a common string &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;has multiple topologies. In this case, the common string &#39;</span><span class="si">{</span><span class="n">cs</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;has these topologies: </span><span class="si">{</span><span class="n">trajs</span><span class="o">.</span><span class="n">top</span><span class="si">}</span><span class="s2">. When you are unhappy with how &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;EncoderMap automatically applies common strings to trajectory &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;filenames, keep in mind that you can always generate a `TrajEnsemble` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;from multiple `TrajEnsembles`. You can do: </span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;trajs1 = em.load(</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  traj_files1,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  top_files1,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  common_str=[&#39;trajs1&#39;],</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;trajs2 = em.load(</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  traj_files2,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  top_files2,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  common_str=[&#39;trajs2&#39;],</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;)</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;trajs = trajs1 + trajs2</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;to force a `TrajEnsemble` to adhere to your common strings.&quot;</span>
            <span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cs</span><span class="p">,</span> <span class="n">trajs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_common_str</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">trajs</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">to_fasta</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="n">add</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&gt;</span><span class="si">{</span><span class="n">cs</span><span class="si">}</span><span class="s2">n</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TrajEnsemble.parse_clustal_w_alignment">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.parse_clustal_w_alignment">[docs]</a>
    <span class="k">def</span> <span class="nf">parse_clustal_w_alignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aln</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse an alignment in ClustalW format and add the info to the trajectories.</span>

<span class="sd">        Args:</span>
<span class="sd">            aln (str): The alignment in ClustalW format.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clustal_w</span> <span class="o">=</span> <span class="n">aln</span>
        <span class="c1"># remove empty lines</span>
        <span class="n">aln</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*$&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">aln</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()))</span>
        <span class="p">)</span>

        <span class="c1"># every three lines represent one trajectory</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">aln</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">n_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">n_lines</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">n_lines</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The CLUSTAL W aln string, that you provided has the wrong number of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;lines. I&#39;ve expected to receive a multiple of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> (&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;which is the number of trajs (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="si">}</span><span class="s2">) plus one for the score-&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;characters &#39; &#39;, &#39;.&#39;, &#39;:&#39;, &#39;*&#39;), but the number of provided lines was &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_lines</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;|&quot;</span> <span class="ow">in</span> <span class="n">aln</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">sub_trajs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_top</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">cs</span><span class="p">,</span> <span class="n">trajs</span> <span class="ow">in</span> <span class="n">sub_trajs</span><span class="o">.</span><span class="n">trajs_by_common_str</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">chain</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">chains</span><span class="p">):</span>
                            <span class="n">search</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cs</span><span class="si">}</span><span class="s2">|TrajNum_</span><span class="si">{</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="si">}</span><span class="s2">Topology_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">Chain_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">search</span><span class="p">):</span>
                                    <span class="n">data</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">assert</span> <span class="p">(</span>
                                <span class="n">test</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                            <span class="p">)</span> <span class="o">==</span> <span class="n">traj</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;The CLUSTAL W sequence </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s2"> one-letter &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;residues has not the same number of residues as trajectory &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">traj</span><span class="si">}</span><span class="s2">, which has </span><span class="si">{</span><span class="n">traj</span><span class="o">.</span><span class="n">n_residues</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                            <span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cs</span><span class="p">,</span> <span class="n">trajs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_common_str</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">search</span> <span class="o">=</span> <span class="n">cs</span>
                <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">search</span><span class="p">):</span>
                        <span class="n">data</span> <span class="o">+=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">assert</span> <span class="p">(</span><span class="n">test</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)))</span> <span class="o">==</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The CLUSTAL W sequence </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">test</span><span class="si">}</span><span class="s2"> one-letter &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;residues has not the same number of residues as trajectory &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, which has </span><span class="si">{</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_residues</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="n">trajs</span><span class="p">:</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span> <span class="o">=</span> <span class="n">data</span></div>


<div class="viewcode-block" id="TrajEnsemble.del_CVs">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.del_CVs">[docs]</a>
    <span class="k">def</span> <span class="nf">del_CVs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CVs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Deletes all CVs in all trajs. Does not affect the files.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">CVs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
                <span class="n">traj</span><span class="o">.</span><span class="n">del_CVs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">CVs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">CVs</span> <span class="o">=</span> <span class="p">[</span><span class="n">CVs</span><span class="p">]</span>
            <span class="n">remove</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">CVs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">CV</span> <span class="ow">in</span> <span class="n">CVs</span><span class="p">:</span>
                <span class="n">remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">CV</span><span class="si">}</span><span class="s2">_feature_indices&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
                <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">remove</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_CVs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;xarray.Dataset: Returns x-array Dataset of matching CVs. stacked</span>
<span class="sd">        along the trajectory-axis.&quot;&quot;&quot;</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.trajinfo_utils</span> <span class="kn">import</span> <span class="n">trajs_combine_attrs</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">combine_nested</span><span class="p">(</span>
            <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">],</span>
            <span class="n">concat_dim</span><span class="o">=</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span>
            <span class="n">compat</span><span class="o">=</span><span class="s2">&quot;broadcast_equals&quot;</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
            <span class="n">coords</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span>
            <span class="n">combine_attrs</span><span class="o">=</span><span class="n">trajs_combine_attrs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if ensemble we don&#39;t need to reorder labels. That was already done</span>
        <span class="c1"># by the Featurizer. We know if we have an ensemble if the trajs</span>
        <span class="c1"># have features with nans (except the &quot;feature_indices&quot; dataarrays</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;feature_indices&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">ds</span>

        <span class="c1"># sort the combined arrays</span>
        <span class="n">new_label_order</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">non_indices_data_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="s2">&quot;feature_indices&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">k</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">non_indices_data_vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind_k</span> <span class="o">:=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_feature_indices&quot;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ds</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">argsort</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">da</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">ind_k</span><span class="p">]</span>

            <span class="c1"># ResidueMinDistanceFeature</span>
            <span class="k">if</span> <span class="s2">&quot;RES_NO&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">feature_axis_name</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;feature_axis&quot;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;There is no feature_axis attribute in </span><span class="si">{</span><span class="n">da</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">feature_axis_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="s2">&quot;ATOM_NO&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="s2">&quot;frame_num&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
            <span class="k">elif</span> <span class="s2">&quot;ATOM_NO&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="s2">&quot;frame_num&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                    <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="n">iterable</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">feature_axis_name</span><span class="p">,</span> <span class="s2">&quot;frame&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">elif</span> <span class="s2">&quot;ATOM_NO&quot;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="s2">&quot;frame_num&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span><span class="p">:</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="n">da</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">feature_axis_name</span><span class="p">,</span> <span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;ATOM_NO&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">da</span><span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                    <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">iterable</span> <span class="o">=</span> <span class="n">iterable</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">feature_axis_name</span><span class="p">,</span> <span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="s2">&quot;ATOM_NO&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">labels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="s2">&quot;ATOM_NO&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span> <span class="ow">and</span> <span class="s2">&quot;RES_NO&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">coords</span>
                <span class="p">):</span>  <span class="c1"># selection feature</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">row</span><span class="p">)]</span>
                    <span class="n">uniques</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">uniques</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span>
                    <span class="n">argsort</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">row</span><span class="p">)]</span>
                    <span class="n">uniques</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="s2">&quot;side&quot;</span> <span class="ow">in</span> <span class="n">feature_axis_name</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_label_order</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">uniques</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)]</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">if</span> <span class="s2">&quot;attempt to get argmax of an empty&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                                <span class="sa">f</span><span class="s2">&quot;Can&#39;t order the data_var </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">, as the </span><span class="si">{</span><span class="n">row</span><span class="si">=}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;has become empty (</span><span class="si">{</span><span class="n">row</span><span class="si">=}</span><span class="s2">).&quot;</span>
                            <span class="p">)</span>
                        <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">argsort</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">argsort</span><span class="p">)]</span>
            <span class="n">new_label_order</span><span class="p">[</span><span class="n">feature_axis_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">labels</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">new_label_order</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ds</span>

    <span class="k">def</span> <span class="nf">_calc_CV</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">CVs</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>
            <span class="ow">or</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">CVs</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CVs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">matching_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">dropping_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">matching_keys</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">dropping_keys</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The CVs </span><span class="si">{</span><span class="n">dropping_keys</span><span class="si">}</span><span class="s2"> will not be in the `CVs` dictionary, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;as they are only present in some, but not all of the </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;trajectories. You can access them with &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`TrajEnsemble([t for t in trajs if any([cv in </span><span class="si">{</span><span class="n">dropping_keys</span><span class="si">}</span><span class="s2"> for cv in t.CVs.keys()])])`&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">matching_keys</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">matching_keys</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">_CVs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="c1"># check if all shapes are the same</span>
                    <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;I am not returning the CVs for the feature &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;because some trajectories have different &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;shapes for these CVs. The shapes are </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span><span class="si">}</span><span class="s2">. &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;If you want to access these CVs, use the `_CVs` &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;xarray dataset of `TrajEnsemble` instead.&quot;</span>
                        <span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span>
                        <span class="p">]</span>
                    <span class="p">):</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                            <span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="k">if</span> <span class="s2">&quot;zero-dimensional&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">])</span>
                            <span class="k">if</span> <span class="s2">&quot;all the input arrays must have the same&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                                <span class="n">err_shapes</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                    <span class="p">[</span>
                                        <span class="sa">f</span><span class="s2">&quot;Traj: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">traj_num</span><span class="si">:</span><span class="s2">&lt;3</span><span class="si">}</span><span class="s2"> CV &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; shape: </span><span class="si">{</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                                    <span class="p">]</span>
                                <span class="p">)</span>
                                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;Can&#39;t concatenate the data of the CV &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;The shapes of this CV for the individual &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;trajectories are:</span><span class="se">\n</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err_shapes</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">e</span>
                    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">CVs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">CVs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">CVs</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CVs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;dict: Returns dict of CVs in SingleTraj classes. Only CVs with the same names</span>
<span class="sd">        in all SingleTraj classes are loaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_CV</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">locations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: Duplication of self.traj_files but using the trajs own traj_file attribute.</span>
<span class="sd">        Ensures that traj files are always returned independent of the current load state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">index_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: Returns np.ndarray with ndim = 2. Clearly assigning every</span>
<span class="sd">        loaded frame an identifier of traj_num (self.index_arr[:,0]) and</span>
<span class="sd">        frame_num (self.index_arr[:,1]). Can be used to create an unspecified</span>
<span class="sd">        subset of frames and can be useful when used with clustering.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># can also be made to use the SingleTraj.index_arr attribute,</span>
        <span class="c1"># but doing it this way the traj is loaded.</span>
        <span class="c1"># which might slow down thing significantly</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name_arr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: Trajectory names with the same length as self.n_frames.&quot;&quot;&quot;</span>
        <span class="n">name_arr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">name_arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">basename</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)]</span>
                <span class="n">name_arr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">name_arr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: Sum of the loaded frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list: Frames of individual trajectories.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">CVs_in_file</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool: Is true, if CVs can be loaded from file. Can be used to build a</span>
<span class="sd">        data generator from.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">CVs_in_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_traj_joined</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">progbar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">:</span>
        <span class="c1"># use traj[0] of the trajs list as the traj from which the topology will be used</span>
        <span class="n">parent_traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">traj</span>

        <span class="c1"># join the correct number of trajs</span>
        <span class="c1"># by use of the `divmod` method, the frames parent_traj traj will be</span>
        <span class="c1"># appended for a certain amount, until the remainder of the division</span>
        <span class="c1"># is met by that time, the parent traj will be sliced to fill the correct number of frames</span>
        <span class="n">no_of_iters</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">parent_traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>

        <span class="n">total</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">+</span> <span class="n">no_of_iters</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_is_notebook</span><span class="p">():</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">notebook_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">,</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering...&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">normal_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">,</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Clustering...&quot;</span><span class="p">,</span>
                    <span class="n">function</span><span class="o">=</span><span class="s2">&quot;_traj_joined&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progbar</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">progbar</span><span class="o">.</span><span class="n">total</span> <span class="o">+</span> <span class="n">total</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="s2">&quot;_traj_joined&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_of_iters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dummy_traj</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">parent_traj</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">no_of_iters</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rest</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dummy_traj</span> <span class="o">=</span> <span class="n">dummy_traj</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">parent_traj</span><span class="p">)[:</span><span class="n">rest</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy_traj</span> <span class="o">=</span> <span class="n">dummy_traj</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">parent_traj</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;_traj_joined&quot;</span><span class="p">)</span>

        <span class="c1"># some checks</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">==</span> <span class="n">dummy_traj</span><span class="o">.</span><span class="n">n_frames</span>
        <span class="c1"># assert self.n_frames == len(self.trajs), f&quot;{self.n_frames=}, {len(self.trajs)=}&quot;</span>

        <span class="c1"># change the xyz coordinates of dummy_traj according to the frames in joined trajs</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">__</span><span class="p">,</span> <span class="n">traj</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterframes</span><span class="p">()):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dummy_traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;broadcast&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;This`TrajEnsemble` has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique topologies. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;I will use the topology with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2"> for joining &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;and discard atoms in the other trajectories.&quot;</span>
                <span class="p">)</span>
                <span class="n">dummy_traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span> <span class="n">dummy_traj</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;_traj_joined&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dummy_traj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traj_joined</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;mdtraj.Trajectory: Returns a mdtraj Trajectory with every frame of</span>
<span class="sd">        this class appended along the time axis.</span>

<span class="sd">        Can also work if different topologies (with the same number of atoms) are loaded.</span>
<span class="sd">        In that case, the first frame in self will be used as topology parent and the remaining frames&#39;</span>
<span class="sd">        xyz coordinates are used to position the parents&#39; atoms accordingly.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; trajs = em.load_project(&quot;pASP_pGLU&quot;)</span>
<span class="sd">            &gt;&gt;&gt; subsample = trajs[0][:20] + trajs[1][:20]</span>
<span class="sd">            &gt;&gt;&gt; subsample.split_into_frames().traj_joined  # doctest: +ELLIPSIS</span>
<span class="sd">            &lt;mdtraj.Trajectory with 40 frames, 69 atoms, 6 residues, and unitcells at ...&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traj_joined</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: xyz coordinates of all atoms stacked along the traj-time axis.</span>

<span class="sd">        Only works if all trajs share the same topology.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">xyz</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">xyz</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Non consistent topologies don&#39;t allow to return a &quot;</span>
                    <span class="s2">&quot;common xyz. This could be achived by implementing a &quot;</span>
                    <span class="s2">&quot;high-dimensional masked numpy array with nans at &quot;</span>
                    <span class="s2">&quot;non-defined positions.&quot;</span>
                <span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">e2</span> <span class="kn">from</span> <span class="nn">e</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="TrajEnsemble.split_into_frames">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.split_into_frames">[docs]</a>
    <span class="k">def</span> <span class="nf">split_into_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Splits self into separate frames.</span>

<span class="sd">        Args:</span>
<span class="sd">            inplace (bool): Whether to do the split inplace or not.</span>
<span class="sd">                Defaults to False and thus, returns a new `TrajEnsemble` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj_num</span><span class="p">,</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterframes</span><span class="p">():</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">TrajEnsemble</span><span class="o">.</span><span class="n">with_overwrite_trajnums</span><span class="p">(</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">trajs</span> <span class="o">!=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="TrajEnsemble.save_CVs">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.save_CVs">[docs]</a>
    <span class="k">def</span> <span class="nf">save_CVs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the CVs to a NETCDF file using xarray.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4&quot;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;h5netcdf&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TrajEnsemble.cluster">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.cluster">[docs]</a>
    <span class="k">def</span> <span class="nf">cluster</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cluster_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster_membership&quot;</span><span class="p">,</span>
        <span class="n">memberships</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clusters this :obj:`TrajEnsemble` based on the provided</span>
<span class="sd">        ``cluster_id`` and ``col``.</span>

<span class="sd">        With &#39;clustering&#39; we mean to extract a subset given a certain membership.</span>
<span class="sd">        Take two trajectories with 3 frames each as an ensemble. Let&#39;s say we</span>
<span class="sd">        calculate the end-to-end distance of the trajectories and use it as</span>
<span class="sd">        a collective variable of the system. The values are</span>
<span class="sd">        ``[0.8, 1.3, 1.2, 1.9, 0.2, 1.3]``. Based on these values, we define a</span>
<span class="sd">        boolean CV (using 0 as False and 1 as True) which says whether the</span>
<span class="sd">        end-to-end distance is smaller or grather than 1.0. We give this CV the</span>
<span class="sd">        name ``&#39;end_to_end_binary&#39;`` and the values are ``[0, 1, 1, 1, 0, 1]``.</span>
<span class="sd">        We can use this CV to &#39;cluster&#39; the :obj:`TrajEnsemble` via:</span>
<span class="sd">            - ``cluster = trajs.cluster(cluster_id=0, col=&#39;end_to_end_binary&#39;)``:</span>
<span class="sd">                This gives a :obj:`TrajEnsemble` with 2 frames.</span>
<span class="sd">            - ``cluster = trajs.cluster(cluster_id=0, col=&#39;end_to_end_binary&#39;)``:</span>
<span class="sd">                This gives a :obj:`TrajEnsemble` with 4 frames.</span>
<span class="sd">        Sometimes, you want to save this a cluster in a format that can be rendered</span>
<span class="sd">        by graphical programs (``.xtc, .pdb``), you can use either the :meth:`join` or</span>
<span class="sd">        :meth:`stack` method of the resulting :obj:``TrajEnsemble` to get a</span>
<span class="sd">        `mdtraj.Trajectory`, which is either stacked along the atom axis or</span>
<span class="sd">        joined along the time axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            If the resulting :obj:`TrajEnsemble` has inhomogeneous topologies, the</span>
<span class="sd">            :meth:`join` method will return a dict[md.Topology, md.Trajectory]</span>
<span class="sd">            instead. This dict can be used to save multiple (``.xtc, .pdb``) files</span>
<span class="sd">            and visualize your cluster in external programs.</span>

<span class="sd">        The ``col`` parameter takes any CV name, that is per-frame and integer.</span>

<span class="sd">        Args:</span>
<span class="sd">            cluster_id (int): The cluster id to use. Needs to be an integer,</span>
<span class="sd">                that is present in the ``col`` parameter.</span>
<span class="sd">            col (str): Which &#39;column&#39; of the collective variables to use.</span>
<span class="sd">                Needs to be a key, that can be found in ``trajs.CVs.keys()``.</span>
<span class="sd">            memberships (Optional[np.ndarray]): If a :obj:`numpy.ndarray` is</span>
<span class="sd">                provided here, the memberships from this array will be used.</span>
<span class="sd">                In this case, the ``col`` argument will be unused.</span>
<span class="sd">            n_points (int): How many points the resulting cluster should contain.</span>
<span class="sd">                Subsamples the points in ``col == cluster_id`` evenly and without</span>
<span class="sd">                repeat. If set to -1, all points will be used.</span>
<span class="sd">            overwrite (bool): When the ``memberships`` argument is used, but the</span>
<span class="sd">                :obj:`TrajEnsemble` already has a CV under the name specified by</span>
<span class="sd">                ``col``, you can set this to True to overwrite this column. Can</span>
<span class="sd">                be helpful, when you iteratively conduct multiple clusterings.</span>

<span class="sd">        Examples:</span>

<span class="sd">            Import EncoderMap and NumPy.</span>

<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>

<span class="sd">            Load an example project.</span>

<span class="sd">            &gt;&gt;&gt; trajs = em.load_project(&quot;pASP_pGLU&quot;, load_autoencoder=False)</span>

<span class="sd">            Create an array full of ``-1``&#39;s. These are the &#39;outliers&#39;.</span>

<span class="sd">            &gt;&gt;&gt; cluster_membership = np.ones(shape=(trajs.n_frames, )) * -1</span>

<span class="sd">            Select the first 5 frames of every traj to be in cluster 0.</span>

<span class="sd">            &gt;&gt;&gt; cluster_membership[trajs.id[:, 1] &lt; 5] = 0</span>

<span class="sd">            Select all frames between 50 and 55 to be cluster 1.</span>

<span class="sd">            &gt;&gt;&gt; cluster_membership[(50 &lt;= trajs.id[:, 1]) &amp; (trajs.id[:, 1] &lt;= 55)] = 1</span>
<span class="sd">            &gt;&gt;&gt; np.unique(cluster_membership)</span>
<span class="sd">            array([-1.,  0.,  1.])</span>

<span class="sd">            Load this array as a CV called ``&#39;clu_mem&#39;``.</span>

<span class="sd">            &gt;&gt;&gt; trajs.load_CVs(cluster_membership, attr_name=&#39;clu_mem&#39;)</span>

<span class="sd">            Extract all of cluster 0 with ``n_points=-1``.</span>

<span class="sd">            &gt;&gt;&gt; clu0 = trajs.cluster(0, &quot;clu_mem&quot;)</span>
<span class="sd">            &gt;&gt;&gt; clu0.n_frames</span>
<span class="sd">            35</span>

<span class="sd">            Extract an evenly spaced subset of cluster 1 with 10 total points.</span>

<span class="sd">            &gt;&gt;&gt; clu1 = trajs.cluster(1, &quot;clu_mem&quot;, n_points=10)</span>
<span class="sd">            &gt;&gt;&gt; clu1.n_frames</span>
<span class="sd">            10</span>

<span class="sd">            Cclusters with inhomogeneous topologies can be stacked along the atom axis.</span>

<span class="sd">            &gt;&gt;&gt; [t.n_atoms for t in trajs]</span>
<span class="sd">            [69, 83, 103, 91, 80, 63, 73]</span>
<span class="sd">            &gt;&gt;&gt; stacked = clu1.stack()</span>
<span class="sd">            &gt;&gt;&gt; stacked.n_atoms</span>
<span class="sd">            795</span>

<span class="sd">            But joining the trajectories returns a ``dict[top, traj]`` if the</span>
<span class="sd">            topologies are inhomogeneous.</span>

<span class="sd">            &gt;&gt;&gt; joined = clu1.join()</span>
<span class="sd">            &gt;&gt;&gt; type(joined)</span>
<span class="sd">            &lt;class &#39;dict&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">memberships</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">,</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Can&#39;t load </span><span class="si">{</span><span class="n">memberships</span><span class="si">}</span><span class="s2"> as new CVs. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The CV </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> containing cluster memberships already exists. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Choose a different name for the argument `col`.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_CVs</span><span class="p">(</span><span class="n">memberships</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">override</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;To use the CV &#39;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">&#39; for clustering, add it to the CVs with `load_CVs`.&quot;</span>

        <span class="c1"># find the index</span>
        <span class="n">index_</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index_arr</span><span class="p">[</span><span class="n">index_</span><span class="p">]</span>
        <span class="n">frame_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)[</span><span class="n">index_</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">index</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The `cluster_id` </span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="s2"> is not present in the `col` </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="n">col</span><span class="p">])</span><span class="si">=}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">n_points</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_points</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
            <span class="n">frame_index</span> <span class="o">=</span> <span class="n">frame_index</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_frames_by_index</span><span class="p">(</span><span class="n">frame_index</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">parse_clustal_w_alignment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">align_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;name CA&quot;</span><span class="p">,</span>
        <span class="n">superpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ref_align_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;name CA&quot;</span><span class="p">,</span>
        <span class="n">base_traj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">progbar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dict_keys</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">,</span> <span class="s2">&quot;cs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;top&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">superpose</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">align_string</span> <span class="o">==</span> <span class="n">ref_align_string</span> <span class="o">==</span> <span class="s2">&quot;name CA&quot;</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Aligning different topologies only possible, when the `align&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;_string` and `ref_align_string` both are &#39;name CA&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_is_notebook</span><span class="p">():</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">notebook_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">),</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Joining...&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">normal_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">),</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Joining...&quot;</span><span class="p">,</span>
                    <span class="n">function</span><span class="o">=</span><span class="s2">&quot;join&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progbar</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">progbar</span><span class="o">.</span><span class="n">total</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">),</span> <span class="n">function</span><span class="o">=</span><span class="s2">&quot;join&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">all_trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_by_top</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">dict_keys</span> <span class="o">==</span> <span class="s2">&quot;top&quot;</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_top</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">dict_keys</span> <span class="o">==</span> <span class="s2">&quot;cs&quot;</span><span class="p">:</span>
            <span class="n">iterator</span> <span class="o">=</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_common_str</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The argument `dict_keys` &#39;</span><span class="si">{</span><span class="n">dict_keys</span><span class="si">}</span><span class="s2">&#39; is not recognized.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">traj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">_traj_joined</span><span class="p">(</span><span class="n">progbar</span><span class="o">=</span><span class="n">progbar</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">superpose</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">base_traj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">CAs_traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">align_string</span><span class="p">)</span>
                    <span class="n">CAs_ref</span> <span class="o">=</span> <span class="n">base_traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">ref_align_string</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
                        <span class="n">new_CAs_traj</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">new_CAs_ref</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">i_t</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">i_r</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">aln_t</span><span class="p">,</span> <span class="n">aln_r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_top</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">trajs_by_top</span><span class="p">[</span><span class="n">base_traj</span><span class="o">.</span><span class="n">top</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">,</span>
                        <span class="p">):</span>
                            <span class="k">if</span> <span class="n">aln_t</span> <span class="o">==</span> <span class="n">aln_r</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                                <span class="k">pass</span>
                            <span class="k">elif</span> <span class="n">aln_t</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span> <span class="ow">and</span> <span class="n">aln_r</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                                <span class="n">i_t</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">elif</span> <span class="n">aln_t</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span> <span class="ow">and</span> <span class="n">aln_r</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                                <span class="n">i_r</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_CAs_traj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CAs_traj</span><span class="p">[</span><span class="n">i_t</span><span class="p">])</span>
                                <span class="n">new_CAs_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CAs_ref</span><span class="p">[</span><span class="n">i_r</span><span class="p">])</span>
                                <span class="n">i_t</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="n">i_r</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">new_CAs_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_CAs_traj</span><span class="p">)</span>
                        <span class="n">new_CAs_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_CAs_ref</span><span class="p">)</span>
                        <span class="n">CAs_traj</span> <span class="o">=</span> <span class="n">new_CAs_traj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">CAs_ref</span> <span class="o">=</span> <span class="n">new_CAs_ref</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">CAs_traj</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">CAs_ref</span><span class="p">))</span>
                        <span class="n">CAs_traj</span> <span class="o">=</span> <span class="n">CAs_traj</span><span class="p">[:</span><span class="n">length</span><span class="p">]</span>
                        <span class="n">CAs_ref</span> <span class="o">=</span> <span class="n">CAs_ref</span><span class="p">[:</span><span class="n">length</span><span class="p">]</span>
                    <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span>
                        <span class="n">base_traj</span><span class="p">,</span>
                        <span class="n">atom_indices</span><span class="o">=</span><span class="n">CAs_traj</span><span class="p">,</span>
                        <span class="n">ref_atom_indices</span><span class="o">=</span><span class="n">CAs_ref</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span>
                        <span class="n">traj</span><span class="p">,</span>
                        <span class="n">atom_indices</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">align_string</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">base_traj</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">all_trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
            <span class="n">out_by_top</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">traj</span>
            <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;join&quot;</span><span class="p">)</span>

        <span class="c1"># return</span>
        <span class="k">return</span> <span class="n">out_by_top</span>

    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">align_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;name CA&quot;</span><span class="p">,</span>
        <span class="n">superpose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ref_align_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;name CA&quot;</span><span class="p">,</span>
        <span class="n">base_traj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">progbar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_is_notebook</span><span class="p">():</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">notebook_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Stacking...&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="n">normal_tqdm</span><span class="p">(</span>
                    <span class="n">total</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                    <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Stacking...&quot;</span><span class="p">,</span>
                    <span class="n">function</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">progbar</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="n">progbar</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">progbar</span><span class="o">.</span><span class="n">total</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">function</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">progbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">all_trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">align_string</span><span class="p">,</span>
            <span class="n">superpose</span><span class="p">,</span>
            <span class="n">ref_align_string</span><span class="p">,</span>
            <span class="n">base_traj</span><span class="p">,</span>
            <span class="n">progbar</span><span class="o">=</span><span class="n">progbar</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># stack</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_trajs</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">traj</span><span class="p">):</span>
                <span class="n">atoms</span> <span class="o">+=</span> <span class="n">frame</span><span class="o">.</span><span class="n">n_atoms</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">stacked</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">stacked</span> <span class="o">=</span> <span class="n">stacked</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">progbar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">progbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">stacked</span><span class="o">.</span><span class="n">n_atoms</span> <span class="o">==</span> <span class="n">atoms</span>
        <span class="k">return</span> <span class="n">stacked</span>

    <span class="k">def</span> <span class="nf">_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CV</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a low-dimensional represnetation of the loaded CV data by</span>
<span class="sd">        stacking all arguments in `CV` along a single axis.</span>

<span class="sd">        If this `TrajEnsemble` has 10 trajectories with 100 frames each</span>
<span class="sd">        and a CV with shape (100, 50, 3) in each of them with the name &#39;cartesians&#39;</span>
<span class="sd">        then `trajs._trace` will return a np.ndarray of shape</span>
<span class="sd">        (1000, 150).</span>

<span class="sd">        Args:</span>
<span class="sd">            CV (Sequence[str]): The CVs to combine in the trace.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The trace.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">CV</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CV</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="c1"># frame nums can be inhomogeneous</span>
        <span class="n">frame_num</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_</span> <span class="o">:=</span> <span class="n">traj</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">frame_num</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frame_num</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
        <span class="n">time</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

        <span class="c1"># the CV data can be directly extracted from xarray</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">CV</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">[</span><span class="n">CV</span><span class="p">]</span>
                <span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">cv</span> <span class="ow">in</span> <span class="n">CV</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">[</span><span class="n">cv</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                    <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">cv</span><span class="o">.</span><span class="n">upper</span><span class="p">()})</span>
                <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;traj_file&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">traj_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="s2">&quot;top_file&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">top_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="s2">&quot;traj_num&quot;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="s2">&quot;frame_num&quot;</span><span class="p">:</span> <span class="n">frame_num</span><span class="p">,</span>
                <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">time</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">,</span> <span class="o">*</span><span class="n">data</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="TrajEnsemble.dash_summary">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.dash_summary">[docs]</a>
    <span class="k">def</span> <span class="nf">dash_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A :obj:`pandas.DataFrame` that summarizes this ensemble.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: The DataFrame.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dash_summary</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># atoms</span>
            <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">n_atoms</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">n_atoms</span> <span class="o">=</span> <span class="n">n_atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># dt</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">dt</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dt</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># traj_files</span>
            <span class="n">traj_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">basename</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

            <span class="c1"># topologies</span>
            <span class="n">multiple_tops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                <span class="p">{</span>
                    <span class="s2">&quot;field&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="s2">&quot;n_trajs&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;n_frames&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;n_atoms&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;dt (ps)&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;trajs&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;multiple tops&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;common_str&quot;</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span>
                        <span class="n">n_atoms</span><span class="p">,</span>
                        <span class="n">dt</span><span class="p">,</span>
                        <span class="n">traj_files</span><span class="p">,</span>
                        <span class="n">multiple_tops</span><span class="p">,</span>
                        <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="p">)),</span>
                    <span class="p">],</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span></div>


<div class="viewcode-block" id="TrajEnsemble.load_CVs">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.load_CVs">[docs]</a>
    <span class="k">def</span> <span class="nf">load_CVs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">TrajEnsembleFeatureType</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attr_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cols</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">directory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ensemble</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">override</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">custom_aas</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CustomAAsDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">alignment</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads CVs in various ways. The easiest way is to provide a single</span>
<span class="sd">        :obj:`numpy.ndarray` and a name for that array.</span>

<span class="sd">        Besides np.ndarray, files (``.txt and .npy``) can be loaded. Features</span>
<span class="sd">        or Featurizers can be provided. A :obj:`xarray.Dataset` can be provided.</span>
<span class="sd">        A str can be provided which either is the name of one of EncoderMap&#39;s</span>
<span class="sd">        features (`encodermap.features`) or the string can be &#39;all&#39;,</span>
<span class="sd">        which loads all features required for EncoderMap&#39;s</span>
<span class="sd">        :obj:`encodermap.autoencoder.autoencoder`AngleDihedralCartesianEncoderMap`.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (Optional[TrajEnsembleFeatureType]): The CV to</span>
<span class="sd">                load. When a :obj:`numpy.ndarray` is provided, it needs to have</span>
<span class="sd">                a shape matching ``n_frames`` and the data will be distributed</span>
<span class="sd">                to the trajs, When a list of files is provided, ``len(data)``</span>
<span class="sd">                (the files) needs to match ``n_trajs``. The first file will be</span>
<span class="sd">                loaded by the first traj (based on the traj&#39;s ``traj_num``) and</span>
<span class="sd">                so on. If a list of :obj:`numpy.ndarray` is provided, the first</span>
<span class="sd">                array will be assigned to the first traj (based on the traj&#39;s</span>
<span class="sd">                ``traj_num``). If None is provided, the argument ``directory``</span>
<span class="sd">                will be used to construct a str using this expression</span>
<span class="sd">                ``fname = directory + traj.basename + &#39;_&#39; + attr_name``. If</span>
<span class="sd">                there are ``.txt`` or ``.npy`` files matching that string in</span>
<span class="sd">                the ``directory``, the CVs will be loaded from these files to</span>
<span class="sd">                the corresponding trajs. Defaults to None.</span>
<span class="sd">            attr_name (Optional[str]): The name under which the CV should</span>
<span class="sd">                be found in the class. Choose whatever you like. ``&#39;highd&#39;``,</span>
<span class="sd">                ``&#39;lowd&#39;``, ``&#39;dists&#39;``, etc. The CV can then be accessed via</span>
<span class="sd">                dot-notation: ``trajs.attr_name``. Defaults to None, in which</span>
<span class="sd">                case, the argument ``data`` should point to existing files.</span>
<span class="sd">                The ``attr_name`` will be extracted from these files.</span>
<span class="sd">            cols (Optional[list[int]]): A list of integers indexing the columns</span>
<span class="sd">                of the data to be loaded. This is useful if a file contains</span>
<span class="sd">                columns which are not features (i.e. an indexer or the error of</span>
<span class="sd">                the features. eg::</span>

<span class="sd">                    id   f1    f2    f1_err    f2_err</span>
<span class="sd">                    0    1.0   2.0   0.1       0.1</span>
<span class="sd">                    1    2.5   1.2   0.11      0.52</span>

<span class="sd">                In that case, you would want to supply ``cols=[1, 2]`` to the</span>
<span class="sd">                ``cols`` argument. If None is provided all columns are loaded.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            deg (Optional[bool]): Whether to return angular CVs using degrees.</span>
<span class="sd">                If None or False, CVs will be in radian. Defaults to None.</span>
<span class="sd">            periodic (bool): Whether to use the minimum image convention to</span>
<span class="sd">                calculate distances/angles/dihedrals. This is generally recommended,</span>
<span class="sd">                when you don&#39;t clean up your trajectories and the proteins break</span>
<span class="sd">                over the periodic boundary conditions. However, when the protein is</span>
<span class="sd">                large, the distance between one site and another might be shorter</span>
<span class="sd">                through the periodic boundary. This can lead to wrong results</span>
<span class="sd">                in your distance calculations.</span>
<span class="sd">            labels (list[str]): A list containing the labels for the dimensions of</span>
<span class="sd">                the data. If you provide a :obj:`numpy.ndarray` with shape</span>
<span class="sd">                ``(n_trajs, n_frames, n_feat)``, this list needs to be of</span>
<span class="sd">                ``len(n_feat)``. An exception will be raised otherwise. If None is</span>
<span class="sd">                privided, the labels will be automatically generated. Defaults to None.</span>
<span class="sd">            directory (Optional[str]): If this argument is provided, the</span>
<span class="sd">                directory will be searched for ``.txt`` or ``.npy`` files which</span>
<span class="sd">                have the same names as the trajectories have basenames. The</span>
<span class="sd">                CVs will then be loaded from these files.</span>
<span class="sd">            ensemble (bool): Whether the trajs in this class belong to an ensemble.</span>
<span class="sd">                This implies that they contain either the same topology or are</span>
<span class="sd">                very similar (think wt, and mutant). Setting this option True will</span>
<span class="sd">                try to match the CVs of the trajs onto the same dataset.</span>
<span class="sd">                If a VAL residue has been replaced by LYS in the mutant,</span>
<span class="sd">                the number of sidechain dihedrals will increase. The CVs of the</span>
<span class="sd">                trajs with VAL will thus contain some NaN values. Defaults to False.</span>
<span class="sd">            override (bool): Whether to override CVs with the same name as ``attr_name``.</span>
<span class="sd">            custom_aas (Optional[CustomAAsDict]): You can provide non-standard</span>
<span class="sd">                residue definitions in this argument. See</span>
<span class="sd">                :obj:`encodermap.trajinfo.trajinfo_utils.CustomTopology` for</span>
<span class="sd">                information how to use the custom_aas argument. If set to None</span>
<span class="sd">                (default), only standard residue names are assumed.</span>
<span class="sd">            alignment (Optional[str]): If your proteins have similar but different</span>
<span class="sd">                sequences, you can provide a CLUSTAL W alignment as this argument</span>
<span class="sd">                and the featurization will align the features accordingly.</span>

<span class="sd">        Raises:</span>
<span class="sd">            TypeError: When wrong Type has been provided for data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Local Folder Imports</span>
        <span class="kn">from</span> <span class="nn">.trajinfo_utils</span> <span class="kn">import</span> <span class="n">load_CVs_ensembletraj</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">featurizer</span>

        <span class="k">if</span> <span class="n">custom_aas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_custom_topology</span><span class="p">(</span><span class="n">custom_aas</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alignment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ensemble</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parse_clustal_w_alignment</span><span class="p">(</span><span class="n">alignment</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Providing a CLUSTAL W alignment for featurization of ensembles &quot;</span>
                    <span class="s2">&quot;of protein families, makes only sense, when `ensemble` is also &quot;</span>
                    <span class="s2">&quot;set to True. This makes EncoderMap align the features based &quot;</span>
                    <span class="s2">&quot;on their sequence alignment.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># if some trajs are missing time</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">backend</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]),</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">:</span>
                <span class="n">traj</span><span class="o">.</span><span class="n">load_traj</span><span class="p">()</span>

        <span class="n">load_CVs_ensembletraj</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">attr_name</span><span class="p">,</span>
            <span class="n">cols</span><span class="p">,</span>
            <span class="n">deg</span><span class="p">,</span>
            <span class="n">periodic</span><span class="p">,</span>
            <span class="n">labels</span><span class="p">,</span>
            <span class="n">directory</span><span class="p">,</span>
            <span class="n">ensemble</span><span class="p">,</span>
            <span class="n">override</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TrajEnsemble.save">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fname</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
        <span class="n">CVs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">only_top</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves this TrajEnsemble into a single ``.h5`` file.</span>

<span class="sd">        Args:</span>
<span class="sd">            fname (Union[str, Path]): Where to save the file.</span>
<span class="sd">            CVs (Union[Literal[&quot;all&quot;], list[str], Literal[False]]): Which CVs</span>
<span class="sd">                to alos store in the file. If set to ``&#39;all&#39;``, all CVs will</span>
<span class="sd">                be saved. Otherwise, a list[str] can be provided to only save</span>
<span class="sd">                specific CVs. Can also be set to False, no CVs are stored in the</span>
<span class="sd">                file.</span>
<span class="sd">            overwrite (bool): If the file exists, it is overwritten.</span>
<span class="sd">            only_top (bool): Only writes the trajectorie&#39;s topologies into the file.</span>

<span class="sd">        Raises:</span>
<span class="sd">            IOError: If file already exists and overwrite is not True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">from</span> <span class="nn">mdtraj.utils</span> <span class="kn">import</span> <span class="n">in_units_of</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t currently save a `TrajEnsemble` with a clustal w alignment&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">fname</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">fname</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.h5&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;We recommend the .h5 file extension for these files.&quot;</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">only_top</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;File </span><span class="si">{</span><span class="n">fname</span><span class="si">}</span><span class="s2"> already exists. Set `overwrite` to True to overwrite.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">fname</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertrajs</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">HDF5GroupWrite</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">force_overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">only_top</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write_into_group</span><span class="p">(</span>
                        <span class="n">group_id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                        <span class="n">coordinates</span><span class="o">=</span><span class="n">in_units_of</span><span class="p">(</span>
                            <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="o">.</span><span class="n">_distance_unit</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">distance_unit</span>
                        <span class="p">),</span>
                        <span class="n">time</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">time</span><span class="p">,</span>
                        <span class="n">cell_lengths</span><span class="o">=</span><span class="n">in_units_of</span><span class="p">(</span>
                            <span class="n">traj</span><span class="o">.</span><span class="n">unitcell_lengths</span><span class="p">,</span>
                            <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="o">.</span><span class="n">_distance_unit</span><span class="p">,</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">distance_unit</span><span class="p">,</span>
                        <span class="p">),</span>
                        <span class="n">cell_angles</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_angles</span><span class="p">,</span>
                        <span class="n">topology</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write_topology</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="p">,</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertrajs</span><span class="p">():</span>
            <span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
            <span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">to_hdf_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">traj</span><span class="o">.</span><span class="n">_common_str_to_hdf_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">CVs</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">save_netcdf_alongside_mdtraj</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span> <span class="ow">and</span> <span class="n">CVs</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;CVs&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">grp</span> <span class="o">=</span> <span class="n">file</span><span class="p">[</span><span class="s2">&quot;CVs&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grp</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s2">&quot;CVs&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">CVs</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">grp</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_return_trajs_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a :obj:`TrajEnsemble` object with the trajs specified by ``index``.</span>

<span class="sd">        This is a sub-method of the ``trajs[]`` indexer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_common_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_common_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">common_str</span><span class="p">)</span>
        <span class="n">new_common_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_common_str</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trajs_subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">_gen_ensemble</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">_gen_ensemble</span><span class="p">()</span>
                <span class="n">trajs_subset</span> <span class="o">+=</span> <span class="n">new_traj</span>
        <span class="n">trajs_subset</span><span class="o">.</span><span class="n">common_str</span> <span class="o">=</span> <span class="n">new_common_str</span>
        <span class="n">trajs_subset</span><span class="o">.</span><span class="n">basename_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span>
        <span class="k">return</span> <span class="n">trajs_subset</span>

    <span class="k">def</span> <span class="nf">_return_frames_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a :obj:`TrajEnsemble` object with the frames specified by ``index``.&quot;&quot;&quot;</span>
        <span class="n">new_common_str</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">traj_num</span><span class="p">,</span> <span class="n">frame_num</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterframes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">frame_num</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
            <span class="n">new_common_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">common_str</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Can&#39;t return frames with index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> from trajectory with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;frames </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">[:,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>
        <span class="n">new_common_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_common_str</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trajs_subset</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_gen_ensemble</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_traj</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_gen_ensemble</span><span class="p">()</span>
                <span class="n">trajs_subset</span> <span class="o">=</span> <span class="n">trajs_subset</span> <span class="o">+</span> <span class="n">new_traj</span>
        <span class="n">trajs_subset</span><span class="o">.</span><span class="n">common_str</span> <span class="o">=</span> <span class="n">new_common_str</span>
        <span class="n">trajs_subset</span><span class="o">.</span><span class="n">basename_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span>
        <span class="k">return</span> <span class="n">trajs_subset</span>

    <span class="k">def</span> <span class="nf">_pyemma_indexing_tsel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new :obj:`TrajEnsemble` by giving the indices of traj and frame.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">key</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tsel</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">.</span><span class="n">fsel</span><span class="p">[</span><span class="n">frames</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">TrajEnsemble</span><span class="p">(</span>
            <span class="n">trajs</span><span class="p">,</span> <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span><span class="p">,</span> <span class="n">common_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pyemma_indexing_no_tsel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a new :obj:`TrajEnsemble` by giving the indices of traj and frame.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">key</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
            <span class="k">assert</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can&#39;t identify trajectory with number </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2"> in an ensemble &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="si">}</span><span class="s2"> trajectories.&quot;</span>
            <span class="p">)</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">key</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="n">frames</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">TrajEnsemble</span><span class="p">(</span>
            <span class="n">trajs</span><span class="p">,</span> <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span><span class="p">,</span> <span class="n">common_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span>
        <span class="p">)</span>

<div class="viewcode-block" id="TrajEnsemble.subsample">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.subsample">[docs]</a>
    <span class="k">def</span> <span class="nf">subsample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stride</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">total</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TrajEnsemble</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a subset of this :obj:`TrajEnsemble` given the provided stride</span>
<span class="sd">        or total.</span>

<span class="sd">        This is a faster alternative than using the ``trajs[trajs.index_arr[::1000]]``</span>
<span class="sd">        when HDF5 trajs are used, because the slicing information is saved in the</span>
<span class="sd">        respective :obj:`encodermap.trajinfo.info_single.SingleTraj`</span>
<span class="sd">         and loading of single frames is faster in HDF5 formatted trajs.</span>

<span class="sd">        Args:</span>
<span class="sd">            stride (Optional[int]): Return a frame ever stride frames.</span>
<span class="sd">            total (Optional[int]): Return a total of evenly sampled frames.</span>

<span class="sd">        Returns:</span>
<span class="sd">            TrajEnsemble: A trajectory ensemble.</span>

<span class="sd">        Note:</span>
<span class="sd">            The result from ``subsample(1000)` `is different from</span>
<span class="sd">            ``trajs[trajs.index_arr[::1000]]``. With subsample every trajectory</span>
<span class="sd">            is sub-sampled independently. Consider a :obj:`TrajEnsemble` with two</span>
<span class="sd">            :obj:`encodermap.trajinfo.info_single.SingleTraj` trajectories with</span>
<span class="sd">            18 frames each. ``subsampled = trajs.subsample(5)`` would return a</span>
<span class="sd">            :obj:`TrajEnsemble` with two trajs with 3 frames each</span>
<span class="sd">            (``subsampled.n_frames == 6``). Whereas,</span>
<span class="sd">            ``subsampled = trajs[trajs.index_arr[::5]]`` would return a</span>
<span class="sd">            :obj:`TrajEnsemble` with 7 SingleTrajs with 1 frame each</span>
<span class="sd">            (``subsampled.n_frames == 7``). Because the time and frame numbers</span>
<span class="sd">            are saved all the time, this should not be too much of a problem.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">total</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">total</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stride</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trajs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">):</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">traj</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="p">)]</span>
                <span class="n">trajs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">TrajEnsemble</span><span class="p">(</span>
                <span class="n">trajs</span><span class="p">,</span> <span class="n">common_str</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="p">,</span> <span class="n">basename_fn</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">basename_fn</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Provide either stride or total.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TrajEnsemble.get_single_frame">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.get_single_frame">[docs]</a>
    <span class="k">def</span> <span class="nf">get_single_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;SingleTraj&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a single frame from all loaded trajectories.</span>

<span class="sd">        Consider a :obj:`TrajEnsemble` class with two trajectories. One has 10</span>
<span class="sd">        frames, the other 5 (``trajs.n_frames`` is 15). Calling</span>
<span class="sd">        ``trajs.get_single_frame(12)`` is equal to calling ``trajs[1][1]``.</span>
<span class="sd">        Calling ``trajs.get_single_frame(16)`` will error, and</span>
<span class="sd">        ``trajs.get_single_frame(1)`` is the same as ``trajs[0][1]``.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (int): The frame to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            encodermap.trajinfo.info_single.SingleTraj: The frame.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># some input checks</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Indexing a no_load backend does not work. I need some &quot;</span>
                <span class="s2">&quot;information about the frames in each trajectory. Please &quot;</span>
                <span class="s2">&quot;load either highd or lowd.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2"> is out of bounds for trajectory with </span><span class="si">{}</span><span class="s2"> frames&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="s2">&quot;if you want a single frame, please provide an integer. &quot;</span>
                <span class="s2">&quot;If you want multiple frames use ep.TrajEnsemble[]&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">traj_num</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">n_frames</span><span class="p">)])</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">traj_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">traj_nums</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">traj_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tsel</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="n">frame</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traj_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">num</span><span class="p">][</span><span class="n">frame</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">traj_out</span></div>


<div class="viewcode-block" id="TrajEnsemble.unload">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.unload">[docs]</a>
    <span class="k">def</span> <span class="nf">unload</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unloads all trajs in self.&quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">unload</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;no_load&quot;</span></div>


<div class="viewcode-block" id="TrajEnsemble.load_trajs">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.load_trajs">[docs]</a>
    <span class="k">def</span> <span class="nf">load_trajs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads all trajs in self.&quot;&quot;&quot;</span>
        <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">load_traj</span><span class="p">()</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="s2">&quot;mdtraj&quot;</span></div>


    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">batch_iterator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,),</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">yield_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">batch_iterator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,),</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">yield_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">batch_iterator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">yield_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">batch_iterator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">yield_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="p">]:</span> <span class="o">...</span>

<div class="viewcode-block" id="TrajEnsemble.batch_iterator">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.batch_iterator">[docs]</a>
    <span class="k">def</span> <span class="nf">batch_iterator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">yield_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lazy batched iterator of CV data.</span>

<span class="sd">        This iterator extracts batches of CV data from the ensemble. If the</span>
<span class="sd">        ensemble is a large HDF5 datset, this provides the ability to use all</span>
<span class="sd">        data without loading it all into memory.</span>

<span class="sd">        Examples:</span>

<span class="sd">            Import EncoderMap and load some example trajectories.</span>

<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; trajs = em.TrajEnsemble(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUG.pdb&#39;,</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUF.pdb&#39;</span>
<span class="sd">            ...     ]</span>
<span class="sd">            ... )</span>

<span class="sd">            This iterator will yield new samples forever. The batch is a tuple</span>
<span class="sd">            of :obj:`numpy.ndarray`.</span>

<span class="sd">            &gt;&gt;&gt; for batch in trajs.batch_iterator(batch_size=2):</span>
<span class="sd">            ...     print([b.shape for b in batch])</span>
<span class="sd">            ...     break</span>
<span class="sd">            [(2, 148), (2, 147), (2, 150, 3), (2, 149), (2, 82)]</span>

<span class="sd">            Use it with Python&#39;s builtin ``next()`` function. The ``deterministic``</span>
<span class="sd">            flag returns deterministic batches. The ``yield_index`` flag also</span>
<span class="sd">            provides the index of the extracted batch. In this example, both batches</span>
<span class="sd">            are extracted from the 1YUG trajectory (``traj_num==0``).</span>

<span class="sd">            &gt;&gt;&gt; iterator = trajs.batch_iterator(deterministic=True, batch_size=2, yield_index=True)</span>
<span class="sd">            &gt;&gt;&gt; index, batch = next(iterator)</span>
<span class="sd">            &gt;&gt;&gt; index</span>
<span class="sd">            [[0 5]</span>
<span class="sd">             [0 8]]</span>
<span class="sd">            &gt;&gt;&gt; index, batch = next(iterator)</span>
<span class="sd">            &gt;&gt;&gt; index</span>
<span class="sd">            [[ 0  3]</span>
<span class="sd">             [ 0 10]]</span>

<span class="sd">             If a single string is requested for ``CV_names``, the batch, will</span>
<span class="sd">             be a sinlge :obj:`numpy.ndarray`, rather than a tuple thereof.</span>

<span class="sd">             &gt;&gt;&gt; iterator = trajs.batch_iterator(batch_size=2, CV_names=[&quot;central_dihedrals&quot;])</span>
<span class="sd">            &gt;&gt;&gt; batch = next(iterator)</span>
<span class="sd">            &gt;&gt;&gt; batch.shape</span>
<span class="sd">            (2, 147)</span>

<span class="sd">        Args:</span>
<span class="sd">            batch_size (int): The size of the batch.</span>
<span class="sd">            replace (bool): Whether inside a single batch a sample can occur</span>
<span class="sd">                more than once. Set to False (default) to only allow unique</span>
<span class="sd">                samples in a batch.</span>
<span class="sd">            CV_names (Sequence[str]): The names of the CVs to be used in the</span>
<span class="sd">                iterator. If a list/tuple with a single string is provided, the</span>
<span class="sd">                batch will be a :obj:`numpy.ndarray`, rather than a tuple</span>
<span class="sd">                thereof.</span>
<span class="sd">            deterministic (bbol): Whether the samples should be deterministic.</span>
<span class="sd">            yield_index (bool): Whether to also yield the index of the extracted</span>
<span class="sd">                samples.</span>
<span class="sd">            start (int): A start ineteger, which can be used together with</span>
<span class="sd">                ``deterministic=True`` to get different deterministic datasets.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Iterator[Any]: Different iterators based on chosen arguments.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Encodermap imports</span>
        <span class="kn">from</span> <span class="nn">encodermap.autoencoder.autoencoder</span> <span class="kn">import</span> <span class="n">np_to_sparse_tensor</span>

        <span class="c1"># the standard CV_names</span>
        <span class="k">if</span> <span class="n">CV_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">CV_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_cartesians&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs_in_file</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">index</span> <span class="o">==</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]):</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">traj_file</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;h5netcdf&quot;</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;CVs&quot;</span>
            <span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">CV_names</span><span class="p">]</span>
            <span class="n">total_len</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;frame&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">[</span><span class="n">CV_names</span><span class="p">]</span>
            <span class="n">total_len</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">ds</span><span class="o">.</span><span class="n">stack</span><span class="p">({</span><span class="s2">&quot;frame&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;traj_num&quot;</span><span class="p">,</span> <span class="s2">&quot;frame_num&quot;</span><span class="p">)})</span>
                <span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
                <span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s2">&quot;frame&quot;</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="s2">&quot;frame&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">traj_nums_and_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs_in_file</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj_nums_and_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">total_len</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The CVs of the trajs are not aligned with the frames. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;CVs stacked along the traj/frame axis have a shape of </span><span class="si">{</span><span class="n">total_len</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;while the id array of the trajs has a shape of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The frames of the trajs are reported as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="si">}</span><span class="s2">. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;CV data was extracted from the .h5 file </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">traj_file</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;by stacking the traj/frame axis into a combined axis and dropping &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;the frames full of NaNs for the CVs </span><span class="si">{</span><span class="n">CV_names</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">traj_nums_and_frames</span><span class="p">)</span> <span class="o">==</span> <span class="n">total_len</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The CVs of the trajs are not aligned with the frames. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;CVs stacked along the traj/frame axis have a shape of </span><span class="si">{</span><span class="n">total_len</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;while the id array of the trajs has a shape of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;The frames of the trajs are reported as </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="si">}</span><span class="s2">. The CV &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;data was obtained from combining the CVs </span><span class="si">{</span><span class="n">CV_names</span><span class="si">}</span><span class="s2"> of the trajectories &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in this ensemble along a traj axis.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># detect sparse or sidechain only sparse</span>
        <span class="n">sparse</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">sub_ds</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">frame_num</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">CV_names</span><span class="p">:</span>
            <span class="n">datum</span> <span class="o">=</span> <span class="n">sub_ds</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">datum</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">sparse</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c1"># start the loop</span>
        <span class="c1"># i is the counter for the sample</span>
        <span class="c1"># j is the counter for how many tries were needed to select either</span>
        <span class="c1"># unique indices (if replace is False) or select indices where not</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">start</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">CV_names</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">batch_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">batch_size</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Can&#39;t find unique indices after 100 iterations. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Current index is </span><span class="si">{</span><span class="n">index</span><span class="si">=}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="n">deterministic</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">traj_nums_and_frames</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">total_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">index</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">traj_num</span><span class="o">=</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame_num</span><span class="o">=</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># check if any values in CV_names are all nans</span>
                <span class="c1"># this can happen for ensembles with different length trajectories</span>
                <span class="c1"># we append to `out_`, because if not all nans for this frame</span>
                <span class="c1"># we can append `out_` to `out`</span>
                <span class="n">out_</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">CV_names</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">o</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                    <span class="k">if</span> <span class="s2">&quot;dist&quot;</span> <span class="ow">in</span> <span class="n">o</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">),</span> <span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Distances for the selection traj_num=</span><span class="si">{</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> frame=</span><span class="si">{</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;contained a 0. This will result in problems with the cartesian &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;cost.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                        <span class="c1"># if all nans break</span>
                        <span class="n">out_</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># and continue</span>
                <span class="k">if</span> <span class="n">out_</span> <span class="o">==</span> <span class="p">[]:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="c1"># if not, we can append</span>
                <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">out_</span><span class="p">):</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># stack</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span><span class="p">]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

            <span class="c1"># make sparse tensors</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">CV_names</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">sparse</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np_to_sparse_tensor</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># and yield</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">CV_names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">yield_index</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">index</span><span class="p">,</span> <span class="n">out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">out</span></div>


    <span class="k">def</span> <span class="nf">tf_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">replace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sidechains</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">reconstruct_sidechains</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">CV_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deterministic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">prefetch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
        <span class="c1"># Third Party Imports</span>
        <span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

        <span class="n">gen</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_iterator</span><span class="p">(</span>
            <span class="n">batch_size</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">CV_names</span><span class="p">,</span> <span class="n">deterministic</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">start</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">CV_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sidechains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reconstruct_sidechains</span><span class="p">:</span>
            <span class="n">CV_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_cartesians&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">CV_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sidechains</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reconstruct_sidechains</span><span class="p">:</span>
            <span class="n">CV_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_cartesians&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">CV_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">reconstruct_sidechains</span><span class="p">:</span>
            <span class="n">CV_names</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;all_cartesians&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_distances&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">CV_names</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;The CV &#39;</span><span class="si">{</span><span class="n">o</span><span class="si">}</span><span class="s2">&#39; is not loaded in this ensemble.&quot;</span>

        <span class="c1"># define the TensorSpecs</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_iterator</span><span class="p">(</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span>
                <span class="n">CV_names</span><span class="o">=</span><span class="n">CV_names</span><span class="p">,</span>
                <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">tensor_specs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">):</span>
                    <span class="n">tensor_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">tf</span><span class="o">.</span><span class="n">SparseTensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dense_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tensor_specs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">))</span>
            <span class="n">tensor_specs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tensor_specs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tensor_specs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorSpec</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span><span class="n">gen</span><span class="p">,</span> <span class="n">output_signature</span><span class="o">=</span><span class="n">tensor_specs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prefetch</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">batch_size</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deterministic</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>
            <span class="n">options</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">with_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">dataset</span><span class="o">.</span><span class="n">options</span><span class="p">()</span><span class="o">.</span><span class="n">deterministic</span>
        <span class="k">return</span> <span class="n">dataset</span>

<div class="viewcode-block" id="TrajEnsemble.itertrajs">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.itertrajs">[docs]</a>
    <span class="k">def</span> <span class="nf">itertrajs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;SingleTraj&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator over the SingleTraj classes.</span>

<span class="sd">        Yields:</span>
<span class="sd">            tuple: A tuple containing the following:</span>
<span class="sd">                - int: A loop-counter integer. Is identical with traj.traj_num.</span>
<span class="sd">                - encodermap.SingleTraj: An SingleTraj object.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; trajs = em.TrajEnsemble(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUG.pdb&#39;,</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUF.pdb&#39;</span>
<span class="sd">            ...     ]</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; for i, traj in trajs.itertrajs():</span>
<span class="sd">            ...     print(traj.basename)</span>
<span class="sd">            1YUG</span>
<span class="sd">            1YUF</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">traj</span><span class="o">.</span><span class="n">traj_num</span><span class="p">,</span> <span class="n">traj</span></div>


<div class="viewcode-block" id="TrajEnsemble.iterframes">
<a class="viewcode-back" href="../../../user_guide/trajensemble.html#encodermap.trajinfo.info_all.TrajEnsemble.iterframes">[docs]</a>
    <span class="k">def</span> <span class="nf">iterframes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="s2">&quot;SingleTraj&quot;</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generator over the frames in this instance.</span>

<span class="sd">        Yields:</span>
<span class="sd">            tuple: A tuple containing the following:</span>
<span class="sd">                - int: The traj_num</span>
<span class="sd">                - int: The frame_num</span>
<span class="sd">                - encodermap.SingleTraj: An SingleTraj object.</span>

<span class="sd">        Examples:</span>

<span class="sd">            Import EncoderMap and load an example :obj:`TrajEnsemble`.</span>


<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; trajs = em.TrajEnsemble(</span>
<span class="sd">            ...     [</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUG.pdb&#39;,</span>
<span class="sd">            ...         &#39;https://files.rcsb.org/view/1YUF.pdb&#39;,</span>
<span class="sd">            ...     ],</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; print(trajs.n_frames)</span>
<span class="sd">            31</span>

<span class="sd">            Subsample every tenth frame.</span>

<span class="sd">            &gt;&gt;&gt; trajs = trajs.subsample(10)</span>
<span class="sd">            &gt;&gt;&gt; trajs.n_frames</span>
<span class="sd">            4</span>

<span class="sd">            Call the :meth:`iterframes` method.</span>

<span class="sd">            &gt;&gt;&gt; for traj_num, frame_num, frame in trajs.iterframes():</span>
<span class="sd">            ...     print(traj_num, frame_num, frame.n_frames)</span>
<span class="sd">            0 0 1</span>
<span class="sd">            0 10 1</span>
<span class="sd">            1 0 1</span>
<span class="sd">            1 10 1</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">traj</span><span class="o">.</span><span class="n">iterframes</span><span class="p">(</span><span class="n">with_traj_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="c1"># Standard Library Imports</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">CanBeIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TrajEnsemble</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_trajs_by_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_class</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_return_trajs_by_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_class</span>
            <span class="k">elif</span> <span class="n">key</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pyemma_indexing_no_tsel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">new_class</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Passing a key with more than 2 dimensions makes no sense. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;One dim for trajs, one for frames. Your key has &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="p">)</span>
            <span class="n">list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span>
            <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">list_</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">new_class</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid argument for slicing: </span><span class="si">{</span><span class="n">key</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__reversed__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># check if traj_files and ids are the same</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Standard Library Imports</span>
            <span class="kn">import</span> <span class="nn">functools</span>

            <span class="n">same_strings</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">,</span>
                <span class="nb">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">traj_file</span> <span class="k">for</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">],</span>
                    <span class="p">[</span><span class="n">traj2</span><span class="o">.</span><span class="n">traj_file</span> <span class="k">for</span> <span class="n">traj2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">trajs</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">same_ids</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">traj1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">traj2</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">traj1</span><span class="p">,</span> <span class="n">traj2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">trajs</span><span class="p">)</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">same_CVs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_CVs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">same_strings</span> <span class="ow">and</span> <span class="n">same_ids</span> <span class="ow">and</span> <span class="n">same_CVs</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reverse addition to make sum() work.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Addition of two TrajEnsemble objects returns new TrajEnsemble with</span>
<span class="sd">        trajectories joined along the traj axis.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># assert the other contains trajs</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">trajs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The `TrajEnsemble` </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2"> does not contain any trajs and can&#39;t &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;be used in addition.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># decide on the new backend</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">backend</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Mismatch between the backends. Using &#39;mdtraj&#39;.&quot;</span><span class="p">)</span>
            <span class="n">y</span><span class="o">.</span><span class="n">load_trajs</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_trajs</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_nums</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">traj_nums</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Can&#39;t add two `TrajEnsemble` with overlapping traj_nums: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;left side: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_nums</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;right side: </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">traj_nums</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># build a common_str_ array with the correct number of entries</span>
        <span class="c1"># use this to create a new class</span>
        <span class="c1"># if there are no references in self or y. One of them was created from mdtraj.Trajectories</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">_top_files</span><span class="p">]):</span>
            <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">trajs</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">common_str_</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">get_full_common_str_and_ref</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traj_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_str</span>
                <span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">get_full_common_str_and_ref</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">traj_files</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">common_str</span><span class="p">)[</span>
                    <span class="mi">2</span>
                <span class="p">]</span>
            <span class="p">)</span>
            <span class="n">common_str_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">common_str_</span><span class="p">))</span>
            <span class="n">new_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traj_files</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">traj_files</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_top_files</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">_top_files</span><span class="p">,</span>
                <span class="n">traj_nums</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj_nums</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">traj_nums</span><span class="p">,</span>
                <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span>
                <span class="n">common_str</span><span class="o">=</span><span class="n">common_str_</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># put the trajs directly in the new class. This way the frames of the SingleTraj classes are preserved</span>
        <span class="n">new_class</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">trajs</span>

        <span class="k">return</span> <span class="n">new_class</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_string_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">trajectory</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;encodermap.TrajEnsemble object. Current backend is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="si">}</span><span class="s2">. Containing </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span><span class="si">}</span><span class="s2"> frames and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="si">}</span><span class="s2"> trajectories.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;encodermap.TrajEnsemble object. Current backend is &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="si">}</span><span class="s2">. Containing </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_trajs</span><span class="si">}</span><span class="s2"> trajectories.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; Common str is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">common_str</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; CV </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> with shape </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> loaded.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot; Not containing any CVs.&quot;</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_frames</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_string_summary</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_string_summary</span><span class="p">()</span><span class="si">}</span><span class="s2"> Object at 0x</span><span class="si">{</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">:</span><span class="s2">02x</span><span class="si">}</span><span class="s2">&gt;&quot;</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Kevin Sawade, Tobias Lemke, University of Konstanz.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__center">
      
        <div class="footer-item"><p class="last-updated">
  Last updated on 2025-05-15T21:15:05.
  <br/>
</p></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">Docs for EncoderMap 3.0.1+10.g67ae638.dirty</div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>