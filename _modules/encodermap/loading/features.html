
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>encodermap.loading.features &#8212; encodermap 3.0.1+10.g67ae638.dirty documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=c1026b93" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../_static/documentation_options.js?v=ea0ca436"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../_static/copybutton.js?v=30646c52"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/encodermap/loading/features';</script>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="3.0.1+10.g67ae638.dirty" />
    <meta name="docbuild:last-update" content="2025-05-15T21:15:05"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-light" alt="encodermap 3.0.1+10.g67ae638.dirty documentation - Home"/>
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-dark pst-js-only" alt="encodermap 3.0.1+10.g67ae638.dirty documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started/index.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notebooks/index.html">
    Notebook Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../getting_started/index.html">
    Getting started
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../notebooks/index.html">
    Notebook Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../user_guide/index.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../api/index.html">
    API
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../contributing/index.html">
    Contributing
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">encodermap.loading.features</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for encodermap.loading.features</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># encodermap/loading/features.py</span>
<span class="c1">################################################################################</span>
<span class="c1"># EncoderMap: A python library for dimensionality reduction.</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2019-2024 University of Konstanz and the Authors</span>
<span class="c1">#</span>
<span class="c1"># Authors:</span>
<span class="c1"># Kevin Sawade, Patricia Schwarz</span>
<span class="c1">#</span>
<span class="c1"># Encodermap is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as</span>
<span class="c1"># published by the Free Software Foundation, either version 2.1</span>
<span class="c1"># of the License, or (at your option) any later version.</span>
<span class="c1"># This package is distributed in the hope that it will be useful to other</span>
<span class="c1"># researches. IT DOES NOT COME WITH ANY WARRANTY WHATSOEVER; without even the</span>
<span class="c1"># implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1"># See the GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># See &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">################################################################################</span>
<span class="sd">&quot;&quot;&quot;Features contain topological information of proteins and other biomolecules.</span>

<span class="sd">These topological information can be calculated once and then provided with</span>
<span class="sd">input coordinates to calculate frame-wise collective variables of MD simulations.</span>

<span class="sd">The features in this module used to inherit from PyEMMA&#39;s features</span>
<span class="sd">(https://github.com/markovmodel/PyEMMA), but PyEMMA has since been archived.</span>

<span class="sd">If using EncoderMap&#39;s featurization make sure to also cite PyEMMA, from which</span>
<span class="sd">a lot of this code was adopted::</span>

<span class="sd">   @article{scherer_pyemma_2015,</span>
<span class="sd">        author = {Scherer, Martin K. and Trendelkamp-Schroer, Benjamin</span>
<span class="sd">                  and Paul, Fabian and Pérez-Hernández, Guillermo and Hoffmann, Moritz and</span>
<span class="sd">                  Plattner, Nuria and Wehmeyer, Christoph and Prinz, Jan-Hendrik and Noé, Frank},</span>
<span class="sd">        title = {{PyEMMA} 2: {A} {Software} {Package} for {Estimation},</span>
<span class="sd">                 {Validation}, and {Analysis} of {Markov} {Models}},</span>
<span class="sd">        journal = {Journal of Chemical Theory and Computation},</span>
<span class="sd">        volume = {11},</span>
<span class="sd">        pages = {5525-5542},</span>
<span class="sd">        year = {2015},</span>
<span class="sd">        issn = {1549-9618},</span>
<span class="sd">        shorttitle = {{PyEMMA} 2},</span>
<span class="sd">        url = {http://dx.doi.org/10.1021/acs.jctc.5b00743},</span>
<span class="sd">        doi = {10.1021/acs.jctc.5b00743},</span>
<span class="sd">        urldate = {2015-10-19},</span>
<span class="sd">        month = oct,</span>
<span class="sd">   }</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">################################################################################</span>
<span class="c1"># Imports</span>
<span class="c1">################################################################################</span>


<span class="c1"># Future Imports at the top</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="c1"># Standard Library Imports</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Final</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span>

<span class="c1"># Third Party Imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">optional_imports</span> <span class="kn">import</span> <span class="n">_optional_import</span>


<span class="c1">################################################################################</span>
<span class="c1"># Typing</span>
<span class="c1">################################################################################</span>


<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="c1"># Third Party Imports</span>
    <span class="kn">import</span> <span class="nn">dask</span>
    <span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>

    <span class="c1"># Encodermap imports</span>
    <span class="kn">from</span> <span class="nn">encodermap.trajinfo.info_all</span> <span class="kn">import</span> <span class="n">TrajEnsemble</span>
    <span class="kn">from</span> <span class="nn">encodermap.trajinfo.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>
    <span class="kn">from</span> <span class="nn">encodermap.trajinfo.trajinfo_utils</span> <span class="kn">import</span> <span class="n">_AMINO_ACID_CODES</span>


<span class="n">AllCartesiansType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AllCartesians&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">AllBondDistancesType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AllBondDistances&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">CentralCartesiansType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;CentralCartesians&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">CentralBondDistancesType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;CentralBondDistances&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">CentralAnglesType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;CentralAngles&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">CentralDihedralsType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;CentralDihedrals&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SideChainCartesiansType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SideChainCartesians&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SideChainBondDistancesType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SideChainBondDistances&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SideChainAnglesType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SideChainAngles&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SideChainDihedralsType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SideChainDihedrals&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">CustomFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;CustomFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SelectionFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SelectionFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">AngleFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AngleFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">DihedralFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;DihedralFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">DistanceFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;DistanceFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">AlignFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AlignFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">InverseDistanceFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;InverseDistanceFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">ContactFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ContactFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">BackboneTorsionFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;BackboneTorsionFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">ResidueMinDistanceFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ResidueMinDistanceFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">GroupCOMFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;GroupCOMFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">ResidueCOMFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;ResidueCOMFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">SideChainTorsionsType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;SideChainTorsions&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>
<span class="n">MinRmsdFeatureType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;MinRmsdFeature&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Parent&quot;</span><span class="p">)</span>


<span class="n">AnyFeature</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">AllCartesiansType</span><span class="p">,</span>
    <span class="n">AllBondDistancesType</span><span class="p">,</span>
    <span class="n">CentralCartesiansType</span><span class="p">,</span>
    <span class="n">CentralBondDistancesType</span><span class="p">,</span>
    <span class="n">CentralAnglesType</span><span class="p">,</span>
    <span class="n">CentralDihedralsType</span><span class="p">,</span>
    <span class="n">SideChainCartesiansType</span><span class="p">,</span>
    <span class="n">SideChainBondDistancesType</span><span class="p">,</span>
    <span class="n">SideChainAnglesType</span><span class="p">,</span>
    <span class="n">SideChainDihedralsType</span><span class="p">,</span>
    <span class="n">CustomFeatureType</span><span class="p">,</span>
    <span class="n">SelectionFeatureType</span><span class="p">,</span>
    <span class="n">AngleFeatureType</span><span class="p">,</span>
    <span class="n">DihedralFeatureType</span><span class="p">,</span>
    <span class="n">DistanceFeatureType</span><span class="p">,</span>
    <span class="n">AlignFeatureType</span><span class="p">,</span>
    <span class="n">InverseDistanceFeatureType</span><span class="p">,</span>
    <span class="n">ContactFeatureType</span><span class="p">,</span>
    <span class="n">BackboneTorsionFeatureType</span><span class="p">,</span>
    <span class="n">ResidueMinDistanceFeatureType</span><span class="p">,</span>
    <span class="n">GroupCOMFeatureType</span><span class="p">,</span>
    <span class="n">ResidueCOMFeatureType</span><span class="p">,</span>
    <span class="n">SideChainTorsionsType</span><span class="p">,</span>
    <span class="n">MinRmsdFeatureType</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1">################################################################################</span>
<span class="c1"># Optional Imports</span>
<span class="c1">################################################################################</span>


<span class="n">md</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">)</span>
<span class="n">_dist_mic</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._dist_mic&quot;</span><span class="p">)</span>
<span class="n">_dist</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._dist&quot;</span><span class="p">)</span>
<span class="n">_dihedral_mic</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._dihedral_mic&quot;</span><span class="p">)</span>
<span class="n">_dihedral</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._dihedral&quot;</span><span class="p">)</span>
<span class="n">_angle_mic</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._angle_mic&quot;</span><span class="p">)</span>
<span class="n">_angle</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry._geometry._angle&quot;</span><span class="p">)</span>
<span class="n">box_vectors_to_lengths_and_angles</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span>
    <span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;utils.unitcell.box_vectors_to_lengths_and_angles&quot;</span>
<span class="p">)</span>
<span class="n">dask</span> <span class="o">=</span> <span class="n">_optional_import</span><span class="p">(</span><span class="s2">&quot;dask&quot;</span><span class="p">)</span>


<span class="c1">################################################################################</span>
<span class="c1"># Globals</span>
<span class="c1">################################################################################</span>

<span class="n">__all__</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;AllCartesians&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AllBondDistances&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CentralCartesians&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CentralBondDistances&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CentralAngles&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CentralDihedrals&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainCartesians&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainBondDistances&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainAngles&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainDihedrals&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CustomFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SelectionFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AngleFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DihedralFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AlignFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InverseDistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ContactFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BackboneTorsionFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResidueMinDistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GroupCOMFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResidueCOMFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainTorsions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MinRmsdFeature&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="n">PERIODIC_WARNING</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">PYEMMA_CITATION_WARNING</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">PYEMMA_FEATURES</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;SelectionFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AngleFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DihedralFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AlignFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;InverseDistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ContactFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BackboneTorsionFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResidueMinDistanceFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GroupCOMFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ResidueCOMFeature&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SideChainTorsions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MinRmsdFeature&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1">################################################################################</span>
<span class="c1"># Functions</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="pair">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.pair">[docs]</a>
<span class="k">def</span> <span class="nf">pair</span><span class="p">(</span><span class="o">*</span><span class="n">numbers</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ConvertGroup&#39;s (https://convertgroup.com/) implementation of</span>
<span class="sd">    Matthew Szudzik&#39;s pairing function (http://szudzik.com/ElegantPairing.pdf)</span>

<span class="sd">    Maps a pair of non-negative integers to a uniquely associated single non-negative integer.</span>
<span class="sd">    Pairing also generalizes for `n` non-negative integers, by recursively mapping the first pair.</span>
<span class="sd">    For example, to map the following tuple:</span>

<span class="sd">    Args:</span>
<span class="sd">        *numbers (int): Variable length integers.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The paired integer.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Szudzik pairing function needs at least 2 numbers as input&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">any</span><span class="p">((</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Szudzik pairing function maps only non-negative integers. In your &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;input, there seems to be negative or non-integer values: </span><span class="si">{</span><span class="n">numbers</span><span class="si">=}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">numbers</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>

    <span class="c1"># fetch the first two numbers</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">n1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">n1</span> <span class="o">+</span> <span class="n">n2</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numbers</span><span class="p">:</span>
        <span class="c1"># recursion concludes</span>
        <span class="k">return</span> <span class="n">mapping</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numbers</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pair</span><span class="p">(</span><span class="o">*</span><span class="n">numbers</span><span class="p">)</span></div>



<div class="viewcode-block" id="unpair">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.unpair">[docs]</a>
<span class="k">def</span> <span class="nf">unpair</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;ConvertGroup&#39;s (https://convertgroup.com/) implementation of</span>
<span class="sd">    Matthew Szudzik&#39;s pairing function (http://szudzik.com/ElegantPairing.pdf)</span>

<span class="sd">    The inverse function outputs the pair associated with a non-negative integer.</span>
<span class="sd">    Unpairing also generalizes by recursively unpairing a non-negative integer to</span>
<span class="sd">    `n` non-negative integers.</span>

<span class="sd">    For example, to associate a `number` with three non-negative</span>
<span class="sd">    integers n_1, n_2, n_3, such that:</span>

<span class="sd">    pairing(n_1, n_2, n_3) = `number`</span>

<span class="sd">    the `number` will first be unpaired to n_p, n_3, then the n_p will be unpaired to n_1, n_2,</span>
<span class="sd">    producing the desired n_1, n_2 and n_3.</span>

<span class="sd">    Args:</span>
<span class="sd">        number(int): The paired integer.</span>
<span class="sd">        n (int): How many integers are paired in `number`?</span>

<span class="sd">    Returns:</span>
<span class="sd">        list[int]: A list of length `n` with the constituting ints.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Szudzik unpairing function requires a non-negative integer&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">number</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">)):</span>

        <span class="n">n1</span> <span class="o">=</span> <span class="n">number</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">number</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>

    <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n1</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">unpair</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">n2</span><span class="p">,)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># recursion concludes</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span></div>



<div class="viewcode-block" id="_check_aas">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features._check_aas">[docs]</a>
<span class="k">def</span> <span class="nf">_check_aas</span><span class="p">(</span><span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residues</span><span class="p">])</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">amino_acid_codes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;I don&#39;t recognize these residues: </span><span class="si">{</span><span class="n">diff</span><span class="si">}</span><span class="s2">. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Either add them to the `SingleTraj` or `TrajEnsemble` via &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;`traj.load_custom_topology(custom_aas)` or &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;`trajs.load_custom_topology(custom_aas)` &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Or remove them from your trajectory. See the documentation of the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;`em.CustomTopology` class. Here are the recognized residues:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">amino_acid_codes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="describe_last_feats">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.describe_last_feats">[docs]</a>
<span class="k">def</span> <span class="nf">describe_last_feats</span><span class="p">(</span><span class="n">feat</span><span class="p">:</span> <span class="n">AnyFeature</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prints the description of the last `n` features.</span>

<span class="sd">    Args:</span>
<span class="sd">        feat (encodermap.Featurizer): An instance of a featurizer.</span>
<span class="sd">        n (int): The number of last features to describe. Default is 5.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feat</span><span class="o">.</span><span class="n">describe</span><span class="p">()[</span><span class="o">-</span><span class="n">n</span><span class="p">:]):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span></div>



<div class="viewcode-block" id="_describe_atom">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features._describe_atom">[docs]</a>
<span class="k">def</span> <span class="nf">_describe_atom</span><span class="p">(</span>
    <span class="n">topology</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a string describing the given atom.</span>

<span class="sd">    Args:</span>
<span class="sd">        topology (md.Topology): An MDTraj Topology.</span>
<span class="sd">        index (str): The index of the atom.</span>

<span class="sd">    Return:</span>
<span class="sd">        str: A description of the atom.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">atom</span> <span class="o">=</span> <span class="n">topology</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">n_chains</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span></div>



<span class="c1">################################################################################</span>
<span class="c1"># Parent Classes</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="CitePYEMMAWarning">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CitePYEMMAWarning">[docs]</a>
<span class="k">class</span> <span class="nc">CitePYEMMAWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>



<div class="viewcode-block" id="FeatureMeta">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.FeatureMeta">[docs]</a>
<span class="k">class</span> <span class="nc">FeatureMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Inspects the __init__ of classes and adds attributes to them based on</span>
<span class="sd">    their call signature.</span>

<span class="sd">    If a feature uses the arguments `deg` or `omega` in</span>
<span class="sd">    its call signature, the instance will have the CLASS attributes `_use_angle` and</span>
<span class="sd">    `_use_omega` set to True. Otherwise, the instance will have them set as False.</span>

<span class="sd">    This allows other functions that use these features to easily discern whether</span>
<span class="sd">    they need these arguments before instantiating the classes.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; from encodermap.loading import features</span>
<span class="sd">        &gt;&gt;&gt; f_class = getattr(features, &quot;SideChainDihedrals&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f_class._use_angle</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; f_class._use_omega</span>
<span class="sd">        False</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="fm">__init__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">varargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="fm">__init__</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">x</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">args</span>
        <span class="k">if</span> <span class="s2">&quot;deg&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_angle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_angle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;omega&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_omega</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_omega</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;periodic&quot;</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_periodic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="o">.</span><span class="n">_use_periodic</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">x</span><span class="o">.</span><span class="n">atom_feature</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">x</span><span class="o">.</span><span class="n">_raise_on_unitcell</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">x</span></div>



<div class="viewcode-block" id="Feature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.Feature">[docs]</a>
<span class="k">class</span> <span class="nc">Feature</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">FeatureMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parent class to all feature classes. Implements the FeatureMeta,</span>
<span class="sd">     the transform method, and checks for unknown amino acids..</span>

<span class="sd">    This class implements functionality, that holds true for all features.</span>
<span class="sd">    The `transform()` method can be used by subclasses in two ways:</span>
<span class="sd">        * Provide all args with None. In this case, the traj in `self.traj`</span>
<span class="sd">            will be used to calculate the transformation.</span>
<span class="sd">        * Provide custom `xyz`, `unitcell_vectors`, and `unitcell_info`. In this</span>
<span class="sd">            case,</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_on_unitcell</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The trajs in the features seem to have multiple toplogies: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top_files</span><span class="si">}</span><span class="s2">. Features can only work with single &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;topologies.&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span>
        <span class="k">if</span> <span class="n">check_aas</span><span class="p">:</span>
            <span class="n">_check_aas</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delayed</span> <span class="o">=</span> <span class="n">delayed</span>

        <span class="k">if</span> <span class="n">periodic</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">periodic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">periodic</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_raise_on_unitcell</span>
                <span class="k">global</span> <span class="n">PERIODIC_WARNING</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">PERIODIC_WARNING</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;You requested a `em.loading.features.Feature` to calculate &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;features in a periodic box, using the minimum image convention, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;but the trajectory you provided does not have &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;unitcell information. If this feature will later be supplied &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with trajectories with unitcell information, an Exception &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;will be raised, to make sure distances/angles are calculated &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;correctly.&quot;</span><span class="p">,</span>
                        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">PERIODIC_WARNING</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">global</span> <span class="n">PYEMMA_CITATION_WARNING</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PYEMMA_CITATION_WARNING</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">PYEMMA_FEATURES</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="n">message</span><span class="o">=</span><span class="p">(</span>
                    <span class="s2">&quot;EncoderMap&#39;s featurization uses code from the now deprecated &quot;</span>
                    <span class="s2">&quot;python package PyEMMA (https://github.com/markovmodel/PyEMMA). &quot;</span>
                    <span class="s2">&quot;Please make sure to also cite them, when using EncoderMap.&quot;</span>
                <span class="p">),</span>
                <span class="n">category</span><span class="o">=</span><span class="n">CitePYEMMAWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">PYEMMA_CITATION_WARNING</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int: The dimension of the feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span>

    <span class="nd">@dimension</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">AnyFeature</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">Feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dimension</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ref&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">ref</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;scheme&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">scheme</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ignore_nonprotein&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_nonprotein</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">ignore_nonprotein</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;periodic&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">threshold</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;group_definitions&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">self_group_def</span><span class="p">,</span> <span class="n">other_group_def</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">group_definitions</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">self_group_def</span><span class="p">,</span> <span class="n">other_group_def</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;group_pairs&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_pairs</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">group_pairs</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;count_contacts&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_contacts</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">count_contacts</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Encodermap imports</span>
        <span class="kn">from</span> <span class="nn">encodermap.misc.xarray</span> <span class="kn">import</span> <span class="n">_get_indexes_from_feat</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">self_index</span> <span class="o">=</span> <span class="n">_get_indexes_from_feat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">)</span>
            <span class="n">other_index</span> <span class="o">=</span> <span class="n">_get_indexes_from_feat</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">traj</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">self_index</span><span class="p">,</span> <span class="n">other_index</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="Feature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.Feature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Carries out the computation of the CVs.</span>

<span class="sd">        For featurization of single trajs, all arguments can be left None,</span>
<span class="sd">        and the values of the `traj` at class instantiation will be</span>
<span class="sd">        returned by this method. For ensembles with a single topology, but</span>
<span class="sd">        multiple trajectories, the xyz, unitcell_vectors, and unitcell_info</span>
<span class="sd">        should be provided accordingly. This parent class&#39; `transform` then</span>
<span class="sd">        carries out checks (do all arguments provide the same number of frames,</span>
<span class="sd">        does the xyz array have the same number of atoms as the `traj` at</span>
<span class="sd">        instantiation, do the unitcell_angles coincide with the one of the</span>
<span class="sd">        parent traj, ...). Thus, it is generally advised to call this method</span>
<span class="sd">        with super() to run these checks.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): If None, the coordinates of the</span>
<span class="sd">                trajectory in provided as `traj`, when the feature was instantiated</span>
<span class="sd">                will be used.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): If None, the unitcell vectors</span>
<span class="sd">                of the trajectory in provided as `traj`, when the feature was instantiated</span>
<span class="sd">                will be used. Unitcell_vectors are arrays with shape (n_frames, 3, 3),</span>
<span class="sd">                where the rows are the bravais vectors a, b, c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): If None, the unitcell info of</span>
<span class="sd">                the trajectory in provided as `traj`, when the feature was</span>
<span class="sd">                instantiated will be used. The unitcell_info is an array with</span>
<span class="sd">                shape (n_frames, 6), where the first three columns are the unitcell</span>
<span class="sd">                lengths in nm, the remaining columns are the unitcell angles in deg.</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple: A tuple containing three np.ndarrays:</span>
<span class="sd">                - The xyz coordinates.</span>
<span class="sd">                - The unitcell_vectors</span>
<span class="sd">                - The unitcell_info</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raise_on_unitcell</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;This feature was instantiated with the keyword argument `periodic=True`, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but the `SingleTraj` used for instantiation did not contain any unitcell &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;information. Now, unitcell_infos are fed into the `transform` &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;method of this feature. This behavior is not allowed. Make sure to &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;either specifically set `periodic=False` or fix the unitcells in &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;your trajectory files.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_atoms</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">self_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;periodic&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;When providing a `feature.transform` function with xyz &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;data, and setting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="si">=}</span><span class="s2"> to True, please &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;also provide `unitcell_vectors` and `unitcell_info` &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to calculate distances/angles/dihedrals in periodic space.&quot;</span>
                    <span class="p">)</span>
            <span class="k">assert</span> <span class="n">input_atoms</span> <span class="o">==</span> <span class="n">self_atoms</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the input xyz coordinates is off from the expected &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;shape. The topology </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="si">}</span><span class="s2"> defines </span><span class="si">{</span><span class="n">self_atoms</span><span class="si">}</span><span class="s2"> atoms. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;provided array has </span><span class="si">{</span><span class="n">xyz</span><span class="o">.</span><span class="n">shaope</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">=}</span><span class="s2"> atoms.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unitcell_vectors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the provided `unitcell_vectors` is off from the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;expected shape. The xyz data contains </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span><span class="si">=}</span><span class="s2"> frames, while &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;the `unitcell_vectors` contains </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unitcell_vectors</span><span class="p">)</span><span class="si">=}</span><span class="s2"> frames.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span><span class="p">:</span>
                <span class="n">unitcell_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_vectors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unitcell_info</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">),</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the provided `unitcell_info` is off from the &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;expected shape. The xyz data contains </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span><span class="si">=}</span><span class="s2"> frames, while &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;the `unitcell_info` contains </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">unitcell_info</span><span class="p">)</span><span class="si">=}</span><span class="s2"> frames.&quot;</span>
            <span class="p">)</span>
            <span class="n">provided_orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span> <span class="mi">90</span><span class="p">)</span>
            <span class="n">self_orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">provided_orthogonal</span> <span class="o">==</span> <span class="n">self_orthogonal</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The trajectory you provided to `transform` and the one &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;this feature was instantiated with have different crystal &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;systems in their unitcells: </span><span class="si">{</span><span class="n">provided_orthogonal</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">self_orthogonal</span><span class="si">=}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span><span class="p">:</span>
                <span class="n">unitcell_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_lengths</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_angles</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span></div>
</div>



<div class="viewcode-block" id="CustomFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CustomFeature">[docs]</a>
<span class="k">class</span> <span class="nc">CustomFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_nonstandard_transform_args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;top&quot;</span><span class="p">,</span>
        <span class="s2">&quot;indexes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;delayed_call&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_fun&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_args&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_kwargs&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">_is_custom</span><span class="p">:</span> <span class="n">Final</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">traj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">top</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">indexes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_fun</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fun</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">description</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fun_args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">fun_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">fun_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fun_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fun</span> <span class="o">=</span> <span class="n">fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_args</span> <span class="o">=</span> <span class="n">fun_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">fun_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayed</span> <span class="o">=</span> <span class="n">delayed</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Feature dimensions need to be greater than 0.&quot;</span>

<div class="viewcode-block" id="CustomFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CustomFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">arg_str</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CustomFeature_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> calling </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_fun</span><span class="si">}</span><span class="s2"> with args </span><span class="si">{</span><span class="n">arg_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;to avoid confusion, ensure the lengths of &#39;description&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;list matches dimension - or give a single element which will be repeated.&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Input was </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">desc</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">desc</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>

        <span class="k">return</span> <span class="n">desc</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">delayed_call</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_fun</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The CustomFeature dask transfrom is still under development.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
                <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                <span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
                <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
                <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
                <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                <span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">delayed_call</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">delayed_call</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">_fun</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="CustomFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CustomFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
                    <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                    <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                    <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
                    <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
                    <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
                    <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;call&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
                    <span class="n">xyz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                    <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
                    <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_lengths</span><span class="p">),</span>
                    <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">unitcell_angles</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
        <span class="n">feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fun</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Your function should return a NumPy array!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">feature</span></div>
</div>



<div class="viewcode-block" id="SelectionFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SelectionFeature">[docs]</a>
<span class="k">class</span> <span class="nc">SelectionFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ATOM:&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Empty indices in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span>

<div class="viewcode-block" id="SelectionFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SelectionFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> x&quot;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> y&quot;</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> z&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">indexes</span><span class="p">,</span> <span class="p">:],</span> <span class="n">newshape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="SelectionFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SelectionFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span> <span class="p">:],</span> <span class="n">newshape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>
</div>



<div class="viewcode-block" id="AngleFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AngleFeature">[docs]</a>
<span class="k">class</span> <span class="nc">AngleFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">angle_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the `AngleFeature` class.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (Union[SingleTraj, TrajEnsemble]): The trajectory container</span>
<span class="sd">                which topological information will be used to build the angles.</span>
<span class="sd">            angle_indexes (np.ndarray): A numpy array with shape (n_dihedrals, 4),</span>
<span class="sd">                that indexes the 3-tuples of atoms that will be used for</span>
<span class="sd">                the angle calculation.</span>
<span class="sd">            deg (bool): Whether to return the dihedrals in degree (True) or</span>
<span class="sd">                in radian (False). Defaults to False.</span>
<span class="sd">            cossin (bool): Whether to return the angles (False) or tuples of their</span>
<span class="sd">                cos and sin values (True). Defaults to False.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            check_aas (bool): Whether to check if all aas in `traj.top` are</span>
<span class="sd">                recognized. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">angle_indexes</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;empty indices&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deg</span> <span class="o">=</span> <span class="n">deg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span> <span class="o">=</span> <span class="n">cossin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cossin</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">check_aas</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">)</span>

<div class="viewcode-block" id="AngleFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AngleFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;ANGLE: COS(</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;ANGLE: SIN(</span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">s</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sin_cos</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;ANGLE: </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> &quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">triple</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;angle_indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            deg (bool): Whether to return the result in degree (`deg=True`) or in</span>
<span class="sd">                radians (`deg=False`). Defaults to False (radians).</span>
<span class="sd">            cossin (bool): If True, each angle will be returned as a pair of</span>
<span class="sd">                (sin(x), cos(x)). This is useful, if you calculate the means</span>
<span class="sd">                (e.g. TICA/PCA, clustering) in that space. Defaults to False.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">_angle_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">indexes</span><span class="p">,</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">_angle</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">deg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="AngleFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AngleFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
            <span class="p">)</span>
            <span class="n">_angle_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">,</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
            <span class="p">)</span>
            <span class="n">_angle</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="DihedralFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DihedralFeature">[docs]</a>
<span class="k">class</span> <span class="nc">DihedralFeature</span><span class="p">(</span><span class="n">AngleFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dihedrals are torsion angles defined by four atoms.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">dih_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the `DihedralFeature` class.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (Union[SingleTraj, TrajEnsemble]): The trajectory container</span>
<span class="sd">                which topological information will be used to build the dihedrals.</span>
<span class="sd">            dih_indexes (np.ndarray): A numpy array with shape (n_dihedrals, 4),</span>
<span class="sd">                that indexes the 4-tuples of atoms that will be used for</span>
<span class="sd">                the dihedral calculation.</span>
<span class="sd">            deg (bool): Whether to return the dihedrals in degree (True) or</span>
<span class="sd">                in radian (False). Defaults to False.</span>
<span class="sd">            cossin (bool): Whether to return the angles (False) or tuples of their</span>
<span class="sd">                cos and sin values (True). Defaults to False.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            check_aas (bool): Whether to check if all aas in `traj.top` are</span>
<span class="sd">                recognized. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">angle_indexes</span><span class="o">=</span><span class="n">dih_indexes</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">cossin</span><span class="o">=</span><span class="n">cossin</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="DihedralFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DihedralFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. The length</span>
<span class="sd">                is determined by the `dih_indexes` and the `cossin` argument</span>
<span class="sd">                in the `__init__()` method. If `cossin` is false, then</span>
<span class="sd">                `len(describe()) == self.angle_indexes[-1]`, else `len(describe())`</span>
<span class="sd">                is twice as long.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;DIH: COS(</span><span class="si">%s</span><span class="s2"> -  </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;DIH: SIN(</span><span class="si">%s</span><span class="s2"> -  </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">s</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">quad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sin_cos</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;DIH: </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> - </span><span class="si">%s</span><span class="s2"> &quot;</span>
                <span class="o">%</span> <span class="p">(</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span>
                    <span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">quad</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">quad</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            deg (bool): Whether to return the result in degree (`deg=True`) or in</span>
<span class="sd">                radians (`deg=False`). Defaults to False (radians).</span>
<span class="sd">            cossin (bool): If True, each angle will be returned as a pair of</span>
<span class="sd">                (sin(x), cos(x)). This is useful, if you calculate the means</span>
<span class="sd">                (e.g. TICA/PCA, clustering) in that space. Defaults to False.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># convert to angles</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>

            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">_dihedral_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">indexes</span><span class="p">,</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">_dihedral</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">indexes</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="DihedralFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DihedralFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span> <span class="o">=</span> <span class="n">Feature</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># convert to angles</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>

            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
            <span class="p">)</span>
            <span class="n">_dihedral_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">,</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span>
            <span class="p">)</span>
            <span class="n">_dihedral</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="DistanceFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DistanceFeature">[docs]</a>
<span class="k">class</span> <span class="nc">DistanceFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;DIST:&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">distance_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">check_aas</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distance_indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;empty indices&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">distance_indexes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dim</span> <span class="o">=</span> <span class="n">dim</span>

<div class="viewcode-block" id="DistanceFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DistanceFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_describe_atom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;distance_indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>

            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="DistanceFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.DistanceFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xyz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_have_unitcell</span>
        <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="c1"># check for an orthogonal box</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)),</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)),</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<div class="viewcode-block" id="AlignFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AlignFeature">[docs]</a>
<span class="k">class</span> <span class="nc">AlignFeature</span><span class="p">(</span><span class="n">SelectionFeature</span><span class="p">):</span>
    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;aligned ATOM:&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">reference</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">,</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">atom_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ref_atom_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlignFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span> <span class="o">=</span> <span class="n">atom_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_atom_indices</span> <span class="o">=</span> <span class="n">ref_atom_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_place</span> <span class="o">=</span> <span class="n">in_place</span>

<div class="viewcode-block" id="AlignFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AlignFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the aligned xyz coordinates.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_place</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">traj</span>
        <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span>
        <span class="n">aligned</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span>
            <span class="n">reference</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span>
            <span class="n">atom_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">,</span>
            <span class="n">ref_atom_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_atom_indices</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># apply selection</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AlignFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">aligned</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span></div>
</div>



<div class="viewcode-block" id="InverseDistanceFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.InverseDistanceFeature">[docs]</a>
<span class="k">class</span> <span class="nc">InverseDistanceFeature</span><span class="p">(</span><span class="n">DistanceFeature</span><span class="p">):</span>
    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;INVDIST:&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">distance_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">DistanceFeature</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">traj</span><span class="p">,</span> <span class="n">distance_indexes</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;distance_indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">out</span>

<div class="viewcode-block" id="InverseDistanceFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.InverseDistanceFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ContactFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ContactFeature">[docs]</a>
<span class="k">class</span> <span class="nc">ContactFeature</span><span class="p">(</span><span class="n">DistanceFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Defines certain distances as contacts and returns a binary (0, 1) result.</span>

<span class="sd">    Instead of returning the binary result can also count contacts with the</span>
<span class="sd">    argument `count_contacts=True` provided at instantiation. In that case,</span>
<span class="sd">    every frame returns an integer number.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CONTACT:&quot;</span>
    <span class="n">_nonstandard_transform_args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="s2">&quot;count_contacts&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">distance_indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">count_contacts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the contact feature.</span>

<span class="sd">        A regular contact feature yields a np.ndarray with zeros and ones.</span>
<span class="sd">        The zeros are no contact. The ones are contact.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (SingleTraj): An instance of `SingleTraj`.</span>
<span class="sd">            distance_indexes (np.ndarray): An np.ndarray with shape (n_dists, 2),</span>
<span class="sd">                where distance_indexes[:, 0] indexes the first atoms of the distance</span>
<span class="sd">                measurement, and distance_indexes[:, 1] indexes the second atoms of the</span>
<span class="sd">                distance measurement.</span>
<span class="sd">            threshold (float): The threshold in nm, under which a distance is</span>
<span class="sd">                considered to be a contact. Defaults to 5.0 nm.</span>
<span class="sd">            periodic (bool): Whether to use the minimum image convention when</span>
<span class="sd">                calculating distances. Defaults to True.</span>
<span class="sd">            count_contacts (bool): When True, return an integer of the number of</span>
<span class="sd">                contacts instead of returning the array of regular contacts.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ContactFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="p">,</span> <span class="n">distance_indexes</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">count_contacts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;counted &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_contacts</span> <span class="o">=</span> <span class="n">count_contacts</span>
        <span class="k">if</span> <span class="n">count_contacts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;distance_indexes&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">count_contacts</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): A numpy array with shape (n, ) giving the</span>
<span class="sd">                0-based index of the atoms which positions should be returned.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            threshold (float): The threshold in nm, under which a distance is</span>
<span class="sd">                considered to be a contact. Defaults to 5.0 nm.</span>
<span class="sd">            count_contacts (bool): When True, return an integer of the number of contacts</span>
<span class="sd">                instead of returning the array of regular contacts.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">unitcell_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># convert to angles</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">fr_unitcell_vectors</span> <span class="ow">in</span> <span class="n">unitcell_vectors</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="n">box_vectors_to_lengths_and_angles</span><span class="p">(</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">fr_unitcell_vectors</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="p">)</span>
                    <span class="n">unitcell_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">gamma</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">unitcell_angles</span> <span class="o">=</span> <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span>
            <span class="c1"># check for an orthogonal box</span>
            <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">unitcell_angles</span><span class="p">,</span> <span class="mi">90</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist_mic</span><span class="p">(</span>
                <span class="n">xyz</span><span class="p">,</span>
                <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span>
                <span class="n">unitcell_vectors</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">out</span><span class="p">,</span>
                <span class="n">orthogonal</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">_dist</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span>  <span class="c1"># noqa: E741</span>
        <span class="n">res</span><span class="p">[</span><span class="n">I</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">count_contacts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="ContactFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ContactFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ContactFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span>
        <span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>  <span class="c1"># noqa: E741</span>
        <span class="n">res</span><span class="p">[</span><span class="n">I</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_contacts</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="BackboneTorsionFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.BackboneTorsionFeature">[docs]</a>
<span class="k">class</span> <span class="nc">BackboneTorsionFeature</span><span class="p">(</span><span class="n">DihedralFeature</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">selstr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">indices_phi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selstr</span> <span class="o">=</span> <span class="n">selstr</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">),</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">indices_psi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">),</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="c1"># alternate phi, psi pairs (phi_1, psi_1, ..., phi_n, psi_n)</span>
        <span class="n">dih_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">phi_psi</span> <span class="k">for</span> <span class="n">phi_psi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">BackboneTorsionFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">dih_indexes</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">cossin</span><span class="o">=</span><span class="n">cossin</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="BackboneTorsionFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.BackboneTorsionFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. The length</span>
<span class="sd">                is determined by the `dih_indexes` and the `cossin` argument</span>
<span class="sd">                in the `__init__()` method. If `cossin` is false, then</span>
<span class="sd">                `len(describe()) == self.angle_indexes[-1]`, else `len(describe())`</span>
<span class="sd">                is twice as long.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span>
            <span class="p">]</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span>
            <span class="p">]</span>
            <span class="c1"># produce the same ordering as the given indices (phi_1, psi_1, ..., phi_n, psi_n)</span>
            <span class="c1"># or (cos(phi_1), sin(phi_1), cos(psi_1), sin(psi_1), ..., cos(phi_n), sin(phi_n), cos(psi_n), sin(psi_n))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span>
                    <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels_phi</span><span class="p">,</span> <span class="n">labels_psi</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;PHI </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span>
            <span class="p">]</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;PSI </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span>
            <span class="p">]</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">labels_phi</span><span class="p">,</span> <span class="n">labels_psi</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="ResidueMinDistanceFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ResidueMinDistanceFeature">[docs]</a>
<span class="k">class</span> <span class="nc">ResidueMinDistanceFeature</span><span class="p">(</span><span class="n">DistanceFeature</span><span class="p">):</span>
    <span class="n">_nonstandard_transform_args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;threshold&quot;</span><span class="p">,</span>
        <span class="s2">&quot;count_contacts&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scheme&quot;</span><span class="p">,</span>
        <span class="s2">&quot;top&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">contacts</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">scheme</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ca&quot;</span><span class="p">,</span> <span class="s2">&quot;closest&quot;</span><span class="p">,</span> <span class="s2">&quot;closest-heavy&quot;</span><span class="p">],</span>
        <span class="n">ignore_nonprotein</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">count_contacts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">count_contacts</span> <span class="ow">and</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot count contacts when no contact threshold is supplied.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contacts</span> <span class="o">=</span> <span class="n">contacts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="n">scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RES_DIST (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_nonprotein</span> <span class="o">=</span> <span class="n">ignore_nonprotein</span>

        <span class="k">if</span> <span class="n">count_contacts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;counted &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_contacts</span> <span class="o">=</span> <span class="n">count_contacts</span>

        <span class="n">dummy_traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
        <span class="n">dummy_dist</span><span class="p">,</span> <span class="n">dummy_pairs</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">compute_contacts</span><span class="p">(</span>
            <span class="n">dummy_traj</span><span class="p">,</span>
            <span class="n">contacts</span><span class="o">=</span><span class="n">contacts</span><span class="p">,</span>
            <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">ignore_nonprotein</span><span class="o">=</span><span class="n">ignore_nonprotein</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">count_contacts</span> <span class="k">else</span> <span class="n">dummy_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResidueMinDistanceFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">distance_indexes</span><span class="o">=</span><span class="n">dummy_pairs</span><span class="p">,</span>
            <span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="ResidueMinDistanceFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ResidueMinDistanceFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residue</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residue</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;contacts&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
        <span class="n">scheme</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;ca&quot;</span><span class="p">,</span> <span class="s2">&quot;closest&quot;</span><span class="p">,</span> <span class="s2">&quot;closest-heavy&quot;</span><span class="p">],</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">count_contacts</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): For this special feature, the indexes argument</span>
<span class="sd">                in the @staticmethod dask_transform is `self.contacts`.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            threshold (float): The threshold in nm, under which a distance is</span>
<span class="sd">                considered to be a contact. Defaults to 5.0 nm.</span>
<span class="sd">            count_contacts (bool): When True, return an integer of the number of contacts</span>
<span class="sd">                instead of returning the array of regular contacts.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
        <span class="p">)</span>

        <span class="c1"># We let mdtraj compute the contacts with the input scheme</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">compute_contacts</span><span class="p">(</span>
            <span class="n">traj</span><span class="p">,</span>
            <span class="n">contacts</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span>
            <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># Do we want binary?</span>
        <span class="k">if</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">D</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">I</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">D</span>

        <span class="k">if</span> <span class="n">count_contacts</span> <span class="ow">and</span> <span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="ResidueMinDistanceFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ResidueMinDistanceFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span>
            <span class="n">unitcell_vectors</span><span class="p">,</span>
            <span class="n">unitcell_info</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">Feature</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span><span class="p">)</span>

        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
        <span class="p">)</span>

        <span class="c1"># We let mdtraj compute the contacts with the input scheme</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">compute_contacts</span><span class="p">(</span>
            <span class="n">traj</span><span class="p">,</span>
            <span class="n">contacts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">contacts</span><span class="p">,</span>
            <span class="n">scheme</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="c1"># Do we want binary?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">D</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span>
            <span class="n">res</span><span class="p">[</span><span class="n">I</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">I</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">D</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_contacts</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="GroupCOMFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.GroupCOMFeature">[docs]</a>
<span class="k">class</span> <span class="nc">GroupCOMFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cartesian coordinates of the center-of-mass (COM) of atom groups.</span>

<span class="sd">    Groups can be defined as sequences of sequences of int. So a list of list of int</span>
<span class="sd">    can be used to define groups of various sizes. The resulting array will have</span>
<span class="sd">    the shape of (n_frames, n_groups ** 2). The xyz coordinates are flattended,</span>
<span class="sd">    so the array can be rebuilt with `np.dstack()`</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; traj = em.SingleTraj.from_pdb_id(&quot;1YUG&quot;)</span>
<span class="sd">        &gt;&gt;&gt; f = em.features.GroupCOMFeature(</span>
<span class="sd">        ...     traj=traj,</span>
<span class="sd">        ...     group_definitions=[</span>
<span class="sd">        ...         [0, 1, 2],</span>
<span class="sd">        ...         [3, 4, 5, 6, 7],</span>
<span class="sd">        ...         [8, 9, 10],</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; a = f.transform()</span>
<span class="sd">        &gt;&gt;&gt; a.shape  # this array is flattened along the feature axis</span>
<span class="sd">        (15, 9)</span>
<span class="sd">        &gt;&gt;&gt; a = np.dstack([</span>
<span class="sd">        ...     a[..., ::3],</span>
<span class="sd">        ...     a[..., 1::3],</span>
<span class="sd">        ...     a[..., 2::3],</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; a.shape  # now the z, coordinate of the 2nd center of mass is a[:, 1, -1]</span>
<span class="sd">        (15, 3, 3)</span>

<span class="sd">    Note:</span>
<span class="sd">        Centering (`ref_geom`) and imaging (`image_molecules=True`) can be time-</span>
<span class="sd">        consuming. Consider doing this to your trajectory files prior to featurization.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_nonstandard_transform_args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;top&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ref_geom&quot;</span><span class="p">,</span>
        <span class="s2">&quot;image_molecules&quot;</span><span class="p">,</span>
        <span class="s2">&quot;masses_in_groups&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">group_definitions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">ref_geom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">image_molecules</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mass_weighted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the GroupCOMFeature.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (SingleTraj): An instance of `SingleTraj`.</span>
<span class="sd">            group_definitions (Sequence[Sequence[int]]): A sequence of sequences</span>
<span class="sd">                of int defining the groups of which the COM should be calculated.</span>
<span class="sd">                See the example for how to use this argument.</span>
<span class="sd">            ref_geom (Optional[md.Trajectory]): The coordinates can be centered</span>
<span class="sd">                to a reference geometry before computing the COM. Defaults to None.</span>
<span class="sd">            image_molecules (bool): The method traj.image_molecules will be</span>
<span class="sd">                called before computing averages. The method tries to correct</span>
<span class="sd">                for molecules broken across periodic boundary conditions,</span>
<span class="sd">                but can be time-consuming. See</span>
<span class="sd">                http://mdtraj.org/latest/api/generated/mdtraj.Trajectory.html#mdtraj.Trajectory.image_molecules</span>
<span class="sd">                for more details</span>
<span class="sd">            mass_weighted (bool): Whether the COM should be calculated mass-weighted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_on_unitcell</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ref_geom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref_geom</span><span class="p">,</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;argument ref_geom has to be either None or and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;mdtraj.Trajectory, got instead </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ref_geom</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_geom</span> <span class="o">=</span> <span class="n">ref_geom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">image_molecules</span> <span class="o">=</span> <span class="n">image_molecules</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gf</span><span class="p">)</span> <span class="k">for</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">group_definitions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">aa</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">mass</span> <span class="k">for</span> <span class="n">aa</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">mass_weighted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masses_in_groups</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">atom_masses</span><span class="p">[</span><span class="n">aa_in_rr</span><span class="p">]</span> <span class="k">for</span> <span class="n">aa_in_rr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">masses_in_groups</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">aa_in_rr</span><span class="p">)</span> <span class="k">for</span> <span class="n">aa_in_rr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">delayed</span> <span class="o">=</span> <span class="n">delayed</span>

        <span class="c1"># Prepare and store the description</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_describe</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coor</span> <span class="ow">in</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_describe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;COM-</span><span class="si">{</span><span class="n">coor</span><span class="si">}</span><span class="s2"> of atom group [</span><span class="si">{</span><span class="n">group</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="s2">..</span><span class="si">{</span><span class="n">group</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span><span class="si">}</span><span class="s2">]&quot;</span>
                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;group_definitions&quot;</span>

<div class="viewcode-block" id="GroupCOMFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.GroupCOMFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_describe</span></div>


    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
        <span class="n">ref_geom</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span>
        <span class="n">image_molecules</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">masses_in_groups</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The same as `transform()` but without the need to pickle `traj`.</span>

<span class="sd">        When dask delayed concurrencies are distributed, required python objects</span>
<span class="sd">        are pickled. Thus, every feature needs to have its own pickled traj.</span>
<span class="sd">        That defeats the purpose of dask distributed. Thus, this method implements</span>
<span class="sd">        the same calculations as `transform` as a more barebones approach.</span>
<span class="sd">        It foregoes the checks for periodicity and unit-cell shape and just</span>
<span class="sd">        takes xyz, unitcell vectors, and unitcell info. Furthermore, it is a</span>
<span class="sd">        staticmethod, so it doesn&#39;t require `self` to function. However, it</span>
<span class="sd">        needs the indexes in `self.indexes`. That&#39;s why the `dask_indices`</span>
<span class="sd">        property informs the scheduler to also pickle and pass this object to</span>
<span class="sd">        the workers.</span>

<span class="sd">        Args:</span>
<span class="sd">            indexes (np.ndarray): For this special feature, the indexes argument</span>
<span class="sd">                in the @staticmethod dask_transform is `self.group_definitions`.</span>
<span class="sd">            periodic (bool): Whether to observe the minimum image convention</span>
<span class="sd">                and respect proteins breaking over the periodic boundary</span>
<span class="sd">                condition as a whole (True). In this case, the trajectory container</span>
<span class="sd">                in `traj` needs to have unitcell information. Defaults to True.</span>
<span class="sd">            threshold (float): The threshold in nm, under which a distance is</span>
<span class="sd">                considered to be a contact. Defaults to 5.0 nm.</span>
<span class="sd">            count_contacts (bool): When True, return an integer of the number of contacts</span>
<span class="sd">                instead of returning the array of regular contacts.</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
        <span class="p">)</span>
        <span class="n">COM_xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">ref_geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span><span class="n">ref_geom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">image_molecules</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">image_molecules</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">aas</span><span class="p">,</span> <span class="n">mms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">masses_in_groups</span><span class="p">):</span>
            <span class="n">COM_xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span>
                        <span class="p">:,</span>
                        <span class="n">aas</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">mms</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">COM_xyz</span><span class="p">)</span>

<div class="viewcode-block" id="GroupCOMFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.GroupCOMFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span>
            <span class="n">unitcell_vectors</span><span class="p">,</span>
            <span class="n">unitcell_info</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">Feature</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span><span class="p">)</span>
        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="p">(</span>
                <span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">),</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:]</span> <span class="k">if</span> <span class="n">unitcell_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">COM_xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_geom</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">superpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_geom</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_molecules</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">image_molecules</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">aas</span><span class="p">,</span> <span class="n">mms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_definitions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">masses_in_groups</span><span class="p">):</span>
            <span class="n">COM_xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span>
                    <span class="n">traj</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span>
                        <span class="p">:,</span>
                        <span class="n">aas</span><span class="p">,</span>
                    <span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">weights</span><span class="o">=</span><span class="n">mms</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">COM_xyz</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ResidueCOMFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.ResidueCOMFeature">[docs]</a>
<span class="k">class</span> <span class="nc">ResidueCOMFeature</span><span class="p">(</span><span class="n">GroupCOMFeature</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">residue_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">residue_atoms</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">scheme</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;backbone&quot;</span><span class="p">,</span> <span class="s2">&quot;sidechain&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">ref_geom</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">image_molecules</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mass_weighted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the ResidueCOMFeature.</span>

<span class="sd">        Args:</span>
<span class="sd">            residue_indices (Sequence[int]): The residue indices for which the</span>
<span class="sd">                COM will be computed. These are always zero-indexed that are not</span>
<span class="sd">                necessarily the residue sequence record of the topology (resSeq).</span>
<span class="sd">                resSeq indices start at least at 1 but can depend on the topology.</span>
<span class="sd">                Furthermore, resSeq numbers can be duplicated across chains; residue</span>
<span class="sd">                indices are always unique.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResidueCOMFeature</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="p">,</span>
            <span class="n">residue_atoms</span><span class="p">,</span>
            <span class="n">mass_weighted</span><span class="o">=</span><span class="n">mass_weighted</span><span class="p">,</span>
            <span class="n">ref_geom</span><span class="o">=</span><span class="n">ref_geom</span><span class="p">,</span>
            <span class="n">image_molecules</span><span class="o">=</span><span class="n">image_molecules</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">residue_indices</span> <span class="o">=</span> <span class="n">residue_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scheme</span> <span class="o">=</span> <span class="n">scheme</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_describe</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ri</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">residue_indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">coor</span> <span class="ow">in</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_describe</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residue</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="si">}</span><span class="s2"> COM-</span><span class="si">{</span><span class="n">coor</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">scheme</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span></div>



<div class="viewcode-block" id="SideChainTorsions">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainTorsions">[docs]</a>
<span class="k">class</span> <span class="nc">SideChainTorsions</span><span class="p">(</span><span class="n">DihedralFeature</span><span class="p">):</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;chi1&quot;</span><span class="p">,</span> <span class="s2">&quot;chi2&quot;</span><span class="p">,</span> <span class="s2">&quot;chi3&quot;</span><span class="p">,</span> <span class="s2">&quot;chi4&quot;</span><span class="p">,</span> <span class="s2">&quot;chi5&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">selstr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">which</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;chi1&quot;</span><span class="p">,</span> <span class="s2">&quot;chi2&quot;</span><span class="p">,</span> <span class="s2">&quot;chi3&quot;</span><span class="p">,</span> <span class="s2">&quot;chi4&quot;</span><span class="p">,</span> <span class="s2">&quot;chi5&quot;</span><span class="p">]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">which</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">which</span> <span class="o">=</span> <span class="p">[</span><span class="n">which</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">which</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;all&quot;</span><span class="p">}):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Argument &quot;which&quot; should only contain one of </span><span class="si">{}</span><span class="s1">, but was </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">),</span> <span class="n">which</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;all&quot;</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
            <span class="n">which</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>

        <span class="c1"># get all dihedral index pairs</span>
        <span class="n">indices_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;indices_</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">)</span>
            <span class="n">truncated_indices_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">indices_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">inds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">selection</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">truncated_indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">indices_dict</span> <span class="o">=</span> <span class="n">truncated_indices_dict</span>

        <span class="n">valid</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indices_dict</span> <span class="k">if</span> <span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not determine any side chain dihedrals for your topology!&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_label_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">valid</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SideChainTorsions</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">dih_indexes</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">cossin</span><span class="o">=</span><span class="n">cossin</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="SideChainTorsions.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainTorsions.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. The length</span>
<span class="sd">                is determined by the `dih_indexes` and the `cossin` argument</span>
<span class="sd">                in the `__init__()` method. If `cossin` is false, then</span>
<span class="sd">                `len(describe()) == self.angle_indexes[-1]`, else `len(describe())`</span>
<span class="sd">                is twice as long.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix_label_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
                <span class="n">lengths</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">*</span> <span class="n">lengths</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">cossin</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">labels</span></div>
</div>



<div class="viewcode-block" id="MinRmsdFeature">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.MinRmsdFeature">[docs]</a>
<span class="k">class</span> <span class="nc">MinRmsdFeature</span><span class="p">(</span><span class="n">Feature</span><span class="p">):</span>
    <span class="n">_nonstandard_transform_args</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;top&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">ref</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">],</span>
        <span class="n">ref_frame</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">atom_indices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">precentered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Encodermap imports</span>
        <span class="kn">from</span> <span class="nn">encodermap.trajinfo.info_single</span> <span class="kn">import</span> <span class="n">SingleTraj</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_raise_on_unitcell</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">ref_frame</span><span class="p">,</span> <span class="nb">int</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;ref_frame has to be of type integer, and not </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ref_frame</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="p">(</span><span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">,</span> <span class="n">SingleTraj</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;MinRmsdFeature_with_</span><span class="si">{</span><span class="n">ref</span><span class="o">.</span><span class="n">n_atoms</span><span class="si">}</span><span class="s2">_atoms_in_reference&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;input reference has to be either `encodermap.SingleTraj` or &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;a mdtraj.Trajectory object, and not of </span><span class="si">{</span><span class="n">ref</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span> <span class="o">=</span> <span class="n">ref_frame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span> <span class="o">=</span> <span class="n">atom_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precentered</span> <span class="o">=</span> <span class="n">precentered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delayed</span> <span class="o">=</span> <span class="n">delayed</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;atom_indices&quot;</span>

<div class="viewcode-block" id="MinRmsdFeature.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.MinRmsdFeature.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;minrmsd to frame </span><span class="si">%u</span><span class="s2"> of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_frame</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precentered</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot;, precentered=True&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">+=</span> <span class="s2">&quot;, subset of atoms  &quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dask_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the delayed transformation to carry out with this feature.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;atom_indices&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="nd">@dask</span><span class="o">.</span><span class="n">delayed</span>
    <span class="k">def</span> <span class="nf">dask_transform</span><span class="p">(</span>
        <span class="n">indexes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Topology</span><span class="p">,</span>
        <span class="n">ref</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">md</span><span class="o">.</span><span class="n">rmsd</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">atom_indices</span><span class="o">=</span><span class="n">indexes</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<div class="viewcode-block" id="MinRmsdFeature.transform">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.MinRmsdFeature.transform">[docs]</a>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_vectors</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">unitcell_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes xyz and unitcell information to apply the topological calculations on.</span>

<span class="sd">        When this method is not provided with any input, it will take the</span>
<span class="sd">        traj_container provided as `traj` in the `__init__()` method and transforms</span>
<span class="sd">        this trajectory. The argument `xyz` can be the xyz coordinates in nanometer</span>
<span class="sd">        of a trajectory with identical topology as `self.traj`. If `periodic` was</span>
<span class="sd">        set to True, `unitcell_vectors` and `unitcell_info` should also be provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            xyz (Optional[np.ndarray]): A numpy array with shape (n_frames, n_atoms, 3)</span>
<span class="sd">                in nanometer. If None is provided, the coordinates of `self.traj`</span>
<span class="sd">                will be used. Otherwise, the topology of this set of xyz</span>
<span class="sd">                coordinates should match the topology of `self.atom`.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            unitcell_vectors (Optional[np.ndarray]): When periodic is set to</span>
<span class="sd">                True, the `unitcell_vectors` are needed to calculate the</span>
<span class="sd">                minimum image convention in a periodic space. This numpy</span>
<span class="sd">                array should have the shape (n_frames, 3, 3). The rows of this</span>
<span class="sd">                array correlate to the Bravais vectors a, b, and c.</span>
<span class="sd">            unitcell_info (Optional[np.ndarray]): Basically identical to</span>
<span class="sd">                `unitcell_vectors`. A numpy array of shape (n_frames, 6), where</span>
<span class="sd">                the first three columns are the unitcell_lengths in nanometer.</span>
<span class="sd">                The other three columns are the unitcell_angles in degrees.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The result of the computation with shape (n_frames, n_indexes).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span>
            <span class="n">unitcell_vectors</span><span class="p">,</span>
            <span class="n">unitcell_info</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">Feature</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">unitcell_vectors</span><span class="p">,</span> <span class="n">unitcell_info</span><span class="p">)</span>

        <span class="c1"># create a dummy traj, with the appropriate topology</span>
        <span class="n">traj</span> <span class="o">=</span> <span class="n">md</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">(</span>
            <span class="n">xyz</span><span class="o">=</span><span class="n">xyz</span><span class="p">,</span>
            <span class="n">topology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="p">,</span>
            <span class="n">unitcell_lengths</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span>
            <span class="n">unitcell_angles</span><span class="o">=</span><span class="n">unitcell_info</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">:],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">md</span><span class="o">.</span><span class="n">rmsd</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">atom_indices</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_indices</span><span class="p">),</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span></div>
</div>



<span class="c1">################################################################################</span>
<span class="c1"># EncoderMap features</span>
<span class="c1">################################################################################</span>


<div class="viewcode-block" id="CentralDihedrals">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralDihedrals">[docs]</a>
<span class="k">class</span> <span class="nc">CentralDihedrals</span><span class="p">(</span><span class="n">DihedralFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all dihedrals in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">selstr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">omega</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate this feature class.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (em.SingleTraj): A topology to build features from.</span>
<span class="sd">            selstr (Optional[str]): A string, that limits the selection of dihedral angles.</span>
<span class="sd">                Only dihedral angles which atoms are represented by the `selstr` argument</span>
<span class="sd">                are considered. This selection string follows MDTraj&#39;s atom selection</span>
<span class="sd">                language: https://mdtraj.org/1.9.3/atom_selection.html. Can also</span>
<span class="sd">                be None, in which case all backbone dihedrals (also omega) are</span>
<span class="sd">                considered. Defaults to None.</span>
<span class="sd">            deg (bool): Whether to return the result in degree (`deg=True`) or in</span>
<span class="sd">                radians (`deg=False`). Defaults to False (radians).</span>
<span class="sd">            cossin (bool): If True, each angle will be returned as a pair of</span>
<span class="sd">                (sin(x), cos(x)). This is useful, if you calculate the means</span>
<span class="sd">                (e.g. TICA/PCA, clustering) in that space. Defaults to False.</span>
<span class="sd">            periodic (bool): Whether to recognize periodic boundary conditions and</span>
<span class="sd">                work under the minimum image convention. Defaults to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selstr</span> <span class="o">=</span> <span class="n">selstr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">indices_psi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">),</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">indices_omega</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">selstr</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span> <span class="o">=</span> <span class="n">indices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">),</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="p">]</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">indices_phi</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">),</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
            <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zipped</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span><span class="p">))</span>

        <span class="c1"># alternate phi, psi , omega pairs (phi_1, psi_1, omega_1..., phi_n, psi_n, omega_n)</span>
        <span class="n">dih_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zipped</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># set generic_labels for xarray</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CentralDihedrals</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">dih_indexes</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">cossin</span><span class="o">=</span><span class="n">cossin</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;CentralDihedrals&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;CentralDihedrals&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 4) shaped numpy array giving the atom indices</span>
<span class="sd">        of the dihedral angles to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="CentralDihedrals.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralDihedrals.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">clustal_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">])</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">clustal_w</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">count</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_residues</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Provided clustal W alignment </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="si">}</span><span class="s2"> does not &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;contain as many residues as traj </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">n_residues</span><span class="si">}</span><span class="s2">. Can not &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;use this alignment.&quot;</span>
            <span class="p">)</span>
            <span class="n">_psi_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">clustal_w</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">][</span>
                <span class="p">:</span><span class="o">-</span><span class="mi">1</span>
            <span class="p">]</span>  <span class="c1"># last residue can&#39;t have psi</span>
            <span class="n">_phi_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">clustal_w</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">][</span>
                <span class="mi">1</span><span class="p">:</span>
            <span class="p">]</span>  <span class="c1"># first residue can&#39;t have phi</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">_omega_inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">clustal_w</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">][</span>
                    <span class="p">:</span><span class="o">-</span><span class="mi">1</span>
                <span class="p">]</span>  <span class="c1"># last residue can&#39;t have omega</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_psi_inds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_phi_inds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_omega_inds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_psi_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">_phi_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">_omega_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_psi_inds</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(OMEGA </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(OMEGA </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">labels_omega</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                        <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_omega_inds</span>
                <span class="p">]</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_phi_inds</span>
            <span class="p">]</span>
            <span class="c1"># produce the same ordering as the given indices (phi_1, psi_1, ..., phi_n, psi_n)</span>
            <span class="c1"># or (cos(phi_1), sin(phi_1), cos(psi_1), sin(psi_1), ..., cos(phi_n), sin(phi_n), cos(psi_n), sin(psi_n))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_omega</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">zipped</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CENTERDIH PSI    </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_psi_inds</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">labels_omega</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CENTERDIH OMEGA  </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_omega_inds</span><span class="p">]</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;CENTERDIH PHI    </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_phi_inds</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_omega</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">zipped</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="CentralDihedrals.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralDihedrals.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. The length</span>
<span class="sd">                is determined by the `dih_indexes` and the `cossin` argument</span>
<span class="sd">                in the `__init__()` method. If `cossin` is false, then</span>
<span class="sd">                `len(describe()) == self.angle_indexes[-1]`, else `len(describe())`</span>
<span class="sd">                is twice as long.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;RESID  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PSI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(OMEGA </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(OMEGA </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
                <span class="n">labels_omega</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                        <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span>
                <span class="p">]</span>
            <span class="n">sin_cos</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(PHI </span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                    <span class="n">sin_cos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span>
            <span class="p">]</span>
            <span class="c1"># produce the same ordering as the given indices (phi_1, psi_1, ..., phi_n, psi_n)</span>
            <span class="c1"># or (cos(phi_1), sin(phi_1), cos(psi_1), sin(psi_1), ..., cos(phi_n), sin(phi_n), cos(psi_n), sin(psi_n))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_omega</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">zipped</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels_psi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s2">&quot;CENTERDIH PSI   &quot;</span> <span class="o">+</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psi_inds</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">labels_omega</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;CENTERDIH OMEGA &quot;</span> <span class="o">+</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_omega_inds</span>
                <span class="p">]</span>
            <span class="n">labels_phi</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;CENTERDIH PHI   &quot;</span> <span class="o">+</span> <span class="n">getlbl</span><span class="p">(</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">ires</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phi_inds</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_omega</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels_psi</span><span class="p">,</span> <span class="n">labels_phi</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">zipped</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">res</span></div>
</div>



<div class="viewcode-block" id="SideChainDihedrals">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainDihedrals">[docs]</a>
<span class="k">class</span> <span class="nc">SideChainDihedrals</span><span class="p">(</span><span class="n">DihedralFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all dihedrals in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        options (list[str]): A list of possible sidechain angles [&#39;chi1&#39; to &#39;chi5&#39;].</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">options</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chi1&quot;</span><span class="p">,</span> <span class="s2">&quot;chi2&quot;</span><span class="p">,</span> <span class="s2">&quot;chi3&quot;</span><span class="p">,</span> <span class="s2">&quot;chi4&quot;</span><span class="p">,</span> <span class="s2">&quot;chi5&quot;</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">selstr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">which</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span>
        <span class="c1"># get all dihedral index pairs</span>
        <span class="n">indices_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;indices_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">selstr</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">selstr</span><span class="p">)</span>
            <span class="n">truncated_indices_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">indices_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">inds</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">selection</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">truncated_indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">inds</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">indices_dict</span> <span class="o">=</span> <span class="n">truncated_indices_dict</span>

        <span class="n">valid</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">indices_dict</span> <span class="k">if</span> <span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="c1"># Third Party Imports</span>
            <span class="kn">import</span> <span class="nn">mdtraj</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">mdtraj</span><span class="o">.</span><span class="n">compute_chi1</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Could not determine any side chain dihedrals for your topology! &quot;</span>
                    <span class="s2">&quot;This is an error inside MDTraj. It errors with this message: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. You can try to provide a custom_topology &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;for this protein to supersede MDTraj&#39;s sidechain recognition &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;algorithm.&quot;</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No sidechain dihedrals for the trajectory </span><span class="si">{</span><span class="n">traj</span><span class="si">=}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># for proteins that don&#39;t have some chi angles we filter which</span>
        <span class="n">which</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_dict</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">indices_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># change the sorting to be per-residue and not all chi1 and then all chi2 angles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">per_res_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="n">arrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bools</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">valid</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="p">]))):</span>
                    <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span>
                            <span class="n">valid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">atoms</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="n">valid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">where</span><span class="p">]</span>
                    <span class="n">bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bools</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">bools</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">per_res_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_prefix_label_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">indices_dict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_res_dict</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">SideChainDihedrals</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">dih_indexes</span><span class="o">=</span><span class="n">indices</span><span class="p">,</span>
            <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">,</span>
            <span class="n">cossin</span><span class="o">=</span><span class="n">cossin</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;SideChainDihedrals&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SideChainDihedrals&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 4) shaped numpy array giving the atom indices</span>
<span class="sd">        of the dihedral angles to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>

<div class="viewcode-block" id="SideChainDihedrals.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainDihedrals.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">residue_mapping</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">res</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="n">residue_mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">def</span> <span class="nf">getlbl</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="n">md</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">Atom</span><span class="p">):</span>
                <span class="n">resSeq</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span>
                <span class="n">resSeq</span> <span class="o">=</span> <span class="n">residue_mapping</span><span class="p">[</span><span class="n">resSeq</span><span class="p">]</span>
                <span class="n">r</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;RESID  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">r</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;RESID  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix_label_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
                <span class="n">lengths</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">*</span> <span class="n">lengths</span><span class="p">)</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_res_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
                <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">opt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[:</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">opt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[:</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">cossin</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;SIDECHDIH </span><span class="si">{dih}</span><span class="s2">  </span><span class="si">{res}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[:</span><span class="mi">14</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">27</span><span class="p">:</span><span class="mi">31</span><span class="p">],</span> <span class="n">labels</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="SideChainDihedrals.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainDihedrals.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. The length</span>
<span class="sd">                is determined by the `dih_indexes` and the `cossin` argument</span>
<span class="sd">                in the `__init__()` method. If `cossin` is false, then</span>
<span class="sd">                `len(describe()) == self.angle_indexes[-1]`, else `len(describe())`</span>
<span class="sd">                is twice as long.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;RESID  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prefix_label_lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
                <span class="n">lengths</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">label</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">*</span> <span class="n">lengths</span><span class="p">)</span>
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_res_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
                <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">opt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[:</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">*</span> <span class="mi">2</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefixes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">opt</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[:</span> <span class="n">value</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cossin</span><span class="p">:</span>
            <span class="n">cossin</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;COS(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="s2">&quot;SIN(</span><span class="si">{dih}</span><span class="s2"> </span><span class="si">{res}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cossin</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;SIDECHDIH </span><span class="si">{dih}</span><span class="s2">  </span><span class="si">{res}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">dih</span><span class="o">=</span><span class="n">prefixes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">res</span><span class="o">=</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">ires</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">)</span>
            <span class="p">]</span>

        <span class="k">return</span> <span class="n">labels</span></div>
</div>



<div class="viewcode-block" id="AllCartesians">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllCartesians">[docs]</a>
<span class="k">class</span> <span class="nc">AllCartesians</span><span class="p">(</span><span class="n">SelectionFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all cartesian positions of all atoms in the trajectory.</span>

<span class="sd">    Note:</span>
<span class="sd">        The order of the cartesians is not as in standard MD coordinates.</span>
<span class="sd">        Rather than giving the positions of all atoms of the first residue, and</span>
<span class="sd">        then all positions of the second, and so on, this feature gives all</span>
<span class="sd">        central (backbone) cartesians first, followed by the cartesians of the</span>
<span class="sd">        sidechains. This allows better and faster backmapping. See</span>
<span class="sd">        `encodermap.misc.backmapping._full_backmapping_np` for mor info,</span>
<span class="sd">        why this is easier.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case, it is &#39;POSITION&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;POSITION &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the AllCartesians class.</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (em.SingleTraj): A mdtraj topology.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">central_indices</span> <span class="o">=</span> <span class="n">CentralCartesians</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">indexes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">central_indices</span><span class="p">,</span> <span class="n">SideChainCartesians</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">indexes</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Could not determine&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The topology of </span><span class="si">{</span><span class="n">traj</span><span class="si">}</span><span class="s2"> does not contain any sidechains. The &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`AllCartesians` feature will just contain backbone coordinates.&quot;</span>
                <span class="p">)</span>
                <span class="n">indexes</span> <span class="o">=</span> <span class="n">CentralCartesians</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">indexes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of this class: &#39;AllCartesians&#39;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;AllCartesians&quot;</span>

<div class="viewcode-block" id="AllCartesians.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllCartesians.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SideChainCartesians can&#39;t currently handle alignments. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;implementation below won&#39;t probably work.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># clustal_w_ = [*self.traj.clustal_w]</span>
            <span class="c1"># clustal_w = [None] * (len(clustal_w_) * 3)</span>
            <span class="c1"># clustal_w[::3] = clustal_w_</span>
            <span class="c1"># clustal_w[1::3] = clustal_w_</span>
            <span class="c1"># clustal_w[2::3] = clustal_w_</span>
            <span class="c1"># clustal_w = np.array(clustal_w)</span>
            <span class="c1"># indices = (np.arange(len(clustal_w)) + 1)[clustal_w != &quot;-&quot;]</span>
            <span class="c1"># assert len(indices) == len(</span>
            <span class="c1">#     self.central_indexes</span>
            <span class="c1"># ), f&quot;{indices.shape=} {self.indexes.shape=} {clustal_w.shape=} {clustal_w[:20]}&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="n">visited_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">central_indices</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="s2">&quot;c&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">position</span> <span class="o">=</span> <span class="s2">&quot;s&quot;</span>
            <span class="n">residx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">rescode</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">residx</span><span class="p">)</span> <span class="o">+</span> <span class="n">position</span>
            <span class="k">if</span> <span class="n">rescode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_residues</span><span class="p">:</span>
                <span class="n">visited_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rescode</span><span class="p">)</span>
                <span class="n">atom_index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">residx</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">position</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">atom_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="AllCartesians.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllCartesians.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature. This list has as many entries as atoms in `self.top`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">     </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>
</div>



<div class="viewcode-block" id="CentralCartesians">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralCartesians">[docs]</a>
<span class="k">class</span> <span class="nc">CentralCartesians</span><span class="p">(</span><span class="n">SelectionFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all cartesian positions of the backbone atoms.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; from pprint import pprint</span>
<span class="sd">        &gt;&gt;&gt; traj = em.load_project(&quot;pASP_pGLU&quot;, 0)[0]</span>
<span class="sd">        &gt;&gt;&gt; traj  # doctest: +ELLIPSIS</span>
<span class="sd">        &lt;encodermap.SingleTraj object...&gt;</span>
<span class="sd">        &gt;&gt;&gt; feature = em.features.CentralCartesians(traj, generic_labels=False)</span>
<span class="sd">        &gt;&gt;&gt; pprint(feature.describe())  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">        [&#39;CENTERPOS X     ATOM     N:    0 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;CENTERPOS Y     ATOM     N:    0 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;CENTERPOS Z     ATOM     N:    0 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;CENTERPOS X     ATOM    CA:    3 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;CENTERPOS Y     ATOM    CA:    3 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;CENTERPOS Z     ATOM    CA:    3 GLU:   1 CHAIN 0&#39;,</span>
<span class="sd">         &#39;...</span>
<span class="sd">         &#39;CENTERPOS Z     ATOM     C:   65 GLU:   6 CHAIN 0&#39;]</span>
<span class="sd">         &gt;&gt;&gt; feature = em.features.CentralCartesians(traj, generic_labels=True)</span>
<span class="sd">         &gt;&gt;&gt; pprint(feature.describe())  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">         [&#39;CENTERPOS X 1&#39;,</span>
<span class="sd">          &#39;CENTERPOS Y 1&#39;,</span>
<span class="sd">          &#39;CENTERPOS Z 1&#39;,</span>
<span class="sd">          &#39;CENTERPOS X 2&#39;,</span>
<span class="sd">          &#39;CENTERPOS Y 2&#39;,</span>
<span class="sd">          &#39;CENTERPOS Z 2&#39;,</span>
<span class="sd">          &#39;...</span>
<span class="sd">          &#39;CENTERPOS Z 18&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CENTERPOS&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the CentralCartesians class.</span>

<span class="sd">        In contrary to PyEMMA (which has now been archived), this feature returns</span>
<span class="sd">        a high-dimensional array along the feature axis. In PyEMMA&#39;s and now in</span>
<span class="sd">        EncoderMap&#39;s `SelectionFeature`, the cartesian coordinates of the atoms are</span>
<span class="sd">        returned as a list of [x1, y1, z1, x2, y2, z2, x3, ..., zn]. This feature</span>
<span class="sd">        yields a (n_atoms, 3) array with an extra dimension (carteisan coordinate)::</span>

<span class="sd">            [</span>
<span class="sd">                [x1, y1, z1],</span>
<span class="sd">                [x2, y2, z2],</span>
<span class="sd">                ...,</span>
<span class="sd">                [xn, yn, zn],</span>
<span class="sd">            ]</span>

<span class="sd">        Args:</span>
<span class="sd">            traj (SingleTraj): An instance of `encodermap.SingleTraj`. Using</span>
<span class="sd">                `SingleTrajs` instead of `md.Topology` (as it was in PyEMMA),</span>
<span class="sd">                offers access to EncoderMap&#39;s `CustomTopology`, which can be</span>
<span class="sd">                used to adapt the featurization and NN training for a wide</span>
<span class="sd">                range of protein and non-protein MD trajectories.</span>
<span class="sd">            generic_labels (bool): Whether to use generic labels to describe the</span>
<span class="sd">                feature. Generic labels can be used to align different topologies.</span>
<span class="sd">                If False, the labels returned by this feature&#39;s `describe()` method</span>
<span class="sd">                are topology-specific (&quot;CENTERPOS X     ATOM     N:    0 ASP:   1 CHAIN 0&quot;).</span>
<span class="sd">                If True, the labels are generic (&quot;CENTERPOS X 0&quot;) and can be</span>
<span class="sd">                aligned with other Features, that contain topologies, of which ASP</span>
<span class="sd">                might not be the first amino acid.</span>
<span class="sd">            check_aas (bool): Whether to check if all residues in `traj` are</span>
<span class="sd">                known, prior to computing.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name CA or name C or name N&quot;</span><span class="p">)</span>
        <span class="c1"># filter out unwanted indexes</span>
        <span class="n">unwanted_resnames</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">amino_acid_codes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span>
                <span class="nb">filter</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span>
                    <span class="ow">not</span> <span class="ow">in</span> <span class="n">unwanted_resnames</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">,</span> <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

<div class="viewcode-block" id="CentralCartesians.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralCartesians.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">clustal_w_</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">]</span>
            <span class="n">clustal_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w_</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">clustal_w</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">clustal_w</span> <span class="o">!=</span> <span class="s2">&quot;-&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">clustal_w</span><span class="o">.</span><span class="n">shape</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">clustal_w</span><span class="p">[:</span><span class="mi">20</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="CentralCartesians.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralCartesians.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">     </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;CentralCartesians&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;CentralCartesians&quot;</span></div>



<div class="viewcode-block" id="SideChainCartesians">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainCartesians">[docs]</a>
<span class="k">class</span> <span class="nc">SideChainCartesians</span><span class="p">(</span><span class="n">SelectionFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all cartesian positions of all non-backbone atoms.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case it is &#39;SIDECHPOS&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SIDECHPOS&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the `SideChainCartesians feature.</span>

<span class="sd">        Uses MDTraj&#39;s &#39;not backbone&#39; topology selector. Is not guaranteed to</span>
<span class="sd">        work with the better tested `SideChainDihedrals`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="n">dihe_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">SideChainDihedrals</span><span class="p">(</span><span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">angle_indexes</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">backbone_indices</span> <span class="o">=</span> <span class="n">CentralCartesians</span><span class="p">(</span><span class="n">traj</span><span class="o">=</span><span class="n">traj</span><span class="p">)</span><span class="o">.</span><span class="n">indexes</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">dihe_indices</span><span class="p">,</span> <span class="n">backbone_indices</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">dihe_indices</span> <span class="ow">and</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">backbone_indices</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">indexes</span><span class="o">=</span><span class="n">indexes</span><span class="p">,</span> <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

<div class="viewcode-block" id="SideChainCartesians.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainCartesians.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;SideChainCartesians can&#39;t currently handle alignments. The &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;implementation below won&#39;t probably work.&quot;</span>
            <span class="p">)</span>
            <span class="c1"># clustal_w_ = [*self.traj.clustal_w]</span>
            <span class="c1"># clustal_w = [None] * (len(clustal_w_) * 3)</span>
            <span class="c1"># clustal_w[::3] = clustal_w_</span>
            <span class="c1"># clustal_w[1::3] = clustal_w_</span>
            <span class="c1"># clustal_w[2::3] = clustal_w_</span>
            <span class="c1"># clustal_w = np.array(clustal_w)</span>
            <span class="c1"># indices = (np.arange(len(clustal_w)) + 1)[clustal_w != &quot;-&quot;]</span>
            <span class="c1"># assert len(indices) == len(</span>
            <span class="c1">#     self.central_indexes</span>
            <span class="c1"># ), f&quot;{indices.shape=} {self.indexes.shape=} {clustal_w.shape=} {clustal_w[:20]}&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span>
        <span class="n">visited_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">residx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">residx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_residues</span><span class="p">:</span>
                <span class="n">visited_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">residx</span><span class="p">)</span>
                <span class="n">atom_index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">atom_index</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">residx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">atom_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;SideChainCartesians&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SideChainCartesians&quot;</span>

<div class="viewcode-block" id="SideChainCartesians.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainCartesians.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">indexes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">]:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">     </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>
</div>



<div class="viewcode-block" id="AllBondDistances">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllBondDistances">[docs]</a>
<span class="k">class</span> <span class="nc">AllBondDistances</span><span class="p">(</span><span class="n">DistanceFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all bonds in a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case it is &#39;DISTANCE&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;DISTANCE        &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">distance_indexes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span> <span class="o">=</span> <span class="n">distance_indexes</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[[</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">bonds</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="c1"># print(self.distance_indexes, len(self.distance_indexes))</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">,</span>
                <span class="n">periodic</span><span class="p">,</span>
                <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
                <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">,</span>
                <span class="n">periodic</span><span class="p">,</span>
                <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
                <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># print(self.distance_indexes, len(self.distance_indexes))</span>

<div class="viewcode-block" id="AllBondDistances.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllBondDistances.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;AllBondDistances can currently not align disjoint sequences.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="AllBondDistances.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.AllBondDistances.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> DIST  </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;AllBondDistances&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;AllBondDistances&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 2) shaped numpy array giving the atom indices</span>
<span class="sd">        of the distances to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span></div>



<div class="viewcode-block" id="CentralBondDistances">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralBondDistances">[docs]</a>
<span class="k">class</span> <span class="nc">CentralBondDistances</span><span class="p">(</span><span class="n">AllBondDistances</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all bonds in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case, it is &#39;CENTERDISTANCE&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CENTERDISTANCE  &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">distance_indexes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name CA or name C or name N&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">distance_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">distance_indexes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">bonds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">select</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]):</span>
                <span class="n">distance_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>
        <span class="n">distance_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distance_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">distance_indexes</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>

<div class="viewcode-block" id="CentralBondDistances.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralBondDistances.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">clustal_w_</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">]</span>
            <span class="n">clustal_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w_</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">clustal_w</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">clustal_w</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;CentralBondDistances&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;CentralBondDistances&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 2) shaped numpy array giving the atom indices</span>
<span class="sd">        of the distances to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span></div>



<div class="viewcode-block" id="SideChainBondDistances">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainBondDistances">[docs]</a>
<span class="k">class</span> <span class="nc">SideChainBondDistances</span><span class="p">(</span><span class="n">AllBondDistances</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all bonds not in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case it is &#39;SIDECHDISTANCE&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SIDECHDISTANCE  &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>

        <span class="n">which</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;chi1&quot;</span><span class="p">,</span> <span class="s2">&quot;chi2&quot;</span><span class="p">,</span> <span class="s2">&quot;chi3&quot;</span><span class="p">,</span> <span class="s2">&quot;chi4&quot;</span><span class="p">,</span> <span class="s2">&quot;chi5&quot;</span><span class="p">]</span>
        <span class="n">indices_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;indices_</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">which</span><span class="p">}</span>
        <span class="c1"># flat_list = [</span>
        <span class="c1">#     item</span>
        <span class="c1">#     for sublist in indices_dict.values()</span>
        <span class="c1">#     for item in sublist.flatten().tolist()</span>
        <span class="c1"># ]</span>
        <span class="c1"># atoms_in_sidechain_dihedrals = set(flat_list)</span>

        <span class="n">distance_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">angle</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">indices_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="o">==</span> <span class="s2">&quot;chi1&quot;</span><span class="p">:</span>
                    <span class="n">distance_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
                    <span class="n">distance_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">distance_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">index</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">distance_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">distance_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span>
            <span class="n">distance_indexes</span><span class="o">=</span><span class="n">distance_indexes</span><span class="p">,</span>
            <span class="n">periodic</span><span class="o">=</span><span class="n">periodic</span><span class="p">,</span>
            <span class="n">check_aas</span><span class="o">=</span><span class="n">check_aas</span><span class="p">,</span>
            <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

<div class="viewcode-block" id="SideChainBondDistances.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainBondDistances.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="c1"># indices = []</span>
            <span class="c1"># clustal_w_ = [*self.traj.clustal_w]</span>
            <span class="c1"># clustal_w = [None] * (len(clustal_w_) * 3)</span>
            <span class="c1"># clustal_w[::3] = clustal_w_</span>
            <span class="c1"># clustal_w[1::3] = clustal_w_</span>
            <span class="c1"># clustal_w[2::3] = clustal_w_</span>
            <span class="c1"># i = 0</span>
            <span class="c1"># for a, b in zip(clustal_w[:-1], clustal_w[1:]):</span>
            <span class="c1">#     i += 1</span>
            <span class="c1">#     if a == &quot;-&quot;:</span>
            <span class="c1">#         continue</span>
            <span class="c1">#     indices.append(i)</span>
            <span class="c1"># indices = np.array(indices)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span>
        <span class="n">visited_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">residx_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">residx_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">residx_a</span> <span class="o">==</span> <span class="n">residx_b</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The sidechain distance between atom </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2"> and &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2"> describes a distance between two residues &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">residx_a</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">residx_b</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;As sidechains belong always to a single residue, something is off. &quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">residx_a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_residues</span><span class="p">:</span>
                <span class="n">visited_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">residx_a</span><span class="p">)</span>
                <span class="n">distance_index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">distance_index</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">residx_a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">distance_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;SideChainBondDistances&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SideChainBondDistances&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 2) shaped numpy array giving the atom indices</span>
<span class="sd">        of the distances to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">distance_indexes</span></div>



<div class="viewcode-block" id="CentralAngles">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralAngles">[docs]</a>
<span class="k">class</span> <span class="nc">CentralAngles</span><span class="p">(</span><span class="n">AngleFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all angles in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case it is &#39;CENTERANGLE&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CENTERANGLE     &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SingleTraj</span><span class="p">,</span> <span class="n">TrajEnsemble</span><span class="p">],</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="n">select</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;name CA or name C or name N&quot;</span><span class="p">)</span>
        <span class="c1"># add 4 bonds in KAC</span>
        <span class="c1"># if any([r.name == &quot;KAC&quot; for r in top.residues]):</span>
        <span class="c1">#     self.top = add_KAC_backbone_bonds(self.top)</span>
        <span class="n">bonds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([[</span><span class="n">x</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">bonds</span><span class="p">])</span>
        <span class="n">bond_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">bonds</span><span class="p">])</span>
        <span class="n">angle_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">select</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bonds</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
            <span class="n">possible_bonds</span> <span class="o">=</span> <span class="n">bonds</span><span class="p">[</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">possible_bond_names</span> <span class="o">=</span> <span class="n">bond_names</span><span class="p">[</span><span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">possible_bonds</span><span class="p">,</span> <span class="n">select</span><span class="p">)</span>
            <span class="n">hits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">hits</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># atom is not part of any angles</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">hits</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">these</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">possible_bonds</span><span class="p">[</span><span class="n">where</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
                <span class="p">)</span>
                <span class="n">angle_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">these</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">hits</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">bonds</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="sa">f</span><span class="s2">&quot;BOND </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">bonds</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="n">a</span>
                    <span class="p">]</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The atom </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2"> takes part in three possible angles defined &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;by the C, CA, and N atoms:</span><span class="se">\n</span><span class="si">{</span><span class="n">bonds</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">hits</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t deal with these angles. One atom is part of four possible angles&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t deal with these angles. One atom is part of more than three angles&quot;</span>
                <span class="p">)</span>

        <span class="n">angle_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">angle_indexes</span><span class="p">)</span>
        <span class="n">angle_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">angle_indexes</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">traj</span><span class="p">,</span> <span class="n">angle_indexes</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">cossin</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>

<div class="viewcode-block" id="CentralAngles.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralAngles.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">clustal_w_</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">clustal_w</span><span class="p">]</span>
            <span class="n">clustal_w</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clustal_w_</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">clustal_w</span><span class="p">[::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">clustal_w</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">clustal_w_</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clustal_w</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">clustal_w</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">clustal_w</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="s2">&quot;-&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="CentralAngles.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.CentralAngles.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM  </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> ANGLE </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="si">}</span><span class="s2"> ANGLE &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2"> CHAIN &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;CentralAngles&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;CentralAngles&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 3) shaped numpy array giving the atom indices</span>
<span class="sd">        of the angles to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span></div>



<div class="viewcode-block" id="SideChainAngles">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainAngles">[docs]</a>
<span class="k">class</span> <span class="nc">SideChainAngles</span><span class="p">(</span><span class="n">AngleFeature</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feature that collects all angles not in the backbone of a topology.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        top (mdtraj.Topology): Topology of this feature.</span>
<span class="sd">        indexes (np.ndarray): The numpy array returned from `top.select(&#39;all&#39;)`.</span>
<span class="sd">        prefix_label (str): A prefix for the labels. In this case it is &#39;SIDECHANGLE&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">prefix_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;SIDECHANGLE &quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">traj</span><span class="p">:</span> <span class="n">SingleTraj</span><span class="p">,</span>
        <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cossin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">check_aas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">generic_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">delayed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traj</span> <span class="o">=</span> <span class="n">traj</span>
        <span class="n">angle_indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">residue</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">_custom_top</span><span class="o">.</span><span class="n">sidechain_indices_by_residue</span><span class="p">():</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">ind</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">angle_indexes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">angle_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">angle_indexes</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="n">angle_indexes</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">cossin</span><span class="p">,</span> <span class="n">periodic</span><span class="p">,</span> <span class="n">check_aas</span><span class="p">,</span> <span class="n">delayed</span><span class="o">=</span><span class="n">delayed</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">generic_labels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">describe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_describe</span>

<div class="viewcode-block" id="SideChainAngles.generic_describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainAngles.generic_describe">[docs]</a>
    <span class="k">def</span> <span class="nf">generic_describe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a list of generic labels, not containing residue names.</span>
<span class="sd">        These can be used to stack tops of different topology.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: A list of labels.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="p">,</span> <span class="s2">&quot;clustal_w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="c1"># indices = []</span>
            <span class="c1"># clustal_w_ = [*self.traj.clustal_w]</span>
            <span class="c1"># clustal_w = [None] * (len(clustal_w_) * 3)</span>
            <span class="c1"># clustal_w[::3] = clustal_w_</span>
            <span class="c1"># clustal_w[1::3] = clustal_w_</span>
            <span class="c1"># clustal_w[2::3] = clustal_w_</span>
            <span class="c1"># i = 0</span>
            <span class="c1"># for a, b, c in zip(clustal_w[:-2], clustal_w[1:-1], clustal_w[2:]):</span>
            <span class="c1">#     i += 1</span>
            <span class="c1">#     if a == &quot;-&quot;:</span>
            <span class="c1">#         continue</span>
            <span class="c1">#     indices.append(i)</span>
            <span class="c1"># indices = np.array(indices)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span>
        <span class="n">visited_residues</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">residx_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">residx_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">residx_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">residx_a</span> <span class="o">==</span> <span class="n">residx_b</span> <span class="o">==</span> <span class="n">residx_c</span><span class="p">,</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The sidechain distance between atom </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2">, and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traj</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="si">}</span><span class="s2"> describes &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;an angle between two or more residues (</span><span class="si">{</span><span class="n">residx_a</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">residx_b</span><span class="si">}</span><span class="s2">, and </span><span class="si">{</span><span class="n">residx_c</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;As sidechains belong always to a single residue, something is off. &quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">residx_a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_residues</span><span class="p">:</span>
                <span class="n">visited_residues</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">residx_a</span><span class="p">)</span>
                <span class="n">angle_index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">angle_index</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">residx_a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">angle_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">labels</span></div>


<div class="viewcode-block" id="SideChainAngles.describe">
<a class="viewcode-back" href="../../../user_guide/featurization.html#encodermap.loading.features.SideChainAngles.describe">[docs]</a>
    <span class="k">def</span> <span class="nf">describe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gives a list of strings describing this feature&#39;s feature-axis.</span>

<span class="sd">        A feature computes a collective variable (CV). A CV is aligned with an MD</span>
<span class="sd">        trajectory on the time/frame-axis. The feature axis is unique for every</span>
<span class="sd">        feature. A feature describing the backbone torsions (phi, omega, psi) would</span>
<span class="sd">        have a feature axis with the size 3*n-3, where n is the number of residues.</span>
<span class="sd">        The end-to-end distance of a linear protein in contrast would just have</span>
<span class="sd">        a feature axis with length 1. This `describe()` method will label these</span>
<span class="sd">        values unambiguously. A backbone torsion feature&#39;s `describe()` could be</span>
<span class="sd">        [&#39;phi_1&#39;, &#39;omega_1&#39;, &#39;psi_1&#39;, &#39;phi_2&#39;, &#39;omega_2&#39;, ..., &#39;psi_n-1&#39;].</span>
<span class="sd">        The end-to-end distance feature could be described by</span>
<span class="sd">        [&#39;distance_between_MET1_and_LYS80&#39;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[str]: The labels of this feature.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">getlbl</span> <span class="o">=</span> <span class="p">(</span>
            <span class="k">lambda</span> <span class="n">at</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;ATOM </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">index</span><span class="si">:</span><span class="s2">5</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">at</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">resSeq</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">prefix_label</span><span class="si">}{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2"> ANGLE </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="si">}</span><span class="s2"> ANGLE </span><span class="si">{</span><span class="n">getlbl</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2"> CHAIN </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">a</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">index</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">]])[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">labels</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: The name of the class: &quot;SideChainAngles&quot;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;SideChainAngles&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">indexes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;np.ndarray: A (n_angles, 3) shaped numpy array giving the atom indices</span>
<span class="sd">        of the angles to be calculated.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_indexes</span></div>

</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2024, Kevin Sawade, Tobias Lemke, University of Konstanz.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
    <div class="footer-items__center">
      
        <div class="footer-item"><p class="last-updated">
  Last updated on 2025-05-15T21:15:05.
  <br/>
</p></div>
      
    </div>
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">Docs for EncoderMap 3.0.1+10.g67ae638.dirty</div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>