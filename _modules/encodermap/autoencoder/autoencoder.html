
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>encodermap.autoencoder.autoencoder &#8212; encodermap 3.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/encodermap/autoencoder/autoencoder';</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">

  
  
  
  
  
  
  

  
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../getting_started/index.html">
                        Getting started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide_and_examples/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Changelog
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../getting_started/index.html">
                        Getting started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide_and_examples/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Changelog
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <h1>Source code for encodermap.autoencoder.autoencoder</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># encodermap/autoencoder/autoencoder.py</span>
<span class="c1">################################################################################</span>
<span class="c1"># Encodermap: A python library for dimensionality reduction.</span>
<span class="c1">#</span>
<span class="c1"># Copyright 2019-2022 University of Konstanz and the Authors</span>
<span class="c1">#</span>
<span class="c1"># Authors:</span>
<span class="c1"># Kevin Sawade, Tobias Lemke</span>
<span class="c1">#</span>
<span class="c1"># Encodermap is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as</span>
<span class="c1"># published by the Free Software Foundation, either version 2.1</span>
<span class="c1"># of the License, or (at your option) any later version.</span>
<span class="c1"># This package is distributed in the hope that it will be useful to other</span>
<span class="c1"># researches. IT DOES NOT COME WITH ANY WARRANTY WHATSOEVER; without even the</span>
<span class="c1"># implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span class="c1"># See the GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># See &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">################################################################################</span>
<span class="sd">&quot;&quot;&quot;Forward facing Autoencoder classes. Contains four classes:</span>

<span class="sd">* Autoencoder: Simple NN dense, fully connected AE architecture. Reg loss, auto loss and center loss</span>
<span class="sd">* EncoderMap: Uses the same architecture as `Autoencoder`, but adds another loss function.</span>
<span class="sd">* DihedralEncoderMap: Basically the same as `EncoderMap`, but rewrites the `generate` method to use</span>
<span class="sd">    an atomistic topology to rebuild a trajectory.</span>
<span class="sd">* AngleDihedralCartesianEncoderMap: Uses more loss functions and tries to learn a full all atom conformation.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="c1">################################################################################</span>
<span class="c1"># Imports</span>
<span class="c1">################################################################################</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">tensorflow.keras</span>

<span class="kn">import</span> <span class="nn">encodermap</span>

<span class="kn">from</span> <span class="nn">..callbacks.callbacks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">CheckpointSaver</span><span class="p">,</span>
    <span class="n">ImageCallback</span><span class="p">,</span>
    <span class="n">IncreaseCartesianCost</span><span class="p">,</span>
    <span class="n">ProgressBar</span><span class="p">,</span>
    <span class="n">TensorboardWriteBool</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..loss_functions.loss_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">angle_loss</span><span class="p">,</span>
    <span class="n">auto_loss</span><span class="p">,</span>
    <span class="n">cartesian_distance_loss</span><span class="p">,</span>
    <span class="n">cartesian_loss</span><span class="p">,</span>
    <span class="n">center_loss</span><span class="p">,</span>
    <span class="n">dihedral_loss</span><span class="p">,</span>
    <span class="n">distance_loss</span><span class="p">,</span>
    <span class="n">reconstruction_loss</span><span class="p">,</span>
    <span class="n">regularization_loss</span><span class="p">,</span>
    <span class="n">side_dihedral_loss</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..misc.backmapping</span> <span class="kn">import</span> <span class="n">dihedral_backmapping</span><span class="p">,</span> <span class="n">mdtraj_backmapping</span>
<span class="kn">from</span> <span class="nn">..misc.misc</span> <span class="kn">import</span> <span class="n">BadError</span><span class="p">,</span> <span class="n">create_n_cube</span><span class="p">,</span> <span class="n">plot_model</span>
<span class="kn">from</span> <span class="nn">..misc.saving_loading_models</span> <span class="kn">import</span> <span class="n">load_model</span><span class="p">,</span> <span class="n">save_model</span>
<span class="kn">from</span> <span class="nn">..models.models</span> <span class="kn">import</span> <span class="n">gen_functional_model</span><span class="p">,</span> <span class="n">gen_sequential_model</span>
<span class="kn">from</span> <span class="nn">..parameters.parameters</span> <span class="kn">import</span> <span class="n">ADCParameters</span><span class="p">,</span> <span class="n">Parameters</span>
<span class="kn">from</span> <span class="nn">..trajinfo.info_all</span> <span class="kn">import</span> <span class="n">Capturing</span><span class="p">,</span> <span class="n">TrajEnsemble</span>

<span class="c1">################################################################################</span>
<span class="c1"># Typing</span>
<span class="c1">################################################################################</span>


<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">MDAnalysis</span> <span class="k">as</span> <span class="nn">mda</span>
    <span class="kn">import</span> <span class="nn">mdtraj</span> <span class="k">as</span> <span class="nn">md</span>


<span class="c1">################################################################################</span>
<span class="c1"># Globals</span>
<span class="c1">################################################################################</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Autoencoder&quot;</span><span class="p">,</span>
    <span class="s2">&quot;EncoderMap&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AngleDihedralCartesianEncoderMap&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DihedralEncoderMap&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1">##############################################################################</span>
<span class="c1"># Function definition which allows self.p.tensorboard to be passed</span>
<span class="c1"># @function(self.p.tensorboard)</span>
<span class="c1"># def train(self):</span>
<span class="c1">#     # some training</span>
<span class="c1">##############################################################################</span>


<span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tensorboard</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compiles functions with `tensorflow.function` based on a `tensorboard`</span>
<span class="sd">    parameter.</span>


<span class="sd">    To understand the neccessity of this function, we need to have a look how</span>
<span class="sd">    tensorflow executes computations. There are two modes of execution:</span>
<span class="sd">    * eager mode: In eager mode, the computations are handles by python.</span>
<span class="sd">        The input types are python objects, and the output is a python object.</span>
<span class="sd">        This eager execution allows you to directly execute a calculation of</span>
<span class="sd">        two tensors (e.g. multiplication).</span>
<span class="sd">    * graph mode: In graph mode, computations are done inside tensorflow graphs,</span>
<span class="sd">        which are a collection of operations and tensors (i.e. data), that flow</span>
<span class="sd">        through the operations of the graph. These graphs, make tensorflow</span>
<span class="sd">        computations portable and significantly increase the performance of</span>
<span class="sd">        similar computations.</span>
<span class="sd">    Normally, you would accelerate a simple python function in tensorflow,</span>
<span class="sd">    by compiling it like so:</span>

<span class="sd">    ```python</span>
<span class="sd">    import tensorflow as tf</span>

<span class="sd">    @tf.function</span>
<span class="sd">    def multiply(a, b):</span>
<span class="sd">        return a * b</span>

<span class="sd">    multiply(tf.constant(2), tf.constant(3)).numpy()</span>
<span class="sd">    # 6</span>
<span class="sd">    ```</span>

<span class="sd">    However, the basic paradigm of accelerating the computation interferes with</span>
<span class="sd">    `encodermap.Parameters` `tensorboard=True` argument, as it writes a lot of</span>
<span class="sd">    additional information to tensorboard. Thus, a compilation with tf.function</span>
<span class="sd">    does not make sense here. That&#39;s why encodermap&#39;s `function` decorator</span>
<span class="sd">    takes an additional argument:</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tensorboard</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tensorboard&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper of `encodermap.function`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tensorboard</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Running in tensorboard mode writes a lot of stuff to tensorboard. For speed boost deactivate tensorboard mode.&quot;</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compiled</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">compiled</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<span class="c1">##############################################################################</span>
<span class="c1"># Public Classes</span>
<span class="c1">##############################################################################</span>


<div class="viewcode-block" id="Autoencoder"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder">[docs]</a><span class="k">class</span> <span class="nc">Autoencoder</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Main Autoencoder class preparing data, setting up the neural network and implementing training.</span>

<span class="sd">    This is the main class for neural networks inside EncoderMap. The class prepares the data</span>
<span class="sd">    (batching and shuffling), creates a `tf.keras.Model` of layers specified by the attributes of</span>
<span class="sd">    the `encodermap.Parameters` class. Depending on what Parent/Child-Class is instantiated</span>
<span class="sd">    a combination of cost functions is set up. Callbacks to Tensorboard are also set up.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        train_data (np.ndarray): The numpy array of the train data passed at init.</span>
<span class="sd">        p (encodermap.Parameters): An `encodermap.Parameters()` class containing all info needed to set</span>
<span class="sd">            up the network.</span>
<span class="sd">        dataset (tensorflow.data.Dataset): The dataset that is actually used in training the keras model. The dataset</span>
<span class="sd">            is a batched, shuffled, infinitely-repeating dataset.</span>
<span class="sd">        read_only (bool): Variable telling the class whether it is allowed to write to disk (False) or not (True).</span>
<span class="sd">        optimizer (tf.keras.optimizers.Adam): Instance of the Adam optimizer with learning rate specified by</span>
<span class="sd">            the Parameters class.</span>
<span class="sd">        metrics (list): A list of metrics passed to the model when it is compiled.</span>
<span class="sd">        callbacks (list): A list of tf.keras.callbacks.Callback Sub-classes changing the behavior of the model during</span>
<span class="sd">            training. Some standard callbacks are always present like:</span>
<span class="sd">                * encodermap.callbacks.callbacks.ProgressBar:</span>
<span class="sd">                    A progress bar callback using tqdm giving the current progress of training and the</span>
<span class="sd">                    current loss.</span>
<span class="sd">                * CheckPointSaver:</span>
<span class="sd">                    A callback that saves the model every parameters.checkpoint_step steps into</span>
<span class="sd">                    the main directory. This callback will only be used, when `read_only` is False.</span>
<span class="sd">                * TensorboardWriteBool:</span>
<span class="sd">                    A callback that contains a boolean Tensor that will be True or False,</span>
<span class="sd">                    depending on the current training step and the summary_step in the parameters class. The loss</span>
<span class="sd">                    functions use this callback to decide whether they should write to Tensorboard. This callback</span>
<span class="sd">                    will only be present, when `read_only` is False and `parameters.tensorboard` is True.</span>
<span class="sd">            You can append your own callbacks to this list before executing Autoencoder.train().</span>
<span class="sd">        encoder (tf.keras.models.Model): The encoder (sub)model of `model`.</span>
<span class="sd">        decoder (tf.keras.models.Model): The decoder (sub)model of `model`.</span>

<span class="sd">    Methods:</span>
<span class="sd">        from_checkpoint: Rebuild the model from a checkpoint.</span>
<span class="sd">        add_images_to_tensorboard: Make tensorboard plot images.</span>
<span class="sd">        train: Starts the training of the tf.keras.models.Model.</span>
<span class="sd">        plot_network: Tries to plot the network. For this method to work graphviz, pydot and pydotplus needs to be installed.</span>
<span class="sd">        encode: Takes high-dimensional data and sends it through the encoder.</span>
<span class="sd">        decode: Takes low-dimensional data and sends it through the encoder.</span>
<span class="sd">        generate: Same as decode. For AngleDihedralCartesianAutoencoder classes this will build a protein strutcure.</span>

<span class="sd">    Note:</span>
<span class="sd">        Performance of tensorflow is not only dependant on your system&#39;s hardware and how the data is presented to</span>
<span class="sd">        the network (for this check out https://www.tensorflow.org/guide/data_performance), but also how you compiled</span>
<span class="sd">        tensorflow. Normal tensorflow (pip install tensorflow) is build without CPU extensions to work on many CPUs.</span>
<span class="sd">        However, Tensorflow can greatly benefit from using CPU instructions like AVX2, AVX512 that bring a speed-up</span>
<span class="sd">        in linear algebra computations of 300%. By building tensorflow from source you can activate these extensions.</span>
<span class="sd">        However, the CPU speed-up is dwarfed by the speed-up when you allow tensorflow to run on your GPU (grapohics</span>
<span class="sd">        card). To check whether a GPU is available run:</span>
<span class="sd">        `print(&quot;Num GPUs Available: &quot;, len(tf.config.list_physical_devices(&#39;GPU&#39;)))`.</span>
<span class="sd">        Refer to these pages to install tensorflow for best performance:</span>
<span class="sd">        https://www.tensorflow.org/install/pip, https://www.tensorflow.org/install/gpu</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; # without providing any data, default parameters and a 4D hypercube as input data will be used.</span>
<span class="sd">        &gt;&gt;&gt; e_map = em.EncoderMap(read_only=True)</span>
<span class="sd">        &gt;&gt;&gt; print(e_map.train_data.shape)</span>
<span class="sd">        (16000, 4)</span>
<span class="sd">        &gt;&gt;&gt; print(e_map.dataset)</span>
<span class="sd">        &lt;BatchDataset element_spec=(TensorSpec(shape=(None, 4), dtype=tf.float32, name=None), TensorSpec(shape=(None, 4), dtype=tf.float32, name=None))&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(e_map.encode(e_map.train_data).shape)</span>
<span class="sd">        (16000, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Autoencoder.__init__"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">train_data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Dataset</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">read_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the Autoencoder class.</span>

<span class="sd">        Args:</span>
<span class="sd">            parameters (Union[encodermap.Parameters, None], optional): The parameters to be used. If None is</span>
<span class="sd">                provided default values (check them with print(em.Parameters.defaults_description()))</span>
<span class="sd">                are used. Defaults to None.</span>
<span class="sd">            train_data (Union[np.ndarray, tf.data.Dataset, None], optional): The train data. Can be one of the following:</span>
<span class="sd">                * None: If None is provided points on the edges of a 4-dimensional hypercube will be used as train data.</span>
<span class="sd">                * np.ndarray: If a numpy array is provided, it will be transformed into a batched tf.data.Dataset by</span>
<span class="sd">                    first making it an infinitely repeating dataset, shuffling it and the batching it with a batch</span>
<span class="sd">                    size specified by parameters.batch_size.</span>
<span class="sd">                * tf.data.Dataset: If a dataset is provided it will be used without making any adjustments. Make</span>
<span class="sd">                    sure, that the dataset uses `float32` as its type.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            model (Union[tf.keras.models.Model, None], optional): Providing a keras model to this argument will make</span>
<span class="sd">                the Autoencoder/EncoderMap class use this model instead of the predefined ones. Make sure the model</span>
<span class="sd">                can accept EncoderMap&#39;s loss functions. If None is provided the model will be built using</span>
<span class="sd">                the specifications in parameters. Defaults to None.</span>
<span class="sd">            read_only (bool, optional): Whether the class is allowed to write to disk (False) or not (True). Defaults</span>
<span class="sd">                to False and will allow the class to write to disk.</span>

<span class="sd">        Raises:</span>
<span class="sd">            BadError: When read_only is `True` and `parameters.tensorboard` is `True`, this Exception will be raised,</span>
<span class="sd">                because they are mutually exclusive.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">Parameters</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">parameters</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span> <span class="o">=</span> <span class="n">read_only</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Output files are saved to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">),</span>
                <span class="s2">&quot;as defined in &#39;main_path&#39; in the parameters.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># check whether Tensorboard and Read-Only makes Sense</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BadError</span><span class="p">(</span>
                <span class="s2">&quot;Setting tensorboard and read_only True is not possible. Tensorboard will always write to disk.&quot;</span>
                <span class="s2">&quot; If you received this Error while loading a trained model, pass read_only=False as an argument&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; or set overwrite_tensorboard_bool True to overwrite the tensorboard parameter.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># clear old sessions</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">clear_session</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>

        <span class="c1"># set up train_data</span>
        <span class="k">if</span> <span class="n">train_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span> <span class="o">=</span> <span class="n">create_n_cube</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">seed</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">periodicity</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">train_data</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Input contains nans. Using sparse network.&quot;</span><span class="p">)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">train_data</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                <span class="n">dense_shape</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">train_data</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">train_data</span><span class="p">)]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
                <span class="n">sparse_tensor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span> <span class="o">=</span> <span class="n">sparse_tensor</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">train_data</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">training</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;It seems like your dataset only yields tensors and not &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;tuples of tensors. Tensorlfow is optimized for classification &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;tasks, where datasets yield tuples of (data, classes). EncoderMap,&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;however is a regression task, but uses the same code as the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;classification tasks. I will transform your dataset using &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;the `tf.data.Dataset.zip()` function of `tf.data`. You can &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;set the `training` parameter in the parameter class to &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;custom&#39; to not alter your dataset.&quot;</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span> <span class="o">=</span> <span class="n">_</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;train_data must be `None`, `np.ndarray` or `tf.data.Dataset`. You supplied </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check data and periodicity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">train_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">train_data</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">periodicity</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;There seems to be an error regarding the periodicity &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;of your data. The chosen periodicity is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">periodicity</span><span class="si">}</span><span class="s2">, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but there are datapoints outwards of this range: </span><span class="si">{</span><span class="n">train_data</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># prepare the data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">training</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">(</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
                <span class="n">buffer_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reshuffle_each_iteration</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># ToDo: Make training faster with Autotune, XLA (jit) compilation, DataRecords</span>
        <span class="c1"># self.dataset = self.dataset.prefetch(self.p.batch_size * 4)</span>
        <span class="c1"># self.dataset = self.dataset.interleave(num_parallel_calls=tf.data.experimental.AUTOTUNE)</span>
        <span class="c1"># num_batches = 20</span>
        <span class="c1"># num_threads = 8</span>
        <span class="c1"># if self.p.training == &#39;auto&#39;:</span>
        <span class="c1">#     ds = tf.data.Dataset.from_tensors((self.train_data, self.train_data)).repeat(self.p.batch_size * num_batches)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     ds = tf.data.Dataset.from_tensors(self.train_data).repeat(self.p.batch_size * num_batches)</span>
        <span class="c1"># # ds = tf.data.Dataset.from_tensors(self.train_data).repeat(self.p.batch_size * num_batches)</span>
        <span class="c1"># ds = ds.batch(self.p.batch_size)</span>
        <span class="c1"># self.dataset = ds.interleave(lambda *args:tf.data.Dataset.from_tensor_slices(args), num_threads, 1, num_threads)</span>

        <span class="c1"># create model based on user input</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">model_api</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># setup callbacks for nice progress bars and saving every now and then</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>

        <span class="c1"># create loss based on user input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">loss</span>

        <span class="c1"># choose optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>

        <span class="c1"># compile model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span>
        <span class="p">)</span>

        <span class="c1"># do this if tensorboard is true.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_images</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># get the output from model summary.</span>
            <span class="k">with</span> <span class="n">Capturing</span><span class="p">()</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span> <span class="o">+</span> <span class="s2">&quot;/model_summary.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">plot_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="n">to_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span> <span class="o">+</span> <span class="s2">&quot;/model_summary.png&quot;</span><span class="p">,</span>
                <span class="n">show_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;LR&quot;</span><span class="p">,</span>
                <span class="n">expand_nested</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Saved a text-summary of the model and an image in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">,</span>
                <span class="s2">&quot;as specified in &#39;main_path&#39; in the parameters.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># sets up the tb callback to plot the model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tb_callback</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">,</span> <span class="n">write_graph</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tb_callback</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autoencoder._setup_callbacks"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder._setup_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets up a list with callbacks to be passed to self.model.fit()&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CheckpointSaver</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span> <span class="o">=</span> <span class="n">TensorboardWriteBool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span><span class="p">)</span>
            <span class="n">file_writer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="n">create_file_writer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span> <span class="o">+</span> <span class="s2">&quot;/train&quot;</span><span class="p">)</span>
            <span class="n">file_writer</span><span class="o">.</span><span class="n">set_as_default</span><span class="p">()</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">summary</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Parameters Summary for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># callbacks.append(self.tb_callback)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Autoencoder.from_checkpoint"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.from_checkpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_checkpoint</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">checkpoint_path</span><span class="p">,</span>
        <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">overwrite_tensorboard_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstructs the class from a checkpoint.</span>

<span class="sd">        Args:</span>
<span class="sd">            Checkpoint path (str): The path to the checkpoint. Most models are saved in parts (encoder, decoder)</span>
<span class="sd">                and thus the provided path often needs a wildcard (*). The `save()` method of this class prints</span>
<span class="sd">                a string with which the model can be reloaded.</span>
<span class="sd">            read_only (bool, optional): Whether to reload the model in read_only mode (True) or allow the `Autoencoder`</span>
<span class="sd">                class to write to disk (False). This option might collide with the tensorboard Parameter in the</span>
<span class="sd">                respective parameters.json file in the maith_path. Defaults to True.</span>
<span class="sd">            overwrite_tensorboard_bool (bool, optional): Whether to overwrite the tensorboard Parameter while reloading</span>
<span class="sd">                the class. This can be set to True to set the tensorboard parameter False and allow read_only.</span>
<span class="sd">                Defaults to False.</span>

<span class="sd">        Raises:</span>
<span class="sd">            BadError: When read_only is True, overwrite_tensorboard_bool is False and the reloaded parameters</span>
<span class="sd">                have tensorboard set to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Autoencoder: Encodermap `Autoencoder` class.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">load_model</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">checkpoint_path</span><span class="p">,</span> <span class="n">read_only</span><span class="p">,</span> <span class="n">overwrite_tensorboard_bool</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span>
        <span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tf.keras.models.Model: The tf.keras.Model model used for training.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span>

    <span class="nd">@model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sets self.model according to `model_api` argument in self.parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;functional&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">gen_functional_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;sequential&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">gen_sequential_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sparse</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;No custom API currently supported&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;API argument needs to be one of `functional`, `sequential`, `custom`. You provided &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">encoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tf.keras.models.Model: Encoder part of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">encoder_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tf.keras.models.Model: Decoder part of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model</span><span class="o">.</span><span class="n">decoder_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(Union[list, string, function]): A list of loss functions passed to the model when it is compiled.</span>
<span class="sd">        When the main Autoencoder class is used and parameters.loss is &#39;emap_cost&#39; this list is comprised of</span>
<span class="sd">        center_cost, regularization_cost, auto_cost. When the EncoderMap sub-class is used and parameters.loss is</span>
<span class="sd">        &#39;emap_cost&#39; distance_cost is added to the list. When parameters.loss is not &#39;emap_cost&#39;, the loss can either</span>
<span class="sd">        be a string (&#39;mse&#39;), or a function, that both are acceptable arguments for loss, when a keras model</span>
<span class="sd">        is compiled.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span>

    <span class="nd">@loss</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sets self.loss according to `loss` in self.parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;reconstruction_loss&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="n">reconstruction_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;emap_cost&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auto_loss</span> <span class="o">=</span> <span class="n">auto_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span> <span class="o">=</span> <span class="n">regularization_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span> <span class="o">=</span> <span class="n">center_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">auto_loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;mse&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="s2">&quot;mse&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;loss argument needs to be `reconstruction_loss`, `mse` or `emap_cost`. You provided &#39;</span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="Autoencoder.train"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Starts the training of the model.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">training</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batched</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">training</span> <span class="o">==</span> <span class="s2">&quot;custom&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batched</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">training</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_images</span><span class="p">:</span>
                <span class="c1"># get the old backend because the Tensorboard Images callback will set &#39;Agg&#39;</span>
                <span class="n">old_backend</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">get_backend</span><span class="p">()</span>
            <span class="c1"># start_time = time.perf_counter()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span>
                <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                <span class="n">epochs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">n_steps</span><span class="p">,</span>
                <span class="n">steps_per_epoch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">callbacks</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># print(&quot;Execution time:&quot;, time.perf_counter() - start_time)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;training argument needs to be `auto` or `custom`. You provided &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">n_steps</span><span class="p">)</span>
        <span class="c1"># reset the backend.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_images</span><span class="p">:</span>
            <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">old_backend</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autoencoder.add_images_to_tensorboard"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.add_images_to_tensorboard">[docs]</a>    <span class="k">def</span> <span class="nf">add_images_to_tensorboard</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">image_step</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">scatter_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">},</span>
        <span class="n">hist_kws</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;bins&quot;</span><span class="p">:</span> <span class="mi">50</span><span class="p">},</span>
        <span class="n">additional_fns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">when</span><span class="o">=</span><span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds images to Tensorboard using the data in data and the ids in ids.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (Union[np.ndarray, list, None], optional): The input-data will be passed through the encoder</span>
<span class="sd">                part of the autoencoder. If None is provided a set of 10000 points from the provided</span>
<span class="sd">                train data will be taken. A list is needed for the functional API of the ADCAutoencoder, that takes</span>
<span class="sd">                a list of [angles, dihedrals, side_dihedrals]. Defaults to None.</span>
<span class="sd">            image_step (Union[int, None], optional): The interval in which to plot images to tensorboard.</span>
<span class="sd">                If None is provided, the update step will be the same as parameters.summary_step. Defaults to None.</span>
<span class="sd">            scatter_kws (dict, optional): A dict with items that matplotlib.pyplot.scatter() will accept. Defaults to</span>
<span class="sd">                {&#39;s&#39;: 20}, which sets an appropriate size of scatter points for the size of datasets encodermap is</span>
<span class="sd">                usually used for.</span>
<span class="sd">            hist_kws (dict, optional): A dict with items that matplotlib.pyplot.scatter() will accept. You can</span>
<span class="sd">                choose a colorbar here. Defaults to {&#39;bins&#39;: 50} which sets an appropriate bin count  for the</span>
<span class="sd">                size of datasets encodermap is usually used for.</span>
<span class="sd">            additional_fns (Union[list, None], optional): A list of functions that will accept the low-dimensional</span>
<span class="sd">                output of the autoencoder&#39;s latent/bottleneck layer and return a tf.Tensor that can be logged</span>
<span class="sd">                by `tf.summary.image()`. See the notebook &#39;writing_custom_images_to_tensorboard.ipynb&#39; in</span>
<span class="sd">                tutorials/notebooks_customization for more info. If None is provided no additional functions will be</span>
<span class="sd">                used to plot to tensorboard. Defaults to None.</span>
<span class="sd">            when (str, optional): When to log the images can be either &#39;batch&#39;, then the images will be logged after</span>
<span class="sd">                every step during training, or &#39;epoch&#39;, then only after every image_step epoch the images will be</span>
<span class="sd">                written. Defaults to &#39;epoch&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Nothing is written to Tensorboard for this Model. Please change parameters.tensorboard to True.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">image_step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">summary_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log_images</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># make a dataset for images</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mi">10000</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)))</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">data</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Provided data has wrong type. Train data in this class is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">)</span><span class="si">}</span><span class="s2">, provided data is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">ImageCallback</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">image_step</span><span class="p">,</span>
                <span class="n">scatter_kws</span><span class="o">=</span><span class="n">scatter_kws</span><span class="p">,</span>
                <span class="n">hist_kws</span><span class="o">=</span><span class="n">hist_kws</span><span class="p">,</span>
                <span class="n">additional_fns</span><span class="o">=</span><span class="n">additional_fns</span><span class="p">,</span>
                <span class="n">when</span><span class="o">=</span><span class="n">when</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">)):</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Logging images with </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">-shaped data every </span><span class="si">{</span><span class="n">image_step</span><span class="si">}</span><span class="s2"> epochs to Tensorboard at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Logging images with </span><span class="si">{</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">data</span><span class="p">]</span><span class="si">}</span><span class="s2">-shaped data every </span><span class="si">{</span><span class="n">image_step</span><span class="si">}</span><span class="s2"> epochs to Tensorboard at </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Autoencoder.plot_network"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.plot_network">[docs]</a>    <span class="k">def</span> <span class="nf">plot_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tries to plot the network using pydot, pydotplus and graphviz. Doesn&#39;t raise an exception if plotting is</span>
<span class="sd">        not possible.</span>

<span class="sd">        Note:</span>
<span class="sd">            Refer to this guide to install these programs:</span>
<span class="sd">            https://stackoverflow.com/questions/47605558/importerror-failed-to-import-pydot-you-must-install-pydot-and-graphviz-for-py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">plot_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Autoencoder.encode"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls encoder part of model.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (Union[np.ndarray, None], optional): The data to be passed top the encoder part.</span>
<span class="sd">                Can be either numpy ndarray or None. If None is provided a set of 10000 points from the provided</span>
<span class="sd">                train data will be taken. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: The output from the bottlenack/latent layer.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s2">&quot;encoder&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="s2">&quot;encoder_model&quot;</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">encoder_model</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Autoencoder.generate"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Duplication of decode.</span>

<span class="sd">        In Autoencoder and EncoderMap this method is equivalent to `decode()`. In AngleDihedralCartesianAutoencoder</span>
<span class="sd">        this method will be overwritten to produce output molecular conformations.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The data to be passed to the decoder part of the model. Make sure that the</span>
<span class="sd">                shape of the data matches the number of neurons in the latent space.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Oue output from the decoder part.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autoencoder.decode"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.decode">[docs]</a>    <span class="k">def</span> <span class="nf">decode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls the decoder part of the model.</span>

<span class="sd">        AngleDihedralCartesianAutoencoder will, like the other two classes&#39; output a tuple of data.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray):  The data to be passed to the decoder part of the model. Make sure that the</span>
<span class="sd">                shape of the data matches the number of neurons in the latent space.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: Oue output from the decoder part.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Autoencoder.save"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the model to the current path defined in `parameters.main_path`.</span>

<span class="sd">        Args:</span>
<span class="sd">            step (Union[int, None], optional): Does not actually save the model at the given training step, but rather</span>
<span class="sd">                changes the string used for saving the model from an datetime format to another.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span><span class="p">:</span>
            <span class="n">save_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span></div>

<div class="viewcode-block" id="Autoencoder.close"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.Autoencoder.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clears the current keras backend and frees up resources.&quot;&quot;&quot;</span>
        <span class="c1"># clear old sessions</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">clear_session</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="EncoderMap"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.EncoderMap">[docs]</a><span class="k">class</span> <span class="nc">EncoderMap</span><span class="p">(</span><span class="n">Autoencoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete copy of Autoencoder class but uses additional distance cost</span>
<span class="sd">    scaled by the SketchMap sigmoid params&quot;&quot;&quot;</span>

<div class="viewcode-block" id="EncoderMap.from_checkpoint"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.EncoderMap.from_checkpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_checkpoint</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">checkpoint_path</span><span class="p">,</span>
        <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">overwrite_tensorboard_bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstructs the model from a checkpoint.&quot;&quot;&quot;</span>
        <span class="c1"># Is this classmethod necessary? We need to make sure the class knows all losses.</span>
        <span class="c1"># And I don&#39;t know if the parent class calls the correct loss.setter</span>
        <span class="k">return</span> <span class="n">load_model</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">checkpoint_path</span><span class="p">,</span> <span class="n">read_only</span><span class="p">,</span> <span class="n">overwrite_tensorboard_bool</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span>
        <span class="p">)</span></div>

    <span class="nd">@Autoencoder</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;reconstruction_loss&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="n">reconstruction_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;emap_cost&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auto_loss</span> <span class="o">=</span> <span class="n">auto_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span> <span class="o">=</span> <span class="n">regularization_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span> <span class="o">=</span> <span class="n">center_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="c1"># this cost is new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">distance_loss</span> <span class="o">=</span> <span class="n">distance_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">auto_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_loss</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;mse&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="s2">&quot;mse&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;loss argument needs to be `reconstruction_loss`, `mse` or `emap_cost`. You provided &#39;</span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="DihedralEncoderMap"><a class="viewcode-back" href="../../../encodermap.autoencoder.html#encodermap.DihedralEncoderMap">[docs]</a><span class="k">class</span> <span class="nc">DihedralEncoderMap</span><span class="p">(</span><span class="n">EncoderMap</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Similar to the `EncoderMap` class, but overwrites the `generate` method.</span>

<span class="sd">    Using this class, instead of tbe `EncoderMap` class, the `generate` method,</span>
<span class="sd">    needs an additional argument: `top`, which should be a topology file. This</span>
<span class="sd">    topology will be used as a base on which the dihedrals of the `decode`</span>
<span class="sd">    method are applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DihedralEncoderMap.generate"><a class="viewcode-back" href="../../../encodermap.autoencoder.html#encodermap.DihedralEncoderMap.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">top</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrites `EncoderMap`&#39;s generate method and actually does backmapping if a list of dihedrals is</span>
<span class="sd">        provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): The low-dimensional/latent/bottleneck data. A ndim==2 numpy array with xy coordinates</span>
<span class="sd">                of points in latent space.</span>
<span class="sd">            top (str): Topology file for this run of EncoderMap (can be .pdb, .gro, .. etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            MDAnalysis.Universe: The topology with the provided backbone torsions.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; # get some time-resolved pdb files</span>
<span class="sd">            &gt;&gt;&gt; import requests</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; pdb_link = &#39;https://files.rcsb.org/view/1YUF.pdb&#39;</span>
<span class="sd">            &gt;&gt;&gt; contents = requests.get(pdb_link).text</span>
<span class="sd">            &gt;&gt;&gt; print(contents.splitlines()[0]) # doctest: +SKIP</span>
<span class="sd">            HEADER    GROWTH FACTOR                           01-APR-96   1YUF</span>
<span class="sd">            &gt;&gt;&gt; # fake a file with stringio</span>
<span class="sd">            &gt;&gt;&gt; from io import StringIO</span>
<span class="sd">            &gt;&gt;&gt; import MDAnalysis as mda</span>
<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; file = StringIO(contents)</span>
<span class="sd">            &gt;&gt;&gt; # pass it to MDAnalysis</span>
<span class="sd">            &gt;&gt;&gt; u = mda.Universe(file, format=&#39;PDB&#39;)</span>
<span class="sd">            &gt;&gt;&gt; print(u)</span>
<span class="sd">            &lt;Universe with 720 atoms&gt;</span>
<span class="sd">            &gt;&gt;&gt; # select the atomgroups</span>
<span class="sd">            &gt;&gt;&gt; ags = [*[res.psi_selection() for res in u.residues],</span>
<span class="sd">            ...        *[res.omega_selection() for res in u.residues],</span>
<span class="sd">            ...        *[res.phi_selection() for res in u.residues]</span>
<span class="sd">            ...        ]</span>
<span class="sd">            &gt;&gt;&gt; # filter Nones</span>
<span class="sd">            &gt;&gt;&gt; ags = list(filter(lambda x: False if x is None else True, ags))</span>
<span class="sd">            &gt;&gt;&gt; print(ags[0][0]) # doctest: +SKIP</span>
<span class="sd">            &lt;Atom 3: C of type C of resname VAL, resid 1 and segid A and altLoc &gt;</span>
<span class="sd">            &gt;&gt;&gt; # Run dihedral Angles</span>
<span class="sd">            &gt;&gt;&gt; from MDAnalysis.analysis.dihedrals import Dihedral</span>
<span class="sd">            &gt;&gt;&gt; R = np.deg2rad(Dihedral(ags).run().results.angles)</span>
<span class="sd">            &gt;&gt;&gt; print(R.shape)</span>
<span class="sd">            (16, 147)</span>
<span class="sd">            &gt;&gt;&gt; # import EncoderMap and define parameters</span>
<span class="sd">            &gt;&gt;&gt; from encodermap.autoencoder import DihedralEncoderMap</span>
<span class="sd">            &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">            &gt;&gt;&gt; parameters = em.Parameters(</span>
<span class="sd">            ... dist_sig_parameters = (4.5, 12, 6, 1, 2, 6),</span>
<span class="sd">            ... periodicity = 2*np.pi,</span>
<span class="sd">            ... l2_reg_constant = 10.0,</span>
<span class="sd">            ... summary_step = 5,</span>
<span class="sd">            ... tensorboard = False,</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; e_map = DihedralEncoderMap(parameters, R, read_only=True)</span>
<span class="sd">            &gt;&gt;&gt; print(e_map.__class__.__name__)</span>
<span class="sd">            DihedralEncoderMap</span>
<span class="sd">            &gt;&gt;&gt; # get some low-dimensional data</span>
<span class="sd">            &gt;&gt;&gt; lowd = np.random.random((100, 2))</span>
<span class="sd">            &gt;&gt;&gt; # use the generate method to get a new MDAnalysis universe</span>
<span class="sd">            &gt;&gt;&gt; # but first remove the time resolution</span>
<span class="sd">            &gt;&gt;&gt; file = StringIO(contents.split(&#39;MODEL        2&#39;)[0])</span>
<span class="sd">            &gt;&gt;&gt; new = e_map.generate(lowd, file)</span>
<span class="sd">            &gt;&gt;&gt; print(new.trajectory.coordinate_array.shape)</span>
<span class="sd">            (100, 720, 3)</span>
<span class="sd">            &gt;&gt;&gt; # check whether frame 0 of u and new_u are different</span>
<span class="sd">            &gt;&gt;&gt; for ts in u.trajectory:</span>
<span class="sd">            ...     a1 = ts.positions</span>
<span class="sd">            ...     break</span>
<span class="sd">            &gt;&gt;&gt; print(np.array_equal(a1, new.trajectory.coordinate_array[0]))</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">dihedrals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dihedrals</span><span class="p">)</span>
        <span class="n">uni</span> <span class="o">=</span> <span class="n">dihedral_backmapping</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">uni</span></div></div>


<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap">[docs]</a><span class="k">class</span> <span class="nc">AngleDihedralCartesianEncoderMap</span><span class="p">(</span><span class="n">Autoencoder</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Different `__init__` method, than Autoencoder Class. Uses callbacks to tune-in cartesian cost.</span>

<span class="sd">    Overwritten methods: `_set_up_callbacks` and `generate`.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import encodermap as em</span>
<span class="sd">        &gt;&gt;&gt; # Load two trajectories</span>
<span class="sd">        &gt;&gt;&gt; xtcs = [&quot;tests/data/1am7_corrected_part1.xtc&quot;, &quot;tests/data/1am7_corrected_part2.xtc&quot;]</span>
<span class="sd">        &gt;&gt;&gt; tops = [&quot;tests/data/1am7_protein.pdb&quot;, &quot;tests/data/1am7_protein.pdb&quot;]</span>
<span class="sd">        &gt;&gt;&gt; trajs = em.load(xtcs, tops)</span>
<span class="sd">        &gt;&gt;&gt; print(trajs)</span>
<span class="sd">        encodermap.TrajEnsemble object. Current backend is no_load. Containing 2 trajs. Not containing any CVs.</span>
<span class="sd">        &gt;&gt;&gt; # load CVs</span>
<span class="sd">        &gt;&gt;&gt; # This step can be omitted. The AngleDihedralCartesianEncoderMap class automatically loads CVs</span>
<span class="sd">        &gt;&gt;&gt; trajs.load_CVs(&#39;all&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(trajs.CVs[&#39;central_cartesians&#39;].shape)</span>
<span class="sd">        (51, 474, 3)</span>
<span class="sd">        &gt;&gt;&gt; print(trajs.CVs[&#39;central_dihedrals&#39;].shape)</span>
<span class="sd">        (51, 471)</span>
<span class="sd">        &gt;&gt;&gt; # create some parameters</span>
<span class="sd">        &gt;&gt;&gt; p = em.ADCParameters(periodicity=360, use_backbone_angles=True, use_sidechains=True,</span>
<span class="sd">        ...                      cartesian_cost_scale_soft_start=(6, 12))</span>
<span class="sd">        &gt;&gt;&gt; # Standard is functional model, as it offers more flexibility</span>
<span class="sd">        &gt;&gt;&gt; print(p.model_api)</span>
<span class="sd">        functional</span>
<span class="sd">        &gt;&gt;&gt; print(p.distance_cost_scale)</span>
<span class="sd">        None</span>
<span class="sd">        &gt;&gt;&gt; # Instantiate the class</span>
<span class="sd">        &gt;&gt;&gt; e_map = em.AngleDihedralCartesianEncoderMap(trajs, p, read_only=True)</span>
<span class="sd">        &gt;&gt;&gt; # dataset contains these inputs:</span>
<span class="sd">        &gt;&gt;&gt; # central_angles, central_dihedrals, central_cartesians, central_distances, sidechain_dihedrals</span>
<span class="sd">        &gt;&gt;&gt; print(e_map.dataset)</span>
<span class="sd">        &lt;BatchDataset element_spec=(TensorSpec(shape=(None, 472), dtype=tf.float32, name=None), TensorSpec(shape=(None, 471), dtype=tf.float32, name=None), TensorSpec(shape=(None, 474, 3), dtype=tf.float32, name=None), TensorSpec(shape=(None, 473), dtype=tf.float32, name=None), TensorSpec(shape=(None, 316), dtype=tf.float32, name=None))&gt;</span>
<span class="sd">        &gt;&gt;&gt; # output from the model contains the following data:</span>
<span class="sd">        &gt;&gt;&gt; # out_angles, out_dihedrals, back_cartesians, pairwise_distances of inp cartesians, pairwise of back-mapped cartesians, out_side_dihedrals</span>
<span class="sd">        &gt;&gt;&gt; for data in e_map.dataset.take(1):</span>
<span class="sd">        ...     pass</span>
<span class="sd">        &gt;&gt;&gt; out = e_map.model(data)</span>
<span class="sd">        &gt;&gt;&gt; print([i.shape for i in out])</span>
<span class="sd">        [TensorShape([256, 472]), TensorShape([256, 471]), TensorShape([256, 474, 3]), TensorShape([256, 112101]), TensorShape([256, 112101]), TensorShape([256, 316])]</span>
<span class="sd">        &gt;&gt;&gt; # get output of latent space by providing central_angles, central_dihedrals, sidehcain_dihedrals</span>
<span class="sd">        &gt;&gt;&gt; latent = e_map.encoder([data[0], data[1], data[-1]])</span>
<span class="sd">        &gt;&gt;&gt; print(latent.shape)</span>
<span class="sd">        (256, 2)</span>
<span class="sd">        &gt;&gt;&gt; # Rebuild central_angles, central_dihedrals and sidechain_angles from latent</span>
<span class="sd">        &gt;&gt;&gt; dih, ang, side_dih = e_map.decode(latent)</span>
<span class="sd">        &gt;&gt;&gt; print(dih.shape, ang.shape, side_dih.shape)</span>
<span class="sd">        (256, 472) (256, 471) (256, 316)</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.__init__"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">trajs</span><span class="p">:</span> <span class="n">encodermap</span><span class="o">.</span><span class="n">TrajEnsemble</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">encodermap</span><span class="o">.</span><span class="n">ADCParameters</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">model</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">tensorflow</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">read_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">cartesian_loss_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">mdtraj</span><span class="o">.</span><span class="n">Topology</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate the `AngleDihedralCartesianEncoderMap` class.</span>

<span class="sd">        Args:</span>
<span class="sd">            trajs (em.TrajEnsemble): The trajectories to be used as input. If trajs contain no CVs, correct CVs will be loaded.</span>
<span class="sd">            parameters (Optional[em.ACDParameters]): The parameters for the current run. Can be set to None and the</span>
<span class="sd">                default parameters will be used. Defaults to None.</span>
<span class="sd">            model (Optional[tf.keras.models.Model]): The keras model to use. You can provide your own model</span>
<span class="sd">                with this argument. If set to None, the model will be built to the specifications of parameters using</span>
<span class="sd">                either the functional or sequential API. Defaults to None</span>
<span class="sd">            read_only (bool): Whether to write anything to disk (False) or not (True). Defaults to False.</span>
<span class="sd">            cartesian_loss_step (int, optional): For loading and re-training the model. The cartesian_distance_loss</span>
<span class="sd">                is tuned in step-wise. For this the start step of the training needs to be accounted for. If the</span>
<span class="sd">                scale of the cartesian loss should increase from epoch 6 to epoch 12 and the model is saved at</span>
<span class="sd">                epoch 9, this argument should also be set to 9, to continue training with the correct scaling</span>
<span class="sd">                factor. Defaults to 0.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># parameters</span>
        <span class="k">if</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">ADCParameters</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">parameters</span>

        <span class="c1"># seed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">set_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># read_only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span> <span class="o">=</span> <span class="n">read_only</span>

        <span class="c1"># will be saved and overwritten when loading.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss_step</span> <span class="o">=</span> <span class="n">cartesian_loss_step</span>

        <span class="c1"># save params and create dir</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;Output files are saved to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">),</span>
                <span class="s2">&quot;as defined in &#39;main_path&#39; in the parameters.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># check whether Tensorboard and Read-Only makes Sense</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">BadError</span><span class="p">(</span>
                <span class="s2">&quot;Setting tensorboard and read_only True is not possible. Tensorboard will always write to disk.&quot;</span>
                <span class="s2">&quot; If you received this Error while loading a trained model, pass read_only=False as an argument&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; or set overwrite_tensorboard_bool True to overwrite the tensorboard parameter.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># clear old sessions</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">clear_session</span><span class="p">()</span>

        <span class="c1"># get the CVs:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="n">TrajEnsemble</span><span class="p">([</span><span class="n">trajs</span><span class="p">],</span> <span class="p">[</span><span class="n">top</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span> <span class="o">=</span> <span class="n">trajs</span>

        <span class="c1"># load missing values</span>
        <span class="n">should_be</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_cartesians&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                <span class="s2">&quot;central_distances&quot;</span><span class="p">,</span>
                <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs_in_file</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Write a tf.data.Dataset.from_generator function in enocdermap.data using the data from the netCDF files&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">should_be</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">missing</span> <span class="o">!=</span> <span class="p">[]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;loading missing values: &quot;</span><span class="p">,</span> <span class="n">missing</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">load_CVs</span><span class="p">(</span><span class="n">missing</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">load_CVs</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">should_be</span><span class="p">),</span> <span class="n">ensemble</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">should_be</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">BadError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Could not load CVs. Should be </span><span class="si">{</span><span class="n">should_be</span><span class="si">}</span><span class="s2">, but currenlty only </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> are loaded&quot;</span>
            <span class="p">)</span>

        <span class="c1"># define inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">train_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_train_data_from_trajs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="p">)</span>

        <span class="c1"># create dataset</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_cartesians&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_distances&quot;</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;side_dihedrals&quot;</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span>
            <span class="n">buffer_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_cartesians&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">reshuffle_each_iteration</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">repeat</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">batch_size</span><span class="p">)</span>

        <span class="c1"># ToDo: Make training faster with Autotune, XLA (jit) compilation, DataRecords</span>
        <span class="c1"># self.dataset = self.dataset.prefetch(self.p.batch_size * 4)</span>
        <span class="c1"># self.dataset = self.dataset.interleave(num_parallel_calls=tf.data.experimental.AUTOTUNE)</span>
        <span class="c1"># num_batches = 20</span>
        <span class="c1"># num_threads = 8</span>
        <span class="c1"># ds = tf.data.Dataset.from_tensors(self.train_data).repeat(self.p.batch_size * num_batches)</span>
        <span class="c1"># ds = ds.batch(self.p.batch_size)</span>
        <span class="c1"># self.dataset = ds.interleave(lambda *args:tf.data.Dataset.from_tensor_slices(args), num_threads, 1, num_threads)</span>

        <span class="c1"># create model based on user input</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">model_api</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model</span> <span class="o">=</span> <span class="n">model</span>

        <span class="c1"># setup callbacks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>

        <span class="c1"># create loss based on user input</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">loss</span>

        <span class="c1"># choose optimizer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">optimizers</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">)</span>

        <span class="c1"># compile model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">optimizer</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">metrics</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metrics</span>
        <span class="p">)</span>

        <span class="c1"># do this if tensorboard is true.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">tensorboard</span><span class="p">:</span>
            <span class="c1"># print shapes</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;input shapes are:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inp_CV_data</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="c1"># set _log_images to False to fix the backend after training</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log_images</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># get the output from model summary.</span>
            <span class="k">with</span> <span class="n">Capturing</span><span class="p">()</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">summary</span><span class="p">()</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span> <span class="o">+</span> <span class="s2">&quot;/model_summary.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">plot_model</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                    <span class="n">to_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span> <span class="o">+</span> <span class="s2">&quot;/model_summary.png&quot;</span><span class="p">,</span>
                    <span class="n">show_shapes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">rankdir</span><span class="o">=</span><span class="s2">&quot;TB&quot;</span><span class="p">,</span>
                    <span class="n">expand_nested</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;saving image gave error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># todo: add image of cat</span>
            <span class="c1"># from ..parameters import parameters as _p</span>
            <span class="c1"># cat_image = os.path.split(os.path.split(os.path.split(_p.__file__)[0])[0])[0] + &#39;/pic/priscilla-du-preez-8NXmaXg5xL0-unsplash.jpg&#39;</span>
            <span class="c1"># image = plt.imread(cat_image)</span>
            <span class="c1"># plt.imshow(image)</span>
            <span class="c1"># print(cat_image)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Saved a text-summary of the model and an image in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">,</span>
                <span class="s2">&quot;as specified in &#39;main_path&#39; in the parameters.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># sets up the tb callback to plot the model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tb_callback</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">TensorBoard</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">,</span> <span class="n">write_graph</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tb_callback</span><span class="o">.</span><span class="n">set_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.get_train_data_from_trajs"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.get_train_data_from_trajs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_train_data_from_trajs</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;CVs&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
            <span class="n">inp_CV_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">sparse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sparse</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Input contains nans. Using sparse network.&quot;</span><span class="p">)</span>
            <span class="n">inp_CV_data</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">key</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>

            <span class="c1"># squeeze, if xarray is provided</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inp_CV_data</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>
                <span class="n">inp_CV_data</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inp_CV_data</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">inp_CV_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">v</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;central_cartesians&quot;</span><span class="p">:</span>
                        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span>
                    <span class="n">dense_shape</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">)]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">sparse_tensor</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dense_shape</span><span class="p">)</span>
                    <span class="n">inp_CV_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse_tensor</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
            <span class="n">train_data</span> <span class="o">=</span> <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
            <span class="n">train_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">],</span>
                <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">model_api</span> <span class="o">==</span> <span class="s2">&quot;sequential&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">train_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
            <span class="n">train_data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">],</span>
                <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">],</span>
                <span class="n">inp_CV_data</span><span class="p">[</span><span class="s2">&quot;side_dihedrals&quot;</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">model_api</span> <span class="o">==</span> <span class="s2">&quot;sequential&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sparse</span><span class="p">:</span>
                <span class="n">train_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                <span class="s2">&quot;Cannot train model with central dihedrals and side dihedrals only. Backbone angles are required.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># some checks for the length of the train data</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">model_api</span> <span class="o">==</span> <span class="s2">&quot;functional&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">train_data</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">SparseTensor</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>

        <span class="k">return</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">train_data</span><span class="p">,</span> <span class="n">inp_CV_data</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.from_checkpoint"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.from_checkpoint">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_checkpoint</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">trajs</span><span class="p">,</span> <span class="n">checkpoint_path</span><span class="p">,</span> <span class="n">read_only</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_tensorboard_bool</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstructs the model from a checkpoint.&quot;&quot;&quot;</span>
        <span class="c1"># Is this classmethod necessary? We need to make sure the class knows all losses.</span>
        <span class="c1"># And I don&#39;t know if the parent class calls the correct loss.setter</span>
        <span class="k">return</span> <span class="n">load_model</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">checkpoint_path</span><span class="p">,</span> <span class="n">read_only</span><span class="p">,</span> <span class="n">overwrite_tensorboard_bool</span><span class="p">,</span> <span class="n">trajs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap._setup_callbacks"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap._setup_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">_setup_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overwrites the parent class&#39; `_setup_callbacks` method.</span>

<span class="sd">        Due to the &#39;soft start&#39; of the cartesian cost, the `cartesiand_increase_callback`</span>
<span class="sd">        needs to be added to the list of callbacks.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_callbacks</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cartesian_cost_scale_soft_start</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_increase_callback</span> <span class="o">=</span> <span class="n">IncreaseCartesianCost</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">start_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss_step</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartesian_increase_callback</span><span class="p">)</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.save"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the model to the current path defined in `parameters.main_path`.</span>

<span class="sd">        Args:</span>
<span class="sd">            step (Optional[int]): Does not actually save the model at the given training step, but rather</span>
<span class="sd">                changes the string used for saving the model from an datetime format to another.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_only</span><span class="p">:</span>
            <span class="n">save_model</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
                <span class="n">current_step</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss_step</span><span class="p">,</span>
            <span class="p">)</span></div>

    <span class="nd">@Autoencoder</span><span class="o">.</span><span class="n">loss</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loss</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;reconstruction_loss&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="n">reconstruction_loss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;emap_cost&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_loss</span> <span class="o">=</span> <span class="n">dihedral_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">angle_loss</span> <span class="o">=</span> <span class="n">angle_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">cartesian_cost_scale_soft_start</span> <span class="o">!=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss</span> <span class="o">=</span> <span class="n">cartesian_loss</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_increase_callback</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss</span> <span class="o">=</span> <span class="n">cartesian_loss</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">distance_loss</span> <span class="o">=</span> <span class="n">distance_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_distance_loss</span> <span class="o">=</span> <span class="n">cartesian_distance_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span> <span class="o">=</span> <span class="n">center_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span> <span class="o">=</span> <span class="n">regularization_loss</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dihedral_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">angle_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">distance_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_distance_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">center_loss</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">regularization_loss</span><span class="p">,</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">side_dihedral_loss</span> <span class="o">=</span> <span class="n">side_dihedral_loss</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tensorboard_write_bool</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">side_dihedral_loss</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loss</span> <span class="o">==</span> <span class="s2">&quot;mse&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_loss</span> <span class="o">=</span> <span class="s2">&quot;mse&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;loss argument needs to be `reconstruction_loss`, `mse` or `emap_cost`. You provided &#39;</span><span class="si">{</span><span class="n">loss</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.train"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.train">[docs]</a>    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overrides the parent class&#39; `train` method.</span>

<span class="sd">        After the training is finished, an additional file is written to disk,</span>
<span class="sd">        which saves the current epoch. In the event that training will continue,</span>
<span class="sd">        the current state of the soft-start cartesian cost is read from that file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss_step</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">n_steps</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">main_path</span><span class="si">}</span><span class="s2">/saved_model_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">n_steps</span><span class="si">}</span><span class="s2">.model&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span> <span class="o">+</span> <span class="s2">&quot;_current_step.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cartesian_loss_step</span><span class="p">))</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.encode"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.encode">[docs]</a>    <span class="k">def</span> <span class="nf">encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;_traj_file&quot;</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_train_data_from_trajs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s2">&quot;_CVs&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;traj_files&quot;</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_train_data_from_trajs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="AngleDihedralCartesianEncoderMap.generate"><a class="viewcode-back" href="../../../reference/autoencoder_classes.html#encodermap.AngleDihedralCartesianEncoderMap.generate">[docs]</a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">top</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">mdtraj</span><span class="o">.</span><span class="n">Topology</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span> <span class="s2">&quot;mdanalysis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mdtraj&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">MDAnalysis</span><span class="o">.</span><span class="n">Universe</span><span class="p">,</span> <span class="n">mdtraj</span><span class="o">.</span><span class="n">Trajectory</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overrides the parent class&#39; `generate` method and builds a trajectory.</span>

<span class="sd">        Instead of just providing data to `decode` using the decoder part of the</span>
<span class="sd">        network, this method also takes a molecular topology as its `top`</span>
<span class="sd">        argument. This topology is then used to rebuild a time-resolved</span>
<span class="sd">        trajectory.</span>

<span class="sd">        Args:</span>
<span class="sd">            points (np.ndarray): The low-dimensional points from which the</span>
<span class="sd">                trajectory should be rebuilt.</span>
<span class="sd">            top (Optional[str, int, mdtraj.Topology]): The topology to be used for rebuilding the</span>
<span class="sd">                trajectory. This should be a string pointing towards a &lt;*.pdb,</span>
<span class="sd">                *.gro, *.h5&gt; file. Alternatively, None can be provided, in which</span>
<span class="sd">                case, the internal topology (`self.top`) of this class is used.</span>
<span class="sd">                Defaults to None.</span>
<span class="sd">            backend (str): Defines what MD python package to use, to build the</span>
<span class="sd">                trajectory and also what type this method returns, needs to be</span>
<span class="sd">                one of the following:</span>
<span class="sd">                * &quot;mdtraj&quot;</span>
<span class="sd">                * &quot;mdanalysis&quot;</span>

<span class="sd">        Returns:</span>
<span class="sd">            Union[mdtraj.Trajectory, MDAnalysis.universe]: The trajectory after</span>
<span class="sd">                applying the decoded structural information. The type of this</span>
<span class="sd">                depends on the chosen `backend` parameter.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the output this can be done regardless</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">top</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">top_files</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">top</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Please specify which topology you would like to use for generating &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;conformations. You can either provide a `str` to a topology file &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(file extension .pdb, .h5, .gro) on disk, or a `int` specifying the &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`SingleTraj` object in this class&#39; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">n_trajs</span><span class="si">}</span><span class="s2"> trajs, or &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;you can also specify a `mdtraj.Topology` object.&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span>
                <span class="k">if</span> <span class="n">top</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">top_files</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;Provided topology was not used to train Encodermap.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># get the output</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">dihedrals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">splits</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">splits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">splits</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">trajs</span><span class="o">.</span><span class="n">CVs</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="p">]</span>

                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">sidechain_dihedrals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span>
                            <span class="n">out</span><span class="p">,</span> <span class="n">splits</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">angles</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">sidechain_dihedrals</span> <span class="o">=</span> <span class="n">out</span>

            <span class="c1"># in this case we can just use any traj from self.trajs</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">top_files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">trajs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span>
                <span class="k">if</span> <span class="n">top</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">top_files</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;Provided topology was not used to train Encodermap.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">top_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="n">top</span><span class="p">]</span><span class="o">.</span><span class="n">traj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">top_</span><span class="o">.</span><span class="n">save_pdb</span><span class="p">(</span><span class="s2">&quot;/tmp/tmp.pdb&quot;</span><span class="p">)</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="s2">&quot;/tmp/tmp.pdb&quot;</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">mdtraj</span><span class="o">.</span><span class="n">Topology</span><span class="p">):</span>
                    <span class="n">top</span><span class="o">.</span><span class="n">save_pdb</span><span class="p">(</span><span class="s2">&quot;/tmp/tmp.pdb&quot;</span><span class="p">)</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="s2">&quot;/tmp/tmp.pdb&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Provided type for `top` must be `str`, `int`, or `mdtraj.Topology`, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;you provided </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">top</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># align the topology with the trajs in self.trajs</span>
                <span class="kn">from</span> <span class="nn">..loading</span> <span class="kn">import</span> <span class="n">features</span>
                <span class="kn">from</span> <span class="nn">..loading.featurizer</span> <span class="kn">import</span> <span class="n">UNDERSOCRE_MAPPING</span>

                <span class="n">UNDERSOCRE_MAPPING</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">UNDERSOCRE_MAPPING</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;CentralCartesians&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;CentralBondDistances&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;CentralAngles&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;CentralDihedrals&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;SideChainDihedrals&quot;</span><span class="p">,</span>
                <span class="p">]</span>

                <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_names</span><span class="p">:</span>
                    <span class="n">feature</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">feature</span><span class="p">)(</span><span class="n">top_</span><span class="o">.</span><span class="n">top</span><span class="p">,</span> <span class="n">generic_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">labels</span><span class="p">[</span><span class="n">UNDERSOCRE_MAPPING</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">name</span><span class="p">]]</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>

                <span class="n">return_values</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="s2">&quot;central_dihedrals&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;central_angles&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;side_dihedrals&quot;</span><span class="p">,</span>
                <span class="p">]</span>
                <span class="n">splits</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">return_values</span><span class="p">):</span>
                    <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_CVs</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="p">)</span>
                    <span class="n">splits</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span>

                <span class="c1"># split the output</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">out</span><span class="p">[:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">]]</span>
                    <span class="n">angles</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">][:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_backbone_angles</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">use_sidechains</span><span class="p">:</span>
                    <span class="n">dihedrals</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;central_dihedrals&quot;</span><span class="p">]]</span>
                    <span class="n">angles</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;central_angles&quot;</span><span class="p">]]</span>
                    <span class="n">sidechain_dihedrals</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">2</span><span class="p">][:,</span> <span class="n">splits</span><span class="p">[</span><span class="s2">&quot;side_dihedrals&quot;</span><span class="p">]]</span>

                <span class="c1"># if the backend is mdanalysis we need to save the pdb</span>
                <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;mdanalysis&quot;</span><span class="p">:</span>
                    <span class="n">top_</span><span class="o">.</span><span class="n">save_pdb</span><span class="p">(</span><span class="s2">&quot;/tmp/tmp.pdb&quot;</span><span class="p">)</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="s2">&quot;/tmp/tmp.pdb&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># in this case we need to use a traj, which topolgy matches top</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">traj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">trajs</span><span class="o">.</span><span class="n">itertrajs</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">traj</span><span class="o">.</span><span class="n">top</span> <span class="o">==</span> <span class="n">top_</span><span class="o">.</span><span class="n">top</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                            <span class="s2">&quot;Could not find a trajectory in self.trajs, &quot;</span>
                            <span class="s2">&quot;that matches the topology provided as `top`.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">traj</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>

        <span class="c1"># do the backmapping</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;mdanalysis&quot;</span><span class="p">:</span>
            <span class="n">uni</span> <span class="o">=</span> <span class="n">dihedral_backmapping</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">sidechains</span><span class="o">=</span><span class="n">sidechain_dihedrals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">uni</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;mdtraj&quot;</span><span class="p">:</span>
            <span class="n">traj</span> <span class="o">=</span> <span class="n">mdtraj_backmapping</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">dihedrals</span><span class="p">,</span> <span class="n">sidechain_dihedrals</span><span class="p">,</span> <span class="n">traj</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">traj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;backend must be &#39;mdtraj&#39; or &#39;mdanalysis&#39;, but you provided </span><span class="si">{</span><span class="n">backend</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div></div>
</pre></div>

            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2023, Kevin Sawade, Tobias Lemke.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  </body>
</html>