
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>encodermap.misc.transformations &#8212; encodermap 3.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/encodermap/misc/transformations';</script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">

  
  
  
  
  
  
  

  
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-light" alt="Logo image">
    <img src="../../../_static/logo_cube_300.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../getting_started/index.html">
                        Getting started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide_and_examples/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Changelog
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../getting_started/index.html">
                        Getting started
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../user_guide_and_examples/index.html">
                        User Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../reference/index.html">
                        API reference
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../../whatsnew/index.html">
                        Changelog
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://github.com/Ag-Peter/encodermap" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fa-brands fa-square-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
      </ul>
      </div>
      
    </div>
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <h1>Source code for encodermap.misc.transformations</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># encodermap/misc/transformations.py</span>

<span class="c1"># Copyright (c) 2006-2013, Christoph Gohlke</span>
<span class="c1"># Copyright (c) 2006-2013, The Regents of the University of California</span>
<span class="c1"># Produced at the Laboratory for Fluorescence Dynamics</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1">#</span>
<span class="c1"># * Redistributions of source code must retain the above copyright</span>
<span class="c1">#   notice, this list of conditions and the following disclaimer.</span>
<span class="c1"># * Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#   notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#   documentation and/or other materials provided with the distribution.</span>
<span class="c1"># * Neither the name of the copyright holders nor the names of any</span>
<span class="c1">#   contributors may be used to endorse or promote products derived</span>
<span class="c1">#   from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">&quot;&quot;&quot;Homogeneous Transformation Matrices and Quaternions.</span>

<span class="sd">A library for calculating 4x4 matrices for translating, rotating, reflecting,</span>
<span class="sd">scaling, shearing, projecting, orthogonalizing, and superimposing arrays of</span>
<span class="sd">3D homogeneous coordinates as well as for converting between rotation matrices,</span>
<span class="sd">Euler angles, and quaternions. Also includes an Arcball control object and</span>
<span class="sd">functions to decompose transformation matrices.</span>

<span class="sd">:Author:</span>
<span class="sd">  `Christoph Gohlke &lt;http://www.lfd.uci.edu/~gohlke/&gt;`_</span>

<span class="sd">:Organization:</span>
<span class="sd">  Laboratory for Fluorescence Dynamics, University of California, Irvine</span>

<span class="sd">:Version: 2013.06.29</span>

<span class="sd">Requirements</span>
<span class="sd">------------</span>
<span class="sd">* `CPython 2.7 or 3.3 &lt;http://www.python.org&gt;`_</span>
<span class="sd">* `Numpy 1.7 &lt;http://www.numpy.org&gt;`_</span>
<span class="sd">* `Transformations.c 2013.01.18 &lt;http://www.lfd.uci.edu/~gohlke/&gt;`_</span>
<span class="sd">  (recommended for speedup of some functions)</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">The API is not stable yet and is expected to change between revisions.</span>

<span class="sd">This Python code is not optimized for speed. Refer to the transformations.c</span>
<span class="sd">module for a faster implementation of some functions.</span>

<span class="sd">Documentation in HTML format can be generated with epydoc.</span>

<span class="sd">Matrices (M) can be inverted using numpy.linalg.inv(M), be concatenated using</span>
<span class="sd">numpy.dot(M0, M1), or transform homogeneous coordinate arrays (v) using</span>
<span class="sd">numpy.dot(M, v) for shape (4, \*) column vectors, respectively</span>
<span class="sd">numpy.dot(v, M.T) for shape (\*, 4) row vectors (&quot;array of points&quot;).</span>

<span class="sd">This module follows the &quot;column vectors on the right&quot; and &quot;row major storage&quot;</span>
<span class="sd">(C contiguous) conventions. The translation components are in the right column</span>
<span class="sd">of the transformation matrix, i.e. M[:3, 3].</span>
<span class="sd">The transpose of the transformation matrices may have to be used to interface</span>
<span class="sd">with other graphics systems, e.g. with OpenGL&#39;s glMultMatrixd(). See also [16].</span>

<span class="sd">Calculations are carried out with numpy.float64 precision.</span>

<span class="sd">Vector, point, quaternion, and matrix function arguments are expected to be</span>
<span class="sd">&quot;array like&quot;, i.e. tuple, list, or numpy arrays.</span>

<span class="sd">Return types are numpy arrays unless specified otherwise.</span>

<span class="sd">Angles are in radians unless specified otherwise.</span>

<span class="sd">Quaternions w+ix+jy+kz are represented as [w, x, y, z].</span>

<span class="sd">A triple of Euler angles can be applied/interpreted in 24 ways, which can</span>
<span class="sd">be specified using a 4 character string or encoded 4-tuple:</span>

<span class="sd">  *Axes 4-string*: e.g. &#39;sxyz&#39; or &#39;ryxy&#39;</span>

<span class="sd">  - first character : rotations are applied to &#39;s&#39;tatic or &#39;r&#39;otating frame</span>
<span class="sd">  - remaining characters : successive rotation axis &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;</span>

<span class="sd">  *Axes 4-tuple*: e.g. (0, 0, 0, 0) or (1, 1, 1, 1)</span>

<span class="sd">  - inner axis: code of axis (&#39;x&#39;:0, &#39;y&#39;:1, &#39;z&#39;:2) of rightmost matrix.</span>
<span class="sd">  - parity : even (0) if inner axis &#39;x&#39; is followed by &#39;y&#39;, &#39;y&#39; is followed</span>
<span class="sd">    by &#39;z&#39;, or &#39;z&#39; is followed by &#39;x&#39;. Otherwise odd (1).</span>
<span class="sd">  - repetition : first and last axis are same (1) or different (0).</span>
<span class="sd">  - frame : rotations are applied to static (0) or rotating (1) frame.</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">(1)  Matrices and transformations. Ronald Goldman.</span>
<span class="sd">     In &quot;Graphics Gems I&quot;, pp 472-475. Morgan Kaufmann, 1990.</span>
<span class="sd">(2)  More matrices and transformations: shear and pseudo-perspective.</span>
<span class="sd">     Ronald Goldman. In &quot;Graphics Gems II&quot;, pp 320-323. Morgan Kaufmann, 1991.</span>
<span class="sd">(3)  Decomposing a matrix into simple transformations. Spencer Thomas.</span>
<span class="sd">     In &quot;Graphics Gems II&quot;, pp 320-323. Morgan Kaufmann, 1991.</span>
<span class="sd">(4)  Recovering the data from the transformation matrix. Ronald Goldman.</span>
<span class="sd">     In &quot;Graphics Gems II&quot;, pp 324-331. Morgan Kaufmann, 1991.</span>
<span class="sd">(5)  Euler angle conversion. Ken Shoemake.</span>
<span class="sd">     In &quot;Graphics Gems IV&quot;, pp 222-229. Morgan Kaufmann, 1994.</span>
<span class="sd">(6)  Arcball rotation control. Ken Shoemake.</span>
<span class="sd">     In &quot;Graphics Gems IV&quot;, pp 175-192. Morgan Kaufmann, 1994.</span>
<span class="sd">(7)  Representing attitude: Euler angles, unit quaternions, and rotation</span>
<span class="sd">     vectors. James Diebel. 2006.</span>
<span class="sd">(8)  A discussion of the solution for the best rotation to relate two sets</span>
<span class="sd">     of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828.</span>
<span class="sd">(9)  Closed-form solution of absolute orientation using unit quaternions.</span>
<span class="sd">     BKP Horn. J Opt Soc Am A. 1987. 4(4):629-642.</span>
<span class="sd">(10) Quaternions. Ken Shoemake.</span>
<span class="sd">     http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf</span>
<span class="sd">(11) From quaternion to matrix and back. JMP van Waveren. 2005.</span>
<span class="sd">     http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm</span>
<span class="sd">(12) Uniform random rotations. Ken Shoemake.</span>
<span class="sd">     In &quot;Graphics Gems III&quot;, pp 124-132. Morgan Kaufmann, 1992.</span>
<span class="sd">(13) Quaternion in molecular modeling. CFF Karney.</span>
<span class="sd">     J Mol Graph Mod, 25(5):595-604</span>
<span class="sd">(14) New method for extracting the quaternion from a rotation matrix.</span>
<span class="sd">     Itzhack Y Bar-Itzhack, J Guid Contr Dynam. 2000. 23(6): 1085-1087.</span>
<span class="sd">(15) Multiple View Geometry in Computer Vision. Hartley and Zissermann.</span>
<span class="sd">     Cambridge University Press; 2nd Ed. 2004. Chapter 4, Algorithm 4.7, p 130.</span>
<span class="sd">(16) Column Vectors vs. Row Vectors.</span>
<span class="sd">     http://steve.hollasch.net/cgindex/math/matrix/column-vec.html</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">&gt;&gt;&gt; alpha, beta, gamma = 0.123, -1.234, 2.345</span>
<span class="sd">&gt;&gt;&gt; origin, xaxis, yaxis, zaxis = [0, 0, 0], [1, 0, 0], [0, 1, 0], [0, 0, 1]</span>
<span class="sd">&gt;&gt;&gt; I = identity_matrix()</span>
<span class="sd">&gt;&gt;&gt; Rx = rotation_matrix(alpha, xaxis)</span>
<span class="sd">&gt;&gt;&gt; Ry = rotation_matrix(beta, yaxis)</span>
<span class="sd">&gt;&gt;&gt; Rz = rotation_matrix(gamma, zaxis)</span>
<span class="sd">&gt;&gt;&gt; R = concatenate_matrices(Rx, Ry, Rz)</span>
<span class="sd">&gt;&gt;&gt; euler = euler_from_matrix(R, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; numpy.allclose([alpha, beta, gamma], euler)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; Re = euler_matrix(alpha, beta, gamma, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, Re)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; al, be, ga = euler_from_matrix(Re, &#39;rxyz&#39;)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(Re, euler_matrix(al, be, ga, &#39;rxyz&#39;))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; qx = quaternion_about_axis(alpha, xaxis)</span>
<span class="sd">&gt;&gt;&gt; qy = quaternion_about_axis(beta, yaxis)</span>
<span class="sd">&gt;&gt;&gt; qz = quaternion_about_axis(gamma, zaxis)</span>
<span class="sd">&gt;&gt;&gt; q = quaternion_multiply(qx, qy)</span>
<span class="sd">&gt;&gt;&gt; q = quaternion_multiply(q, qz)</span>
<span class="sd">&gt;&gt;&gt; Rq = quaternion_matrix(q)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, Rq)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; S = scale_matrix(1.23, origin)</span>
<span class="sd">&gt;&gt;&gt; T = translation_matrix([1, 2, 3])</span>
<span class="sd">&gt;&gt;&gt; Z = shear_matrix(beta, xaxis, origin, zaxis)</span>
<span class="sd">&gt;&gt;&gt; R = random_rotation_matrix(numpy.random.rand(3))</span>
<span class="sd">&gt;&gt;&gt; M = concatenate_matrices(T, R, Z, S)</span>
<span class="sd">&gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(M)</span>
<span class="sd">&gt;&gt;&gt; numpy.allclose(scale, 1.23)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; numpy.allclose(trans, [1, 2, 3])</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; numpy.allclose(shear, [0, math.tan(beta), 0])</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(R, euler_matrix(axes=&#39;sxyz&#39;, *angles))</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; M1 = compose_matrix(scale, shear, angles, trans, persp)</span>
<span class="sd">&gt;&gt;&gt; is_same_transform(M, M1)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; v0, v1 = random_vector(3), random_vector(3)</span>
<span class="sd">&gt;&gt;&gt; M = rotation_matrix(angle_between_vectors(v0, v1), vector_product(v0, v1))</span>
<span class="sd">&gt;&gt;&gt; v2 = numpy.dot(v0, M[:3,:3].T)</span>
<span class="sd">&gt;&gt;&gt; numpy.allclose(unit_vector(v1), unit_vector(v2))</span>
<span class="sd">True</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2013.06.29&quot;</span>
<span class="n">__docformat__</span> <span class="o">=</span> <span class="s2">&quot;restructuredtext en&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">identity_matrix</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 4x4 identity/unit matrix.</span>

<span class="sd">    &gt;&gt;&gt; I = identity_matrix()</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(I, numpy.dot(I, I))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.sum(I), numpy.trace(I)</span>
<span class="sd">    (4.0, 4.0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(I, numpy.identity(4))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">translation_matrix</span><span class="p">(</span><span class="n">direction</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to translate by direction vector.</span>

<span class="sd">    &gt;&gt;&gt; v = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v, translation_matrix(v)[:3, 3])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">translation_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return translation vector from translation matrix.</span>

<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v1 = translation_from_matrix(translation_matrix(v0))</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v0, v1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">reflection_matrix</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to mirror at plane defined by point and normal vector.</span>

<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.random(4) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1.</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R = reflection_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(2, numpy.trace(R))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v0, numpy.dot(R, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0.copy()</span>
<span class="sd">    &gt;&gt;&gt; v2[:3] += v1</span>
<span class="sd">    &gt;&gt;&gt; v3 = v0.copy()</span>
<span class="sd">    &gt;&gt;&gt; v2[:3] -= v1</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v2, numpy.dot(R, v3))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">))</span> <span class="o">*</span> <span class="n">normal</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">reflection_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return mirror plane point and normal vector from reflection matrix.</span>

<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; M0 = reflection_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; point, normal = reflection_from_matrix(M0)</span>
<span class="sd">    &gt;&gt;&gt; M1 = reflection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(M0, M1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># normal: unit eigenvector corresponding to eigenvalue -1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue -1&quot;</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># point: any unit eigenvector corresponding to eigenvalue 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span>


<span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to rotate about axis defined by point and direction.</span>

<span class="sd">    &gt;&gt;&gt; R = rotation_matrix(math.pi/2, [0, 0, 1], [1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.dot(R, [0, 0, 0, 1]), [1, -1, 0, 1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; direc = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(angle-2*math.pi, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(-angle, -direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; I = numpy.identity(4, numpy.float64)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(I, rotation_matrix(math.pi*2, direc))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(2, numpy.trace(rotation_matrix(math.pi/2,</span>
<span class="sd">    ...                                               direc, point)))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sina</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">cosa</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="c1"># rotation matrix around unit vector</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">cosa</span><span class="p">,</span> <span class="n">cosa</span><span class="p">,</span> <span class="n">cosa</span><span class="p">])</span>
    <span class="n">R</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosa</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">*=</span> <span class="n">sina</span>
    <span class="n">R</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
            <span class="p">[</span><span class="o">-</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
    <span class="k">if</span> <span class="n">point</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># rotation not around origin</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">rotation_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return rotation angle and axis from rotation matrix.</span>

<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; direc = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; R0 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; angle, direc, point = rotation_from_matrix(R0)</span>
<span class="sd">    &gt;&gt;&gt; R1 = rotation_matrix(angle, direc, point)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R0, R1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">R33</span> <span class="o">=</span> <span class="n">R</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># direction: unit eigenvector of R33 corresponding to eigenvalue of 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">R33</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">W</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># point: unit eigenvector of R33 corresponding to eigenvalue of 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">Q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no unit eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Q</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># rotation angle depending on direction</span>
    <span class="n">cosa</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">R33</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sina</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">direction</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sina</span><span class="p">,</span> <span class="n">cosa</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span>


<span class="k">def</span> <span class="nf">scale_matrix</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to scale by factor around origin in direction.</span>

<span class="sd">    Use factor -1 for point symmetry.</span>

<span class="sd">    &gt;&gt;&gt; v = (numpy.random.rand(4, 5) - 0.5) * 20</span>
<span class="sd">    &gt;&gt;&gt; v[3] = 1</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(-1.234)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; factor = random.random() * 10 - 5</span>
<span class="sd">    &gt;&gt;&gt; origin = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(factor, origin)</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(factor, origin, direct)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># uniform scaling</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">factor</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># nonuniform scaling</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">factor</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">origin</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">direction</span><span class="p">))</span> <span class="o">*</span> <span class="n">direction</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">scale_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return scaling factor, origin and direction from scaling matrix.</span>

<span class="sd">    &gt;&gt;&gt; factor = random.random() * 10 - 5</span>
<span class="sd">    &gt;&gt;&gt; origin = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; S0 = scale_matrix(factor, origin)</span>
<span class="sd">    &gt;&gt;&gt; factor, origin, direction = scale_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = scale_matrix(factor, origin, direction)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S0 = scale_matrix(factor, origin, direct)</span>
<span class="sd">    &gt;&gt;&gt; factor, origin, direction = scale_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = scale_matrix(factor, origin, direction)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span> <span class="o">-</span> <span class="mf">2.0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># direction: unit eigenvector corresponding to eigenvalue factor</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="n">factor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="c1"># uniform scaling</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="p">(</span><span class="n">factor</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># origin: any eigenvector corresponding to eigenvalue 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">origin</span> <span class="o">/=</span> <span class="n">origin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">direction</span>


<span class="k">def</span> <span class="nf">projection_matrix</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perspective</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to project onto plane defined by point and normal.</span>

<span class="sd">    Using either perspective point, projection direction, or none of both.</span>

<span class="sd">    If pseudo is True, perspective projections will preserve relative depth</span>
<span class="sd">    such that Perspective = dot(Orthogonal, PseudoPerspective).</span>

<span class="sd">    &gt;&gt;&gt; P = projection_matrix([0, 0, 0], [1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(point, normal, direction=direct)</span>
<span class="sd">    &gt;&gt;&gt; P2 = projection_matrix(point, normal, perspective=persp)</span>
<span class="sd">    &gt;&gt;&gt; P3 = projection_matrix(point, normal, perspective=persp, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P2, numpy.dot(P0, P3))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P = projection_matrix([3, 0, 0], [1, 1, 0], [1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; v0 = (numpy.random.rand(4, 5) - 0.5) * 20</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.dot(P, v0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1[1], v0[1])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1[0], 3-v1[1])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">perspective</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># perspective projection</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">perspective</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">perspective</span> <span class="o">-</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">perspective</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pseudo</span><span class="p">:</span>
            <span class="c1"># preserve relative depth</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">perspective</span> <span class="o">+</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">perspective</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">normal</span>
        <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">perspective</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># parallel projection</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span> <span class="o">*</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># orthogonal projection</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">normal</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">projection_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">pseudo</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return projection plane and perspective point from projection matrix.</span>

<span class="sd">    Return values are same as arguments for projection_matrix function:</span>
<span class="sd">    point, normal, direction, perspective, and pseudo.</span>

<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, direct)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, perspective=persp, pseudo=False)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0, pseudo=False)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; P0 = projection_matrix(point, normal, perspective=persp, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; result = projection_from_matrix(P0, pseudo=True)</span>
<span class="sd">    &gt;&gt;&gt; P1 = projection_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(P0, P1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">pseudo</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c1"># point: any eigenvector corresponding to eigenvalue 1</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="c1"># direction: unit eigenvector corresponding to eigenvalue 0</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 0&quot;</span><span class="p">)</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">direction</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
        <span class="c1"># normal: unit eigenvector of M33.T corresponding to eigenvalue 0</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="c1"># parallel projection</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">normal</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># orthogonal projection, where normal equals direction vector</span>
            <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># perspective projection</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector not corresponding to eigenvalue 0&quot;</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">normal</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pseudo</span><span class="p">:</span>
            <span class="n">perspective</span> <span class="o">-=</span> <span class="n">normal</span>
        <span class="k">return</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">perspective</span><span class="p">,</span> <span class="n">pseudo</span>


<span class="k">def</span> <span class="nf">clip_matrix</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">near</span><span class="p">,</span> <span class="n">far</span><span class="p">,</span> <span class="n">perspective</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to obtain normalized device coordinates from frustum.</span>

<span class="sd">    The frustum bounds are axis-aligned along x (left, right),</span>
<span class="sd">    y (bottom, top) and z (near, far).</span>

<span class="sd">    Normalized device coordinates are in range [-1, 1] if coordinates are</span>
<span class="sd">    inside the frustum.</span>

<span class="sd">    If perspective is True the frustum is a truncated pyramid with the</span>
<span class="sd">    perspective point at origin and direction along z axis, otherwise an</span>
<span class="sd">    orthographic canonical view volume (a box).</span>

<span class="sd">    Homogeneous coordinates transformed by the perspective clip matrix</span>
<span class="sd">    need to be dehomogenized (divided by w coordinate).</span>

<span class="sd">    &gt;&gt;&gt; frustum = numpy.random.rand(6)</span>
<span class="sd">    &gt;&gt;&gt; frustum[1] += frustum[0]</span>
<span class="sd">    &gt;&gt;&gt; frustum[3] += frustum[2]</span>
<span class="sd">    &gt;&gt;&gt; frustum[5] += frustum[4]</span>
<span class="sd">    &gt;&gt;&gt; M = clip_matrix(perspective=False, *frustum)</span>
<span class="sd">    &gt;&gt;&gt; numpy.dot(M, [frustum[0], frustum[2], frustum[4], 1])</span>
<span class="sd">    array([-1., -1., -1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; numpy.dot(M, [frustum[1], frustum[3], frustum[5], 1])</span>
<span class="sd">    array([ 1.,  1.,  1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; M = clip_matrix(perspective=True, *frustum)</span>
<span class="sd">    &gt;&gt;&gt; v = numpy.dot(M, [frustum[0], frustum[2], frustum[4], 1])</span>
<span class="sd">    &gt;&gt;&gt; v / v[3]</span>
<span class="sd">    array([-1., -1., -1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; v = numpy.dot(M, [frustum[1], frustum[3], frustum[4], 1])</span>
<span class="sd">    &gt;&gt;&gt; v / v[3]</span>
<span class="sd">    array([ 1.,  1., -1.,  1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;=</span> <span class="n">right</span> <span class="ow">or</span> <span class="n">bottom</span> <span class="o">&gt;=</span> <span class="n">top</span> <span class="ow">or</span> <span class="n">near</span> <span class="o">&gt;=</span> <span class="n">far</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid frustum&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perspective</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">near</span> <span class="o">&lt;=</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid frustum: near &lt;= 0&quot;</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">near</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">t</span> <span class="o">/</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">t</span> <span class="o">/</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span><span class="p">),</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">near</span> <span class="o">-</span> <span class="n">far</span><span class="p">),</span> <span class="n">t</span> <span class="o">*</span> <span class="n">far</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">right</span> <span class="o">+</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">top</span> <span class="o">-</span> <span class="n">bottom</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="p">(</span><span class="n">top</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">top</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">far</span> <span class="o">-</span> <span class="n">near</span><span class="p">),</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">near</span> <span class="o">-</span> <span class="n">far</span><span class="p">)],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">shear_matrix</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to shear by angle along direction vector on shear plane.</span>

<span class="sd">    The shear plane is defined by a point and normal vector. The direction</span>
<span class="sd">    vector must be orthogonal to the plane&#39;s normal vector.</span>

<span class="sd">    A point P is transformed by the shear matrix into P&quot; such that</span>
<span class="sd">    the vector P-P&quot; is parallel to the direction vector and its extent is</span>
<span class="sd">    given by the angle of P-P&#39;-P&quot;, where P&#39; is the orthogonal projection</span>
<span class="sd">    of P onto the shear plane.</span>

<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * 4*math.pi</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = numpy.cross(direct, numpy.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; S = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(1, numpy.linalg.det(S))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">normal</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">direction</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;direction and normal vectors are not orthogonal, diff is </span><span class="si">%f</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">direction</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">angle</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">point</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="n">direction</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">shear_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return shear angle, direction and plane from shear matrix.</span>

<span class="sd">    &gt;&gt;&gt; angle = (random.random() - 0.5) * 4*math.pi</span>
<span class="sd">    &gt;&gt;&gt; direct = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; point = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; normal = numpy.cross(direct, numpy.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; S0 = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; angle, direct, point, normal = shear_from_matrix(S0)</span>
<span class="sd">    &gt;&gt;&gt; S1 = shear_matrix(angle, direct, point, normal)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(S0, S1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">M33</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="c1"># normal: cross independent eigenvectors corresponding to the eigenvalue 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M33</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no two linear independent eigenvectors found </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
    <span class="n">lenorm</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i0</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">lenorm</span><span class="p">:</span>
            <span class="n">lenorm</span> <span class="o">=</span> <span class="n">w</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">normal</span> <span class="o">/=</span> <span class="n">lenorm</span>
    <span class="c1"># direction and angle</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M33</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="n">direction</span> <span class="o">/=</span> <span class="n">angle</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="c1"># point: eigenvector corresponding to eigenvalue 1</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no eigenvector corresponding to eigenvalue 1&quot;</span><span class="p">)</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span> <span class="n">i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="n">point</span> <span class="o">/=</span> <span class="n">point</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">normal</span>


<span class="k">def</span> <span class="nf">decompose_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return sequence of transformations from transformation matrix.</span>

<span class="sd">    matrix : array_like</span>
<span class="sd">        Non-degenerative homogeneous transformation matrix</span>

<span class="sd">    Return tuple of:</span>
<span class="sd">        scale : vector of 3 scaling factors</span>
<span class="sd">        shear : list of shear factors for x-y, x-z, y-z axes</span>
<span class="sd">        angles : list of Euler angles about static x, y, z axes</span>
<span class="sd">        translate : translation vector along x, y, z axes</span>
<span class="sd">        perspective : perspective partition of matrix</span>

<span class="sd">    Raise ValueError if matrix is of wrong type or degenerative.</span>

<span class="sd">    &gt;&gt;&gt; T0 = translation_matrix([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(T0)</span>
<span class="sd">    &gt;&gt;&gt; T1 = translation_matrix(trans)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(T0, T1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(0.123)</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(S)</span>
<span class="sd">    &gt;&gt;&gt; scale[0]</span>
<span class="sd">    0.123</span>
<span class="sd">    &gt;&gt;&gt; R0 = euler_matrix(1, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; scale, shear, angles, trans, persp = decompose_matrix(R0)</span>
<span class="sd">    &gt;&gt;&gt; R1 = euler_matrix(*angles)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(R0, R1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;M[3, 3] is zero&quot;</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">P</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix is singular&quot;</span><span class="p">)</span>

    <span class="n">scale</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">shear</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">):</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">M</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">perspective</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>

    <span class="n">translate</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">row</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>

    <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># angles[0] = math.atan2(row[1, 0], row[1, 1])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">row</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">scale</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">translate</span><span class="p">,</span> <span class="n">perspective</span>


<span class="k">def</span> <span class="nf">compose_matrix</span><span class="p">(</span>
    <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">translate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">perspective</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return transformation matrix from sequence of transformations.</span>

<span class="sd">    This is the inverse of the decompose_matrix function.</span>

<span class="sd">    Sequence of transformations:</span>
<span class="sd">        scale : vector of 3 scaling factors</span>
<span class="sd">        shear : list of shear factors for x-y, x-z, y-z axes</span>
<span class="sd">        angles : list of Euler angles about static x, y, z axes</span>
<span class="sd">        translate : translation vector along x, y, z axes</span>
<span class="sd">        perspective : perspective partition of matrix</span>

<span class="sd">    &gt;&gt;&gt; scale = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; shear = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; angles = (numpy.random.random(3) - 0.5) * (2*math.pi)</span>
<span class="sd">    &gt;&gt;&gt; trans = numpy.random.random(3) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; persp = numpy.random.random(4) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; M0 = compose_matrix(scale, shear, angles, trans, persp)</span>
<span class="sd">    &gt;&gt;&gt; result = decompose_matrix(M0)</span>
<span class="sd">    &gt;&gt;&gt; M1 = compose_matrix(*result)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(M0, M1)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">perspective</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">P</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">perspective</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">translate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">translate</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">angles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">euler_matrix</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s2">&quot;sxyz&quot;</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shear</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">S</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">scale</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">orthogonalization_matrix</span><span class="p">(</span><span class="n">lengths</span><span class="p">,</span> <span class="n">angles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return orthogonalization matrix for crystallographic cell coordinates.</span>

<span class="sd">    Angles are expected in degrees.</span>

<span class="sd">    The de-orthogonalization matrix is the inverse.</span>

<span class="sd">    &gt;&gt;&gt; O = orthogonalization_matrix([10, 10, 10], [90, 90, 90])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.sum(O), 43.063229)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">lengths</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">sina</span><span class="p">,</span> <span class="n">sinb</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">cosa</span><span class="p">,</span> <span class="n">cosb</span><span class="p">,</span> <span class="n">cosg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">co</span> <span class="o">=</span> <span class="p">(</span><span class="n">cosa</span> <span class="o">*</span> <span class="n">cosb</span> <span class="o">-</span> <span class="n">cosg</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sina</span> <span class="o">*</span> <span class="n">sinb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">sinb</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">co</span> <span class="o">*</span> <span class="n">co</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">sinb</span> <span class="o">*</span> <span class="n">co</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">sina</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">a</span> <span class="o">*</span> <span class="n">cosb</span><span class="p">,</span> <span class="n">b</span> <span class="o">*</span> <span class="n">cosa</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">affine_matrix_from_points</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">usesvd</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return affine transform matrix to register two point sets.</span>

<span class="sd">    v0 and v1 are shape (ndims, \*) arrays of at least ndims non-homogeneous</span>
<span class="sd">    coordinates, where ndims is the dimensionality of the coordinate space.</span>

<span class="sd">    If shear is False, a similarity transformation matrix is returned.</span>
<span class="sd">    If also scale is False, a rigid/Euclidean transformation matrix</span>
<span class="sd">    is returned.</span>

<span class="sd">    By default the algorithm by Hartley and Zissermann [15] is used.</span>
<span class="sd">    If usesvd is True, similarity and Euclidean transformation matrices</span>
<span class="sd">    are calculated by minimizing the weighted sum of squared deviations</span>
<span class="sd">    (RMSD) according to the algorithm by Kabsch [8].</span>
<span class="sd">    Otherwise, and if ndims is 3, the quaternion based algorithm by Horn [9]</span>
<span class="sd">    is used, which is slower when using this Python implementation.</span>

<span class="sd">    The returned matrix performs rotation, translation and uniform scaling</span>
<span class="sd">    (if specified).</span>

<span class="sd">    &gt;&gt;&gt; v0 = [[0, 1031, 1031, 0], [0, 0, 1600, 1600]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = [[675, 826, 826, 677], [55, 52, 281, 277]]</span>
<span class="sd">    &gt;&gt;&gt; affine_matrix_from_points(v0, v1)</span>
<span class="sd">    array([[   0.14549,    0.00062,  675.50008],</span>
<span class="sd">           [   0.00048,    0.14094,   53.24971],</span>
<span class="sd">           [   0.     ,    0.     ,    1.     ]])</span>
<span class="sd">    &gt;&gt;&gt; T = translation_matrix(numpy.random.random(3)-0.5)</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix(numpy.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(random.random())</span>
<span class="sd">    &gt;&gt;&gt; M = concatenate_matrices(T, R, S)</span>
<span class="sd">    &gt;&gt;&gt; v0 = (numpy.random.rand(4, 100) - 0.5) * 20</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.dot(M, v0)</span>
<span class="sd">    &gt;&gt;&gt; v0[:3] += numpy.random.normal(0, 1e-8, 300).reshape(3, -1)</span>
<span class="sd">    &gt;&gt;&gt; M = affine_matrix_from_points(v0[:3], v1[:3])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))</span>
<span class="sd">    True</span>

<span class="sd">    More examples in superimposition_matrix()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ndims</span> <span class="ow">or</span> <span class="n">v0</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">v1</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input arrays are of wrong shape or type&quot;</span><span class="p">)</span>

    <span class="c1"># move centroids to origin</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">M0</span><span class="p">[:</span><span class="n">ndims</span><span class="p">,</span> <span class="n">ndims</span><span class="p">]</span> <span class="o">=</span> <span class="n">t0</span>
    <span class="n">v0</span> <span class="o">+=</span> <span class="n">t0</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">M1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">M1</span><span class="p">[:</span><span class="n">ndims</span><span class="p">,</span> <span class="n">ndims</span><span class="p">]</span> <span class="o">=</span> <span class="n">t1</span>
    <span class="n">v1</span> <span class="o">+=</span> <span class="n">t1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ndims</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shear</span><span class="p">:</span>
        <span class="c1"># Affine transformation</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">vh</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:</span><span class="n">ndims</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[:</span><span class="n">ndims</span><span class="p">]</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">vh</span><span class="p">[</span><span class="n">ndims</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndims</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ndims</span><span class="p">,</span> <span class="mi">1</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="p">((</span><span class="mf">0.0</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndims</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,)))</span>
    <span class="k">elif</span> <span class="n">usesvd</span> <span class="ow">or</span> <span class="n">ndims</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># Rigid transformation via SVD of covariance matrix</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v0</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="c1"># rotation matrix from SVD orthonormal bases</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">vh</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c1"># R does not constitute right handed system</span>
            <span class="n">R</span> <span class="o">-=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="n">ndims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vh</span><span class="p">[</span><span class="n">ndims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="c1"># homogeneous transformation matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">ndims</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">M</span><span class="p">[:</span><span class="n">ndims</span><span class="p">,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Rigid transformation matrix via quaternion</span>
        <span class="c1"># compute symmetric matrix N</span>
        <span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">zz</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">*</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xy</span><span class="p">,</span> <span class="n">yz</span><span class="p">,</span> <span class="n">zx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xz</span><span class="p">,</span> <span class="n">yx</span><span class="p">,</span> <span class="n">zy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">xx</span> <span class="o">+</span> <span class="n">yy</span> <span class="o">+</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">yz</span> <span class="o">-</span> <span class="n">zy</span><span class="p">,</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">zx</span> <span class="o">-</span> <span class="n">xz</span><span class="p">,</span> <span class="n">xy</span> <span class="o">+</span> <span class="n">yx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">-</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">zz</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">xy</span> <span class="o">-</span> <span class="n">yx</span><span class="p">,</span> <span class="n">zx</span> <span class="o">+</span> <span class="n">xz</span><span class="p">,</span> <span class="n">yz</span> <span class="o">+</span> <span class="n">zy</span><span class="p">,</span> <span class="n">zz</span> <span class="o">-</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">yy</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="c1"># quaternion: eigenvector corresponding to most positive eigenvalue</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>
        <span class="n">q</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>  <span class="c1"># unit quaternion</span>
        <span class="c1"># homogeneous transformation matrix</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">scale</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">shear</span><span class="p">:</span>
        <span class="c1"># Affine transformation; scale is ratio of RMS deviations from centroid</span>
        <span class="n">v0</span> <span class="o">*=</span> <span class="n">v0</span>
        <span class="n">v1</span> <span class="o">*=</span> <span class="n">v1</span>
        <span class="n">M</span><span class="p">[:</span><span class="n">ndims</span><span class="p">,</span> <span class="p">:</span><span class="n">ndims</span><span class="p">]</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span><span class="p">))</span>

    <span class="c1"># move centroids back</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">M1</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">M0</span><span class="p">))</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">M</span><span class="p">[</span><span class="n">ndims</span><span class="p">,</span> <span class="n">ndims</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">superimposition_matrix</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">usesvd</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return matrix to transform given 3D point set into second point set.</span>

<span class="sd">    v0 and v1 are shape (3, \*) or (4, \*) arrays of at least 3 points.</span>

<span class="sd">    The parameters scale and usesvd are explained in the more general</span>
<span class="sd">    affine_matrix_from_points function.</span>

<span class="sd">    The returned matrix is a similarity or Euclidean transformation matrix.</span>
<span class="sd">    This function has a fast C implementation in transformations.c.</span>

<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.rand(3, 10)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M, numpy.identity(4))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix(numpy.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; v0 = [[1,0,0], [0,1,0], [0,0,1], [1,1,1]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.dot(R, v0)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = (numpy.random.rand(4, 100) - 0.5) * 20</span>
<span class="sd">    &gt;&gt;&gt; v0[3] = 1</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.dot(R, v0)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; S = scale_matrix(random.random())</span>
<span class="sd">    &gt;&gt;&gt; T = translation_matrix(numpy.random.random(3)-0.5)</span>
<span class="sd">    &gt;&gt;&gt; M = concatenate_matrices(T, R, S)</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.dot(M, v0)</span>
<span class="sd">    &gt;&gt;&gt; v0[:3] += numpy.random.normal(0, 1e-9, 300).reshape(3, -1)</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scale=True)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scale=True, usesvd=False)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = numpy.empty((4, 100, 3))</span>
<span class="sd">    &gt;&gt;&gt; v[:, :, 0] = v0</span>
<span class="sd">    &gt;&gt;&gt; M = superimposition_matrix(v0, v1, scale=True, usesvd=False)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, numpy.dot(M, v[:, :, 0]))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">affine_matrix_from_points</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">usesvd</span><span class="o">=</span><span class="n">usesvd</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">euler_matrix</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix from Euler angles and axis sequence.</span>

<span class="sd">    ai, aj, ak : Euler&#39;s roll, pitch and yaw angles</span>
<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    &gt;&gt;&gt; R = euler_matrix(1, 2, 3, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.sum(R[0]), -1.34786452)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = euler_matrix(1, 2, 3, (0, 1, 0, 1))</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.sum(R[0]), -0.383436184)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ai, aj, ak = (4*math.pi) * (numpy.random.random(3) - 0.5)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _AXES2TUPLE.keys():</span>
<span class="sd">    ...    R = euler_matrix(ai, aj, ak, axes)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _TUPLE2AXES.keys():</span>
<span class="sd">    ...    R = euler_matrix(ai, aj, ak, axes)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>  <span class="c1"># validation</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">ak</span><span class="p">,</span> <span class="n">ai</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="o">-</span><span class="n">ai</span><span class="p">,</span> <span class="o">-</span><span class="n">aj</span><span class="p">,</span> <span class="o">-</span><span class="n">ak</span>

    <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">sk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">aj</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">ci</span><span class="p">,</span> <span class="n">cj</span><span class="p">,</span> <span class="n">ck</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aj</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">cc</span><span class="p">,</span> <span class="n">cs</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">ck</span><span class="p">,</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">sk</span>
    <span class="n">sc</span><span class="p">,</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">ck</span><span class="p">,</span> <span class="n">si</span> <span class="o">*</span> <span class="n">sk</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">si</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ci</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sk</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">cc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sj</span> <span class="o">*</span> <span class="n">ck</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">cs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">-</span> <span class="n">ss</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ck</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">-</span> <span class="n">cs</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">+</span> <span class="n">ss</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sk</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">cc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sj</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">si</span>
        <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ci</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">euler_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Euler angles from rotation matrix for specified axis sequence.</span>

<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    Note that many Euler angle triplets can describe one matrix.</span>

<span class="sd">    &gt;&gt;&gt; R0 = euler_matrix(1, 2, 3, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; al, be, ga = euler_from_matrix(R0, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; R1 = euler_matrix(al, be, ga, &#39;syxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(R0, R1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; angles = (4*math.pi) * (numpy.random.random(3) - 0.5)</span>
<span class="sd">    &gt;&gt;&gt; for axes in _AXES2TUPLE.keys():</span>
<span class="sd">    ...    R0 = euler_matrix(axes=axes, *angles)</span>
<span class="sd">    ...    R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes))</span>
<span class="sd">    ...    if not numpy.allclose(R0, R1): print(axes, &quot;failed&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>  <span class="c1"># validation</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span><span class="p">]</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">az</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">az</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cy</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">az</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
            <span class="n">ay</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">cy</span><span class="p">)</span>
            <span class="n">az</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="o">-</span><span class="n">ax</span><span class="p">,</span> <span class="o">-</span><span class="n">ay</span><span class="p">,</span> <span class="o">-</span><span class="n">az</span>
    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">az</span> <span class="o">=</span> <span class="n">az</span><span class="p">,</span> <span class="n">ax</span>
    <span class="k">return</span> <span class="n">ax</span><span class="p">,</span> <span class="n">ay</span><span class="p">,</span> <span class="n">az</span>


<span class="k">def</span> <span class="nf">euler_from_quaternion</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Euler angles from quaternion for specified axis sequence.</span>

<span class="sd">    &gt;&gt;&gt; angles = euler_from_quaternion([0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(angles, [0.123, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">euler_from_matrix</span><span class="p">(</span><span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">quaternion</span><span class="p">),</span> <span class="n">axes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_from_euler</span><span class="p">(</span><span class="n">ai</span><span class="p">,</span> <span class="n">aj</span><span class="p">,</span> <span class="n">ak</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="s2">&quot;sxyz&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion from Euler angles and axis sequence.</span>

<span class="sd">    ai, aj, ak : Euler&#39;s roll, pitch and yaw angles</span>
<span class="sd">    axes : One of 24 axis sequences as string or encoded tuple</span>

<span class="sd">    &gt;&gt;&gt; q = quaternion_from_euler(1, 2, 3, &#39;ryxz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0.435953, 0.310622, -0.718287, 0.444435])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">_AXES2TUPLE</span><span class="p">[</span><span class="n">axes</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
        <span class="n">_TUPLE2AXES</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span>  <span class="c1"># validation</span>
        <span class="n">firstaxis</span><span class="p">,</span> <span class="n">parity</span><span class="p">,</span> <span class="n">repetition</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">axes</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">firstaxis</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">parity</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">_NEXT_AXIS</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">parity</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">frame</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">,</span> <span class="n">ak</span> <span class="o">=</span> <span class="n">ak</span><span class="p">,</span> <span class="n">ai</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">aj</span> <span class="o">=</span> <span class="o">-</span><span class="n">aj</span>

    <span class="n">ai</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">aj</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">ak</span> <span class="o">/=</span> <span class="mf">2.0</span>
    <span class="n">ci</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
    <span class="n">si</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
    <span class="n">cj</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
    <span class="n">sj</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">aj</span><span class="p">)</span>
    <span class="n">ck</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">sk</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ak</span><span class="p">)</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">ck</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">ci</span> <span class="o">*</span> <span class="n">sk</span>
    <span class="n">sc</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">ck</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">si</span> <span class="o">*</span> <span class="n">sk</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
    <span class="k">if</span> <span class="n">repetition</span><span class="p">:</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span> <span class="o">-</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cs</span> <span class="o">+</span> <span class="n">sc</span><span class="p">)</span>
        <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cc</span> <span class="o">+</span> <span class="n">ss</span><span class="p">)</span>
        <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sj</span> <span class="o">*</span> <span class="p">(</span><span class="n">cs</span> <span class="o">-</span> <span class="n">sc</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cc</span> <span class="o">+</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">ss</span>
        <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">-</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cs</span>
        <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">ss</span> <span class="o">+</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">cc</span>
        <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cj</span> <span class="o">*</span> <span class="n">cs</span> <span class="o">-</span> <span class="n">sj</span> <span class="o">*</span> <span class="n">sc</span>
    <span class="k">if</span> <span class="n">parity</span><span class="p">:</span>
        <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">1.0</span>

    <span class="k">return</span> <span class="n">q</span>


<span class="k">def</span> <span class="nf">quaternion_about_axis</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion for rotation about axis.</span>

<span class="sd">    &gt;&gt;&gt; q = quaternion_about_axis(0.123, [1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>
    <span class="n">qlen</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">qlen</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">qlen</span>
    <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span>


<span class="k">def</span> <span class="nf">quaternion_matrix</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix from quaternion.</span>

<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([0.99810947, 0.06146124, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M, rotation_matrix(0.123, [1, 0, 0]))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M, numpy.identity(4))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; M = quaternion_matrix([0, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M, numpy.diag([1, -1, -1, 1]))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">[</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_from_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">isprecise</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return quaternion from rotation matrix.</span>

<span class="sd">    If isprecise is True, the input matrix is assumed to be a precise rotation</span>
<span class="sd">    matrix and a faster algorithm is used.</span>

<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(numpy.identity(4), True)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [1, 0, 0, 0])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(numpy.diag([1, -1, -1, 1]))</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0, 1, 0, 0]) or numpy.allclose(q, [0, -1, 0, 0])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = rotation_matrix(0.123, (1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R, True)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0.9981095, 0.0164262, 0.0328524, 0.0492786])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = [[-0.545, 0.797, 0.260, 0], [0.733, 0.603, -0.313, 0],</span>
<span class="sd">    ...      [-0.407, 0.021, -0.913, 0], [0, 0, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0.19069, 0.43736, 0.87485, -0.083611])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = [[0.395, 0.362, 0.843, 0], [-0.626, 0.796, -0.056, 0],</span>
<span class="sd">    ...      [-0.677, -0.498, 0.529, 0], [0, 0, 0, 1]]</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [0.82336615, -0.13610694, 0.46344705, -0.29792603])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_from_matrix(R)</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(R, quaternion_matrix(q))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">isprecise</span><span class="p">:</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">4</span><span class="p">,))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
            <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
        <span class="n">q</span> <span class="o">*=</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">M</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">m00</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m01</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m02</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">m10</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m11</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m12</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">m20</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">m21</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">m22</span> <span class="o">=</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="c1"># symmetric matrix K</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">[</span><span class="n">m00</span> <span class="o">-</span> <span class="n">m11</span> <span class="o">-</span> <span class="n">m22</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m01</span> <span class="o">+</span> <span class="n">m10</span><span class="p">,</span> <span class="n">m11</span> <span class="o">-</span> <span class="n">m00</span> <span class="o">-</span> <span class="n">m22</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m02</span> <span class="o">+</span> <span class="n">m20</span><span class="p">,</span> <span class="n">m12</span> <span class="o">+</span> <span class="n">m21</span><span class="p">,</span> <span class="n">m22</span> <span class="o">-</span> <span class="n">m00</span> <span class="o">-</span> <span class="n">m11</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">m21</span> <span class="o">-</span> <span class="n">m12</span><span class="p">,</span> <span class="n">m02</span> <span class="o">-</span> <span class="n">m20</span><span class="p">,</span> <span class="n">m10</span> <span class="o">-</span> <span class="n">m01</span><span class="p">,</span> <span class="n">m00</span> <span class="o">+</span> <span class="n">m11</span> <span class="o">+</span> <span class="n">m22</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">K</span> <span class="o">/=</span> <span class="mf">3.0</span>
        <span class="c1"># quaternion is eigenvector of K that corresponds to largest eigenvalue</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">V</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">q</span>


<span class="k">def</span> <span class="nf">quaternion_multiply</span><span class="p">(</span><span class="n">quaternion1</span><span class="p">,</span> <span class="n">quaternion0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return multiplication of two quaternions.</span>

<span class="sd">    &gt;&gt;&gt; q = quaternion_multiply([4, 1, -2, 3], [8, -5, 6, 7])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, [28, -44, -14, 48])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w0</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="n">quaternion0</span>
    <span class="n">w1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">z1</span> <span class="o">=</span> <span class="n">quaternion1</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="o">-</span><span class="n">x1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">w0</span><span class="p">,</span>
            <span class="n">x1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">-</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">x0</span><span class="p">,</span>
            <span class="o">-</span><span class="n">x1</span> <span class="o">*</span> <span class="n">z0</span> <span class="o">+</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">y0</span><span class="p">,</span>
            <span class="n">x1</span> <span class="o">*</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">*</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">z1</span> <span class="o">*</span> <span class="n">w0</span> <span class="o">+</span> <span class="n">w1</span> <span class="o">*</span> <span class="n">z0</span><span class="p">,</span>
        <span class="p">],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_conjugate</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return conjugate of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = quaternion_conjugate(q0)</span>
<span class="sd">    &gt;&gt;&gt; q1[0] == q0[0] and all(q1[1:] == -q0[1:])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">q</span>


<span class="k">def</span> <span class="nf">quaternion_inverse</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return inverse of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = quaternion_inverse(q0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(quaternion_multiply(q0, q1), [1, 0, 0, 0])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quaternion</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">q</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_real</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return real part of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; quaternion_real([3, 0, 1, 2])</span>
<span class="sd">    3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">quaternion</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">quaternion_imag</span><span class="p">(</span><span class="n">quaternion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return imaginary part of quaternion.</span>

<span class="sd">    &gt;&gt;&gt; quaternion_imag([3, 0, 1, 2])</span>
<span class="sd">    array([ 0.,  1.,  2.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">quaternion</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">quaternion_slerp</span><span class="p">(</span><span class="n">quat0</span><span class="p">,</span> <span class="n">quat1</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shortestpath</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return spherical linear interpolation between two quaternions.</span>

<span class="sd">    &gt;&gt;&gt; q0 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q1 = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, q0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 1, 1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(q, q1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = quaternion_slerp(q0, q1, 0.5)</span>
<span class="sd">    &gt;&gt;&gt; angle = math.acos(numpy.dot(q0, q))</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(2, math.acos(numpy.dot(q0, q1)) / angle) or \</span>
<span class="sd">        numpy.allclose(2, math.acos(-numpy.dot(q0, q1)) / angle)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">q0</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">quat0</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="n">unit_vector</span><span class="p">(</span><span class="n">quat1</span><span class="p">[:</span><span class="mi">4</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="k">elif</span> <span class="n">fraction</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="k">if</span> <span class="n">shortestpath</span> <span class="ow">and</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># invert rotation</span>
        <span class="n">d</span> <span class="o">=</span> <span class="o">-</span><span class="n">d</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">spin</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">q0</span>
    <span class="n">isin</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">q0</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">fraction</span><span class="p">)</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">isin</span>
    <span class="n">q1</span> <span class="o">*=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="n">angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">isin</span>
    <span class="n">q0</span> <span class="o">+=</span> <span class="n">q1</span>
    <span class="k">return</span> <span class="n">q0</span>


<span class="k">def</span> <span class="nf">random_quaternion</span><span class="p">(</span><span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return uniform random unit quaternion.</span>

<span class="sd">    rand: array like or None</span>
<span class="sd">        Three independent random variables that are uniformly distributed</span>
<span class="sd">        between 0 and 1.</span>

<span class="sd">    &gt;&gt;&gt; q = random_quaternion()</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(1, vector_norm(q))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; q = random_quaternion(numpy.random.random(3))</span>
<span class="sd">    &gt;&gt;&gt; len(q.shape), q.shape[0]==4</span>
<span class="sd">    (1, True)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rand</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rand</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">rand</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rand</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">rand</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pi2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">2.0</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">pi2</span> <span class="o">*</span> <span class="n">rand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">pi2</span> <span class="o">*</span> <span class="n">rand</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">*</span> <span class="n">r2</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">r1</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="o">*</span> <span class="n">r2</span><span class="p">]</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">random_rotation_matrix</span><span class="p">(</span><span class="n">rand</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return uniform random rotation matrix.</span>

<span class="sd">    rand: array like</span>
<span class="sd">        Three independent random variables that are uniformly distributed</span>
<span class="sd">        between 0 and 1 for each returned quaternion.</span>

<span class="sd">    &gt;&gt;&gt; R = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.dot(R.T, R), numpy.identity(4))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="n">random_quaternion</span><span class="p">(</span><span class="n">rand</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">Arcball</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Virtual Trackball Control.</span>

<span class="sd">    &gt;&gt;&gt; ball = Arcball()</span>
<span class="sd">    &gt;&gt;&gt; ball = Arcball(initial=numpy.identity(4))</span>
<span class="sd">    &gt;&gt;&gt; ball.place([320, 320], 320)</span>
<span class="sd">    &gt;&gt;&gt; ball.down([500, 250])</span>
<span class="sd">    &gt;&gt;&gt; ball.drag([475, 275])</span>
<span class="sd">    &gt;&gt;&gt; R = ball.matrix()</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.sum(R), 3.90583455)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ball = Arcball(initial=[1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; ball.place([320, 320], 320)</span>
<span class="sd">    &gt;&gt;&gt; ball.setaxes([1, 1, 0], [-1, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; ball.constrain = True</span>
<span class="sd">    &gt;&gt;&gt; ball.down([400, 200])</span>
<span class="sd">    &gt;&gt;&gt; ball.drag([200, 400])</span>
<span class="sd">    &gt;&gt;&gt; R = ball.matrix()</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.sum(R), 0.2055924)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ball.next()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize virtual trackball control.</span>

<span class="sd">        initial : quaternion or rotation matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">initial</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">quaternion_from_matrix</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">initial</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,):</span>
                <span class="n">initial</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="n">initial</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;initial not a quaternion or matrix&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span>

    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Place Arcball, e.g. when window size changes.</span>

<span class="sd">        center : sequence[2]</span>
<span class="sd">            Window coordinates of trackball center.</span>
<span class="sd">        radius : float</span>
<span class="sd">            Radius of trackball in window coordinates.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">setaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set axes to constrain rotations.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit_vector</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return state of constrain to axis mode.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span>

    <span class="nd">@constrain</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">constrain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set state of constrain to axis mode.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set initial cursor window coordinates and pick constrain-axis.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constrain</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="n">arcball_nearest_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span> <span class="o">=</span> <span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">drag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update current cursor window coordinates.&quot;&quot;&quot;</span>
        <span class="n">vnow</span> <span class="o">=</span> <span class="n">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_center</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radius</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">vnow</span> <span class="o">=</span> <span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">vnow</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="n">vnow</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">_EPS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vdown</span><span class="p">,</span> <span class="n">vnow</span><span class="p">),</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="n">quaternion_multiply</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qdown</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">acceleration</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Continue rotation in direction of last drag.&quot;&quot;&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">quaternion_slerp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">acceleration</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qpre</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">,</span> <span class="n">q</span>

    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return homogeneous rotation matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">quaternion_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qnow</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">arcball_map_to_sphere</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return unit sphere coordinates from window coordinates.&quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">radius</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">radius</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v0</span> <span class="o">*</span> <span class="n">v0</span> <span class="o">+</span> <span class="n">v1</span> <span class="o">*</span> <span class="n">v1</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="c1"># position outside of sphere</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v0</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">v1</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)])</span>


<span class="k">def</span> <span class="nf">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return sphere point perpendicular to axis.&quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">-=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="c1"># on plane</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">_EPS</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">/=</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">v</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">unit_vector</span><span class="p">([</span><span class="o">-</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">arcball_nearest_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return axis, which arc is nearest to point.&quot;&quot;&quot;</span>
    <span class="n">point</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">nearest</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mx</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arcball_constrain_to_axis</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">mx</span><span class="p">:</span>
            <span class="n">nearest</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">t</span>
    <span class="k">return</span> <span class="n">nearest</span>


<span class="c1"># epsilon for testing whether a number is close to zero</span>
<span class="n">_EPS</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span> <span class="mf">4.0</span>

<span class="c1"># axis sequences for Euler angles</span>
<span class="n">_NEXT_AXIS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># map axes strings to/from tuples of inner axis, parity, repetition, frame</span>
<span class="n">_AXES2TUPLE</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;sxyz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;sxyx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;sxzy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;sxzx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;syzx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;syzy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;syxz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;syxy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;szxy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;szxz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;szyx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;szyz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="s2">&quot;rzyx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rxyx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;ryzx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rxzx&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rxzy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;ryzy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rzxy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;ryxy&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;ryxz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rzxz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rxyz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="s2">&quot;rzyz&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">_TUPLE2AXES</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_AXES2TUPLE</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">vector_norm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return length, i.e. Euclidean norm, of ndarray along axis.</span>

<span class="sd">    &gt;&gt;&gt; v = numpy.random.random(3)</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(n, numpy.linalg.norm(v))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = numpy.random.rand(6, 5, 3)</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; n = vector_norm(v, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v = numpy.random.rand(5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; n = numpy.empty((5, 3))</span>
<span class="sd">    &gt;&gt;&gt; vector_norm(v, axis=1, out=n)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; vector_norm([])</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; vector_norm([1])</span>
<span class="sd">    1.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">data</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">data</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unit_vector</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return ndarray normalized by length, i.e. Euclidean norm, along axis.</span>

<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.random(3)</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, v0 / numpy.linalg.norm(v0))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = numpy.random.rand(5, 4, 3)</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0, axis=-1)</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v1 = unit_vector(v0, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v1 = numpy.empty((5, 4, 3))</span>
<span class="sd">    &gt;&gt;&gt; unit_vector(v0, axis=1, out=v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v1, v2)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; list(unit_vector([]))</span>
<span class="sd">    []</span>
<span class="sd">    &gt;&gt;&gt; list(unit_vector([1]))</span>
<span class="sd">    [1.0]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">/=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">out</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">/=</span> <span class="n">length</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">random_vector</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return array of random doubles in the half-open interval [0.0, 1.0).</span>

<span class="sd">    &gt;&gt;&gt; v = random_vector(10000)</span>
<span class="sd">    &gt;&gt;&gt; numpy.all(v &gt;= 0) and numpy.all(v &lt; 1)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = random_vector(10)</span>
<span class="sd">    &gt;&gt;&gt; v1 = random_vector(10)</span>
<span class="sd">    &gt;&gt;&gt; numpy.any(v0 == v1)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">vector_product</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return vector perpendicular to vectors.</span>

<span class="sd">    &gt;&gt;&gt; v = vector_product([2, 0, 0], [0, 3, 0])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v, [0, 0, 6])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = [[2, 0, 0, 2], [0, 2, 0, 2], [0, 0, 2, 2]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = [[3], [0], [0]]</span>
<span class="sd">    &gt;&gt;&gt; v = vector_product(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v, [[0, 0, 0, 0], [0, 0, 6, 6], [0, -6, 0, -6]])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = [[2, 0, 0], [2, 0, 0], [0, 2, 0], [2, 0, 0]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = [[0, 3, 0], [0, 0, 3], [0, 0, 3], [3, 3, 3]]</span>
<span class="sd">    &gt;&gt;&gt; v = vector_product(v0, v1, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(v, [[0, 0, 6], [0, -6, 0], [6, 0, 0], [0, -6, 6]])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">angle_between_vectors</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return angle between vectors.</span>

<span class="sd">    If directed is False, the input vectors are interpreted as undirected axes,</span>
<span class="sd">    i.e. the maximum angle is pi/2.</span>

<span class="sd">    &gt;&gt;&gt; a = angle_between_vectors([1, -2, 3], [-1, 2, -3])</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(a, math.pi)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; a = angle_between_vectors([1, -2, 3], [-1, 2, -3], directed=False)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(a, 0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = [[2, 0, 0, 2], [0, 2, 0, 2], [0, 0, 2, 2]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = [[3], [0], [0]]</span>
<span class="sd">    &gt;&gt;&gt; a = angle_between_vectors(v0, v1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(a, [0, 1.5708, 1.5708, 0.95532])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; v0 = [[2, 0, 0], [2, 0, 0], [0, 2, 0], [2, 0, 0]]</span>
<span class="sd">    &gt;&gt;&gt; v1 = [[0, 3, 0], [0, 0, 3], [0, 0, 3], [3, 3, 3]]</span>
<span class="sd">    &gt;&gt;&gt; a = angle_between_vectors(v0, v1, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(a, [1.5708, 1.5708, 1.5708, 0.95532])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">dot</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v0</span> <span class="o">*</span> <span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">dot</span> <span class="o">/=</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">*</span> <span class="n">vector_norm</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dot</span> <span class="k">if</span> <span class="n">directed</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">dot</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">inverse_matrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return inverse of square transformation matrix.</span>

<span class="sd">    &gt;&gt;&gt; M0 = random_rotation_matrix()</span>
<span class="sd">    &gt;&gt;&gt; M1 = inverse_matrix(M0.T)</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M1, numpy.linalg.inv(M0.T))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; for size in range(1, 7):</span>
<span class="sd">    ...     M0 = numpy.random.rand(size, size)</span>
<span class="sd">    ...     M1 = inverse_matrix(M0)</span>
<span class="sd">    ...     if not numpy.allclose(M1, numpy.linalg.inv(M0)): print(size)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">concatenate_matrices</span><span class="p">(</span><span class="o">*</span><span class="n">matrices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return concatenation of series of transformation matrices.</span>

<span class="sd">    &gt;&gt;&gt; M = numpy.random.rand(16).reshape((4, 4)) - 0.5</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(M, concatenate_matrices(M))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">matrices</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>


<span class="k">def</span> <span class="nf">apply_transform</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 3D cartesian points after applying transform.</span>

<span class="sd">    The points are converted to 3D Homogeneous, the transformation</span>
<span class="sd">    is applied, and then they are converted back to Cartesian&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points must be 3xN&quot;</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">points</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])</span>
    <span class="n">tformed_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
    <span class="n">tformed_points</span> <span class="o">=</span> <span class="n">tformed_points</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">tformed_points</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">tformed_points</span>


<span class="k">def</span> <span class="nf">is_same_transform</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">matrix1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if two matrices perform same transformation.</span>

<span class="sd">    &gt;&gt;&gt; is_same_transform(numpy.identity(4), numpy.identity(4))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_same_transform(numpy.identity(4), random_rotation_matrix())</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">matrix0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matrix0</span> <span class="o">/=</span> <span class="n">matrix0</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">matrix1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matrix1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">matrix1</span> <span class="o">/=</span> <span class="n">matrix1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">matrix0</span><span class="p">,</span> <span class="n">matrix1</span><span class="p">)</span>


<div class="viewcode-block" id="_import_module"><a class="viewcode-back" href="../../../encodermap.misc.html#encodermap.misc.transformations._import_module">[docs]</a><span class="k">def</span> <span class="nf">_import_module</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;_py_&quot;</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="s2">&quot;_&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Try import all public attributes from module into global namespace.</span>

<span class="sd">    Existing attributes with name clashes are renamed with prefix.</span>
<span class="sd">    Attributes starting with underscore are ignored by default.</span>

<span class="sd">    Return True on successful import.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">warnings</span>
    <span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">package</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">,</span> <span class="n">package</span><span class="o">=</span><span class="n">package</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;failed to import module </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">module</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ignore</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ignore</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">():</span>
                    <span class="nb">globals</span><span class="p">()[</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">attr</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">warn</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;no Python implementation of &quot;</span> <span class="o">+</span> <span class="n">attr</span><span class="p">)</span>
            <span class="nb">globals</span><span class="p">()[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<span class="c1"># print(&quot;about to do import_module, id(inverse_matrix) = %x&quot; % id(inverse_matrix))</span>
<span class="n">_import_module</span><span class="p">(</span><span class="s2">&quot;transformations._transformations&quot;</span><span class="p">)</span>
<span class="c1"># print(&quot;after done import_module, id(inverse_matrix) = %x&quot; % id(inverse_matrix))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="kn">import</span> <span class="nn">random</span>  <span class="c1"># used in doctests</span>

    <span class="n">numpy</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">()</span>
</pre></div>

            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  
</div>

<div class="toc-item">
  
</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2023, Kevin Sawade, Tobias Lemke.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="theme-version">
    Built with the
    <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">
        PyData Sphinx Theme
    </a>
    0.12.0.
</p>
  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
</div>
  </footer>
  </body>
</html>